<!doctype html>
<html class="no-js">
  <head><meta charset="utf-8"/>
    <meta name="viewport" content="width=device-width,initial-scale=1"/>
    <meta name="color-scheme" content="light dark"><link rel="index" title="Index" href="../genindex.html" /><link rel="search" title="Search" href="../search.html" />

    <meta name="generator" content="sphinx-3.5.2, furo 2021.03.20.beta30"/>
        <title>image_class_bs - EELSfitter 0.0.1 documentation</title>
      <link rel="stylesheet" href="../_static/styles/furo.css?digest=978e1795dfe158b585dda6a8417f6411828bf3ed">
    <link rel="stylesheet" href="../_static/pygments.css">
    <link media="(prefers-color-scheme: dark)" rel="stylesheet" href="../_static/pygments_dark.css">
    


<style>
  :root {
    --color-code-background: #f8f8f8;
  --color-code-foreground: black;
  
  }
  @media (prefers-color-scheme: dark) {
    :root {
      --color-code-background: #202020;
  --color-code-foreground: #d0d0d0;
  
    }
  }

  /* For allowing end-user-specific overrides */
  .override-light {
    --color-code-background: #f8f8f8;
  --color-code-foreground: black;
  
  }
  .override-dark {
    --color-code-background: #202020;
  --color-code-foreground: #d0d0d0;
  
  }
</style><link rel="stylesheet" href="../_static/styles/furo-extensions.css?digest=d391b54134226e4196576da3bdb6dddb7e05ba2b"></head>
  <body dir="">
    
<svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
  <symbol id="svg-toc" viewBox="0 0 24 24">
    <title>Contents</title>
    <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none"
      stroke-width="1.5" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round">
      <path stroke="none" d="M0 0h24v24H0z"/>
      <line x1="4" y1="6" x2="20" y2="6" />
      <line x1="10" y1="12" x2="20" y2="12" />
      <line x1="6" y1="18" x2="20" y2="18" />
    </svg>
  </symbol>
  <symbol id="svg-menu" viewBox="0 0 24 24">
    <title>Menu</title>
    <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none"
      stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"
      class="feather feather-menu">
      <line x1="3" y1="12" x2="21" y2="12"></line>
      <line x1="3" y1="6" x2="21" y2="6"></line>
      <line x1="3" y1="18" x2="21" y2="18"></line>
    </svg>
  </symbol>
  <symbol id="svg-arrow-right" viewBox="0 0 24 24">
    <title>Expand</title>
    <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none"
      stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"
      class="feather feather-chevron-right">
      <polyline points="9 18 15 12 9 6"></polyline>
    </svg>
  </symbol>
</svg>

<input type="checkbox" class="sidebar-toggle" name="__navigation" id="__navigation">
<input type="checkbox" class="sidebar-toggle" name="__toc" id="__toc">
<label class="overlay sidebar-overlay" for="__navigation"></label>
<label class="overlay toc-overlay" for="__toc"></label>



<div class="page">
  <header class="mobile-header">
    <div class="header-left">
      <label class="nav-overlay-icon" for="__navigation">
        <i class="icon"><svg><use href="#svg-menu"></use></svg></i>
      </label>
    </div>
    <div class="header-center">
      <a href="../index.html"><div class="brand">EELSfitter 0.0.1 documentation</div></a>
    </div>
    <div class="header-right">
      <label class="toc-overlay-icon toc-header-icon no-toc" for="__toc">
        <i class="icon"><svg><use href="#svg-toc"></use></svg></i>
      </label>
    </div>
  </header>
  <aside class="sidebar-drawer">
    <div class="sidebar-container">
      
      <div class="sidebar-sticky"><a class="sidebar-brand" href="../index.html">
  
  
  <span class="sidebar-brand-text">EELSfitter 0.0.1 documentation</span>
  
</a><form class="sidebar-search-container" method="get" action="../search.html">
  <input class="sidebar-search" placeholder=Search name="q">
  <input type="hidden" name="check_keywords" value="yes">
  <input type="hidden" name="area" value="default">
</form><div class="sidebar-scroll"><div class="sidebar-tree">
  <p class="caption"><span class="caption-text">Contents:</span></p>
<ul>
<li class="toctree-l1 has-children"><a class="reference internal" href="../modules/modules.html">bash_train_pyfiles</a><input class="toctree-checkbox" id="toctree-checkbox-1" name="toctree-checkbox-1" type="checkbox"/><label for="toctree-checkbox-1"><i class="icon"><svg><use href="#svg-arrow-right"></use></svg></i></label><ul>
<li class="toctree-l2"><a class="reference internal" href="../modules/KK_MPI_per_row.html">KK_MPI_per_row module</a></li>
<li class="toctree-l2"><a class="reference internal" href="../modules/KK_analysis_models_bs.html">KK_analysis_models_bs module</a></li>
<li class="toctree-l2"><a class="reference internal" href="../modules/KK_meta.html">KK_meta module</a></li>
<li class="toctree-l2"><a class="reference internal" href="../modules/KK_one_pixel.html">KK_one_pixel module</a></li>
<li class="toctree-l2"><a class="reference internal" href="../modules/KK_per_row.html">KK_per_row module</a></li>
<li class="toctree-l2"><a class="reference internal" href="../modules/KK_pixel.html">KK_pixel module</a></li>
<li class="toctree-l2"><a class="reference internal" href="../modules/KK_plot_results.html">KK_plot_results module</a></li>
<li class="toctree-l2"><a class="reference internal" href="../modules/KK_save_results.html">KK_save_results module</a></li>
<li class="toctree-l2"><a class="reference internal" href="../modules/calculate_dist_KK_results.html">calculate_dist_KK_results module</a></li>
<li class="toctree-l2"><a class="reference internal" href="../modules/image_class_bs.html">image_class_bs module</a></li>
<li class="toctree-l2"><a class="reference internal" href="../modules/k_means_clustering.html">k_means_clustering module</a></li>
<li class="toctree-l2"><a class="reference internal" href="../modules/plot_results_dE.html">plot_results_dE module</a></li>
<li class="toctree-l2"><a class="reference internal" href="../modules/train_nn_torch_bs.html">train_nn_torch_bs module</a></li>
<li class="toctree-l2"><a class="reference internal" href="../modules/training_images_bs.html">training_images_bs module</a></li>
<li class="toctree-l2"><a class="reference internal" href="../modules/untitled7.html">untitled7 module</a></li>
</ul>
</li>
</ul>

</div>
</div>
      </div>
      
    </div>
  </aside>
  <main class="main">
    <div class="content">
      <article role="main">
        <label class="toc-overlay-icon toc-content-icon no-toc" for="__toc">
          <i class="icon"><svg><use href="#svg-toc"></use></svg></i>
        </label>
        <h1>Source code for image_class_bs</h1><div class="highlight"><pre>
<span></span><span class="ch">#!/usr/bin/env python3</span>
<span class="c1"># -*- coding: utf-8 -*-</span>
<span class="sd">"""</span>
<span class="sd">Created on Fri Dec 18 17:38:57 2020</span>

<span class="sd">@author: isabel</span>
<span class="sd">"""</span>
<span class="c1">#!/usr/bin/env python3</span>
<span class="c1"># -*- coding: utf-8 -*-</span>
<span class="sd">"""</span>
<span class="sd">Created on Thu Dec 17 23:12:19 2020</span>

<span class="sd">@author: isabel</span>
<span class="sd">"""</span>
<span class="c1">#!/usr/bin/env python3</span>
<span class="c1"># -*- coding: utf-8 -*-</span>
<span class="sd">"""</span>
<span class="sd">Created on Tue Nov 10 01:05:56 2020</span>

<span class="sd">@author: isabel</span>
<span class="sd">"""</span>

<span class="kn">import</span> <span class="nn">pandas</span> <span class="k">as</span> <span class="nn">pd</span>
<span class="kn">import</span> <span class="nn">glob</span>
<span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>
<span class="kn">import</span> <span class="nn">seaborn</span> <span class="k">as</span> <span class="nn">sns</span>
<span class="kn">import</span> <span class="nn">natsort</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">math</span>
<span class="kn">from</span> <span class="nn">scipy.fftpack</span> <span class="kn">import</span> <span class="n">next_fast_len</span>
<span class="kn">from</span> <span class="nn">scipy.optimize</span> <span class="kn">import</span> <span class="n">curve_fit</span>
<span class="kn">import</span> <span class="nn">logging</span>
<span class="kn">from</span> <span class="nn">ncempy.io</span> <span class="kn">import</span> <span class="n">dm</span>
<span class="kn">import</span> <span class="nn">os</span>
<span class="kn">import</span> <span class="nn">copy</span>
<span class="kn">import</span> <span class="nn">pickle</span>

<span class="kn">import</span> <span class="nn">torch</span>
<span class="kn">import</span> <span class="nn">torch.nn</span> <span class="k">as</span> <span class="nn">nn</span>
<span class="kn">import</span> <span class="nn">torch.nn.functional</span> <span class="k">as</span> <span class="nn">F</span>


<span class="kn">from</span> <span class="nn">k_means_clustering</span> <span class="kn">import</span> <span class="n">k_means</span>
<span class="kn">from</span> <span class="nn">train_nn_torch_bs</span> <span class="kn">import</span> <span class="n">train_nn_scaled</span>


<span class="n">_logger</span> <span class="o">=</span> <span class="n">logging</span><span class="o">.</span><span class="n">getLogger</span><span class="p">(</span><span class="vm">__name__</span><span class="p">)</span>


<div class="viewcode-block" id="Spectral_image"><a class="viewcode-back" href="../modules/image_class_bs.html#image_class_bs.Spectral_image">[docs]</a><span class="k">class</span> <span class="nc">Spectral_image</span><span class="p">():</span>
    <span class="n">DIELECTRIC_FUNCTION_NAMES</span> <span class="o">=</span> <span class="p">[</span><span class="s1">'dielectric_function'</span><span class="p">,</span> <span class="s1">'dielectricfunction'</span><span class="p">,</span> <span class="s1">'dielec_func'</span><span class="p">,</span> <span class="s1">'die_fun'</span><span class="p">,</span> <span class="s1">'df'</span><span class="p">,</span> <span class="s1">'epsilon'</span><span class="p">]</span>
    <span class="n">EELS_NAMES</span> <span class="o">=</span> <span class="p">[</span><span class="s1">'electron_energy_loss_spectrum'</span><span class="p">,</span><span class="s1">'electron_energy_loss'</span><span class="p">,</span><span class="s1">'EELS'</span><span class="p">,</span> <span class="s1">'EEL'</span><span class="p">,</span> <span class="s1">'energy_loss'</span><span class="p">,</span> <span class="s1">'data'</span><span class="p">]</span>
    <span class="n">IEELS_NAMES</span> <span class="o">=</span> <span class="p">[</span><span class="s1">'inelastic_scattering_energy_loss_spectrum'</span><span class="p">,</span> <span class="s1">'inelastic_scattering_energy_loss'</span><span class="p">,</span> <span class="s1">'inelastic_scattering'</span><span class="p">,</span> <span class="s1">'IEELS'</span><span class="p">,</span> <span class="s1">'IES'</span><span class="p">]</span>
    <span class="n">ZLP_NAMES</span> <span class="o">=</span> <span class="p">[</span><span class="s1">'zeros_loss_peak'</span><span class="p">,</span> <span class="s1">'zero_loss'</span><span class="p">,</span> <span class="s1">'ZLP'</span><span class="p">,</span> <span class="s1">'ZLPs'</span><span class="p">,</span> <span class="s1">'zlp'</span><span class="p">,</span> <span class="s1">'zlps'</span><span class="p">]</span>
    <span class="n">THICKNESS_NAMES</span> <span class="o">=</span> <span class="p">[</span><span class="s1">'t'</span><span class="p">,</span> <span class="s1">'thickness'</span><span class="p">,</span> <span class="s1">'thick'</span><span class="p">,</span> <span class="s1">'thin'</span><span class="p">]</span>
    
    <span class="n">m_0</span> <span class="o">=</span> <span class="mf">511.06</span> <span class="c1">#eV, electron rest mass</span>
    <span class="n">a_0</span> <span class="o">=</span> <span class="mf">5.29E-11</span> <span class="c1">#m, Bohr radius</span>
    <span class="n">h_bar</span> <span class="o">=</span> <span class="mf">6.582119569E-16</span> <span class="c1">#eV/s</span>
    <span class="n">c</span> <span class="o">=</span> <span class="mf">2.99792458E8</span> <span class="c1">#m/s</span>
    
    
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">deltadeltaE</span><span class="p">,</span> <span class="n">pixelsize</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">beam_energy</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">collection_angle</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">name</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">"""</span>
<span class="sd">        INPUT:</span>
<span class="sd">            data = 3D-numpy array (x-axis x y-axis x energy loss-axis), spectral image data</span>
<span class="sd">            deltadeltaE = float, width of energy loss bins</span>
<span class="sd">        Keyword-arguments:</span>
<span class="sd">            pixelsize = float (default: None), width of pixels</span>
<span class="sd">            beam_energy = float (default: None), energy of electron beam [eV]</span>
<span class="sd">            collection_angle = float (default: None), collection angle of STEM [rad]</span>
<span class="sd">            name = str (default: None), name if given along is used in title of plots</span>
<span class="sd">        """</span>
        
        <span class="bp">self</span><span class="o">.</span><span class="n">data</span> <span class="o">=</span> <span class="n">data</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">ddeltaE</span> <span class="o">=</span> <span class="n">deltadeltaE</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">determine_deltaE</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">pixelsize</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">pixelsize</span> <span class="o">=</span> <span class="n">pixelsize</span><span class="o">*</span><span class="mf">1E6</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">calc_axes</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">beam_energy</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">beam_energy</span> <span class="o">=</span> <span class="n">beam_energy</span>
        <span class="k">if</span> <span class="n">collection_angle</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">collection_angle</span> <span class="o">=</span> <span class="n">collection_angle</span>
        <span class="k">if</span> <span class="n">name</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="n">name</span>
    
<div class="viewcode-block" id="Spectral_image.save_image"><a class="viewcode-back" href="../modules/image_class_bs.html#image_class_bs.Spectral_image.save_image">[docs]</a>    <span class="k">def</span> <span class="nf">save_image</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">filename</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">filename</span><span class="p">[</span><span class="o">-</span><span class="mi">4</span><span class="p">:]</span> <span class="o">!=</span> <span class="s1">'.pkl'</span><span class="p">:</span>
            <span class="n">filename</span> <span class="o">+</span> <span class="s1">'.pkl'</span>
        <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">filename</span><span class="p">,</span> <span class="s1">'wb'</span><span class="p">)</span> <span class="k">as</span> <span class="n">output</span><span class="p">:</span>  <span class="c1"># Overwrites any existing file.</span>
            <span class="n">pickle</span><span class="o">.</span><span class="n">dump</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">output</span><span class="p">,</span> <span class="n">pickle</span><span class="o">.</span><span class="n">HIGHEST_PROTOCOL</span><span class="p">)</span></div>

    
    <span class="c1">#%%GENERAL FUNCTIONS</span>
    
    <span class="c1">#%%PROPERTIES</span>
    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">l</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">"""returns length of spectra, i.e. num energy loss bins"""</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>
    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">image_shape</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">"""return 2D-shape of spectral image"""</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">[:</span><span class="mi">2</span><span class="p">]</span>
    
    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">shape</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">"""returns 3D-shape of spectral image"""</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">shape</span>
        
    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">n_clusters</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">"""return number of clusters image is clustered into"""</span>
        <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">clusters</span><span class="p">)</span>
    
    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">n_spectra</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">"""returns number of spectra in specral image"""</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">product</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">image_shape</span><span class="p">)</span>
    
<div class="viewcode-block" id="Spectral_image.load_data"><a class="viewcode-back" href="../modules/image_class_bs.html#image_class_bs.Spectral_image.load_data">[docs]</a>    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">load_data</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">path_to_dmfile</span><span class="p">):</span>
        <span class="sd">"""</span>
<span class="sd">        INPUT: </span>
<span class="sd">            path_to_dmfile: str, path to spectral image file (.dm3 or .dm4 extension)</span>
<span class="sd">        OUTPUT:</span>
<span class="sd">            image -- Spectral_image, object of Spectral_image class containing the data of the dm-file</span>
<span class="sd">        """</span>
        <span class="n">dmfile_tot</span> <span class="o">=</span> <span class="n">dm</span><span class="o">.</span><span class="n">fileDM</span><span class="p">(</span><span class="n">path_to_dmfile</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">dmfile_tot</span><span class="o">.</span><span class="n">numObjects</span> <span class="o">-</span> <span class="n">dmfile_tot</span><span class="o">.</span><span class="n">thumbnail</span><span class="o">*</span><span class="mi">1</span><span class="p">):</span>
            <span class="n">dmfile</span> <span class="o">=</span> <span class="n">dmfile_tot</span><span class="o">.</span><span class="n">getDataset</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">dmfile</span><span class="p">[</span><span class="s1">'data'</span><span class="p">]</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">3</span><span class="p">:</span>
                <span class="n">dmfile</span> <span class="o">=</span> <span class="n">dmfile_tot</span><span class="o">.</span><span class="n">getDataset</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
                <span class="n">data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">swapaxes</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">swapaxes</span><span class="p">(</span><span class="n">dmfile</span><span class="p">[</span><span class="s1">'data'</span><span class="p">],</span> <span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">),</span> <span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">)</span>
                <span class="k">break</span>
            <span class="k">elif</span> <span class="n">i</span> <span class="o">==</span> <span class="n">dmfile_tot</span><span class="o">.</span><span class="n">numObjects</span> <span class="o">-</span> <span class="n">dmfile_tot</span><span class="o">.</span><span class="n">thumbnail</span><span class="o">*</span><span class="mi">1</span> <span class="o">-</span> <span class="mi">1</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="s2">"No spectral image detected"</span><span class="p">)</span>
                <span class="n">dmfile</span> <span class="o">=</span> <span class="n">dmfile_tot</span><span class="o">.</span><span class="n">getDataset</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
                <span class="n">data</span> <span class="o">=</span> <span class="n">dmfile</span><span class="p">[</span><span class="s1">'data'</span><span class="p">]</span>
        
        <span class="c1">#.getDataset(0)</span>
        <span class="n">ddeltaE</span> <span class="o">=</span> <span class="n">dmfile</span><span class="p">[</span><span class="s1">'pixelSize'</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">pixelsize</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">dmfile</span><span class="p">[</span><span class="s1">'pixelSize'</span><span class="p">][</span><span class="mi">1</span><span class="p">:])</span>
        <span class="n">energyUnit</span> <span class="o">=</span> <span class="n">dmfile</span><span class="p">[</span><span class="s1">'pixelUnit'</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">ddeltaE</span> <span class="o">*=</span> <span class="bp">cls</span><span class="o">.</span><span class="n">get_prefix</span><span class="p">(</span><span class="n">energyUnit</span><span class="p">,</span> <span class="s1">'eV'</span><span class="p">)</span>
        <span class="n">pixelUnit</span> <span class="o">=</span> <span class="n">dmfile</span><span class="p">[</span><span class="s1">'pixelUnit'</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">pixelsize</span> <span class="o">*=</span> <span class="bp">cls</span><span class="o">.</span><span class="n">get_prefix</span><span class="p">(</span><span class="n">pixelUnit</span><span class="p">,</span> <span class="s1">'m'</span><span class="p">)</span>
        <span class="n">image</span> <span class="o">=</span> <span class="bp">cls</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">ddeltaE</span><span class="p">,</span> <span class="n">pixelsize</span> <span class="o">=</span> <span class="n">pixelsize</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="n">path_to_dmfile</span><span class="p">[:</span><span class="o">-</span><span class="mi">4</span><span class="p">])</span>
        <span class="k">return</span> <span class="n">image</span></div>
    
<div class="viewcode-block" id="Spectral_image.load_Spectral_image"><a class="viewcode-back" href="../modules/image_class_bs.html#image_class_bs.Spectral_image.load_Spectral_image">[docs]</a>    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">load_Spectral_image</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">path_to_pickle</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">path_to_pickle</span><span class="p">[</span><span class="o">-</span><span class="mi">4</span><span class="p">:]</span> <span class="o">!=</span> <span class="s1">'.pkl'</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">"please provide a path to a pickle file containing a Spectrall_image class object."</span><span class="p">)</span>
            <span class="k">return</span>
        <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">path_to_pickle</span><span class="p">,</span> <span class="s1">'rb'</span><span class="p">)</span> <span class="k">as</span> <span class="nb">input</span><span class="p">:</span>
            <span class="n">image</span> <span class="o">=</span> <span class="n">pickle</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="nb">input</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">image</span></div>
    
    
<div class="viewcode-block" id="Spectral_image.determine_deltaE"><a class="viewcode-back" href="../modules/image_class_bs.html#image_class_bs.Spectral_image.determine_deltaE">[docs]</a>    <span class="k">def</span> <span class="nf">determine_deltaE</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">"""</span>
<span class="sd">        INPUT: </span>
<span class="sd">            self</span>
<span class="sd">        </span>
<span class="sd">        Determines the delta energies of the spectral image, based on the delta delta energie,</span>
<span class="sd">        and the index on which the spectral image has on average the highest intesity, this </span>
<span class="sd">        is taken as the zero point for the delta energy.</span>
<span class="sd">        """</span>
        <span class="n">data_avg</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">average</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">,</span> <span class="n">axis</span> <span class="o">=</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">))</span>
        <span class="n">ind_max</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argmax</span><span class="p">(</span><span class="n">data_avg</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">deltaE</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="o">-</span><span class="n">ind_max</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">ddeltaE</span><span class="p">,</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">l</span><span class="o">-</span><span class="n">ind_max</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">ddeltaE</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">l</span><span class="p">)</span></div>
        <span class="c1">#return deltaE</span>
    
    
<div class="viewcode-block" id="Spectral_image.calc_axes"><a class="viewcode-back" href="../modules/image_class_bs.html#image_class_bs.Spectral_image.calc_axes">[docs]</a>    <span class="k">def</span> <span class="nf">calc_axes</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">y_axis</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">image_shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">image_shape</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">x_axis</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">image_shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">image_shape</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s1">'pixelsize'</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">y_axis</span> <span class="o">*=</span> <span class="bp">self</span><span class="o">.</span><span class="n">pixelsize</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">x_axis</span> <span class="o">*=</span> <span class="bp">self</span><span class="o">.</span><span class="n">pixelsize</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> </div>
    
    <span class="c1">#%%RETRIEVING FUNCTIONS</span>
<div class="viewcode-block" id="Spectral_image.get_data"><a class="viewcode-back" href="../modules/image_class_bs.html#image_class_bs.Spectral_image.get_data">[docs]</a>    <span class="k">def</span> <span class="nf">get_data</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span> <span class="c1">#TODO: add smooth possibility</span>
        <span class="sd">"""returns spectra image data in 3D-numpy array (x-axis x y-axis x energy loss-axis)"""</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span></div>
    
<div class="viewcode-block" id="Spectral_image.get_deltaE"><a class="viewcode-back" href="../modules/image_class_bs.html#image_class_bs.Spectral_image.get_deltaE">[docs]</a>    <span class="k">def</span> <span class="nf">get_deltaE</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">"""returns energy loss axis in numpy array"""</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">deltaE</span></div>
    
<div class="viewcode-block" id="Spectral_image.get_metadata"><a class="viewcode-back" href="../modules/image_class_bs.html#image_class_bs.Spectral_image.get_metadata">[docs]</a>    <span class="k">def</span> <span class="nf">get_metadata</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">"""returns list with values for beam_energy and collection_angle, if defined"""</span>
        <span class="n">meta_data</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">beam_energy</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">meta_data</span><span class="p">[</span><span class="s1">'beam_energy'</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">beam_energy</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">collection_angle</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">meta_data</span><span class="p">[</span><span class="s1">'collection_angle'</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">collection_angle</span>
        <span class="k">return</span> <span class="n">meta_data</span></div>
    
<div class="viewcode-block" id="Spectral_image.get_pixel_signal"><a class="viewcode-back" href="../modules/image_class_bs.html#image_class_bs.Spectral_image.get_pixel_signal">[docs]</a>    <span class="k">def</span> <span class="nf">get_pixel_signal</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">,</span> <span class="n">signal</span> <span class="o">=</span> <span class="s1">'EELS'</span><span class="p">):</span>
        <span class="sd">"""</span>
<span class="sd">        INPUT:</span>
<span class="sd">            i: int, x-coordinate for the pixel</span>
<span class="sd">            j: int, y-coordinate for the pixel</span>
<span class="sd">        Keyword argument:</span>
<span class="sd">            signal: str (default = 'EELS'), what signal is requested, should comply with defined names</span>
<span class="sd">        OUTPUT:</span>
<span class="sd">            signal: 1D numpy array, array with the requested signal from the requested pixel</span>
<span class="sd">        """</span>
        <span class="c1">#TODO: add alternative signals + names</span>
        <span class="k">if</span> <span class="n">signal</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">EELS_NAMES</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">[</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="p">:])</span>
        <span class="k">elif</span> <span class="n">signal</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">DIELECTRIC_FUNCTION_NAMES</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dielectric_function_im_avg</span><span class="p">[</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="p">:])</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">[</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="p">:])</span></div>
    
    
<div class="viewcode-block" id="Spectral_image.get_cluster_spectra"><a class="viewcode-back" href="../modules/image_class_bs.html#image_class_bs.Spectral_image.get_cluster_spectra">[docs]</a>    <span class="k">def</span> <span class="nf">get_cluster_spectra</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">conf_interval</span> <span class="o">=</span> <span class="mf">0.68</span><span class="p">,</span> <span class="n">clusters</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">save_as_attribute</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span> <span class="n">based_upon</span> <span class="o">=</span> <span class="s2">"sum"</span><span class="p">):</span>
        <span class="sd">"""</span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        conf_interval : float, optional</span>
<span class="sd">            The ratio of spectra returned. The spectra are selected based on the </span>
<span class="sd">            based_upon value. The default is 0.68.</span>
<span class="sd">        clusters : list of ints, optional #TODO: finish</span>
<span class="sd">            DESCRIPTION. The default is None.</span>
<span class="sd">        save_as_attribute : TYPE, optional</span>
<span class="sd">            DESCRIPTION. The default is False.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        cluster_data : np.array of type object, filled with 2D numpy arrays</span>
<span class="sd">            Each cell of the super numpy array is filled with the data of all spectra </span>
<span class="sd">            with in one of the requested clusters.</span>
<span class="sd">            </span>
<span class="sd">        Atributes</span>
<span class="sd">        ---------</span>
<span class="sd">        self.cluster_data: np.array of type object, filled with 2D numpy arrays</span>
<span class="sd">            If save_as_attribute set to True, the cluster data is also saved as attribute</span>

<span class="sd">        """</span>
        
        <span class="k">if</span> <span class="n">clusters</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">clusters</span> <span class="o">=</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n_clusters</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">conf_interval</span> <span class="o">&gt;=</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">ci_lim</span> <span class="o">=</span> <span class="mi">0</span>
        
        <span class="n">integrated_I</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">,</span> <span class="n">axis</span> <span class="o">=</span> <span class="mi">2</span><span class="p">)</span>
        <span class="n">cluster_data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">clusters</span><span class="p">),</span> <span class="n">dtype</span> <span class="o">=</span> <span class="nb">object</span><span class="p">)</span>
        
        <span class="n">j</span><span class="o">=</span><span class="mi">0</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">clusters</span><span class="p">:</span>
            <span class="n">data_cluster</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">clustered</span> <span class="o">==</span> <span class="n">i</span><span class="p">]</span>
            <span class="n">intensities_cluster</span> <span class="o">=</span> <span class="n">integrated_I</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">clustered</span> <span class="o">==</span> <span class="n">i</span><span class="p">]</span>
            <span class="n">arg_sort_I</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argsort</span><span class="p">(</span><span class="n">intensities_cluster</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">conf_interval</span> <span class="o">&lt;</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">ci_lim</span> <span class="o">=</span> <span class="nb">round</span><span class="p">((</span><span class="mi">1</span><span class="o">-</span><span class="n">conf_interval</span><span class="p">)</span><span class="o">/</span><span class="mi">2</span> <span class="o">*</span><span class="n">intensities_cluster</span><span class="o">.</span><span class="n">size</span><span class="p">)</span> <span class="c1">#TODO: ask juan: round up or down?</span>
            <span class="n">data_cluster</span> <span class="o">=</span> <span class="n">data_cluster</span><span class="p">[</span><span class="n">arg_sort_I</span><span class="p">][</span><span class="n">ci_lim</span><span class="p">:</span><span class="o">-</span><span class="n">ci_lim</span><span class="p">]</span>
            <span class="n">intensities_cluster</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">intensities_cluster</span><span class="p">)</span><span class="o">-</span><span class="mi">2</span><span class="o">*</span><span class="n">ci_lim</span><span class="p">)</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">clusters</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
            <span class="n">cluster_data</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">data_cluster</span>
            <span class="n">j</span> <span class="o">+=</span> <span class="mi">1</span>
        
        <span class="k">if</span> <span class="n">save_as_attribute</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">cluster_data</span> <span class="o">=</span> <span class="n">cluster_data</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">cluster_data</span></div>
    
    
    <span class="c1">#%%METHODS ON SIGNAL</span>
    
<div class="viewcode-block" id="Spectral_image.cut"><a class="viewcode-back" href="../modules/image_class_bs.html#image_class_bs.Spectral_image.cut">[docs]</a>    <span class="k">def</span> <span class="nf">cut</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">E1</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">E2</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">in_ex</span> <span class="o">=</span> <span class="s2">"in"</span><span class="p">):</span>
        <span class="sd">"""</span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        E1 : TYPE, optional</span>
<span class="sd">            DESCRIPTION. The default is None.</span>
<span class="sd">        E2 : TYPE, optional</span>
<span class="sd">            DESCRIPTION. The default is None.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        None.</span>
<span class="sd">        """</span>
        <span class="k">if</span> <span class="n">E1</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">E1</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">deltaE</span><span class="o">.</span><span class="n">min</span><span class="p">()</span> <span class="o">-</span><span class="mi">1</span>
        <span class="k">if</span> <span class="n">E2</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">E2</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">deltaE</span><span class="o">.</span><span class="n">max</span><span class="p">()</span> <span class="o">+</span><span class="mi">1</span>
        <span class="k">if</span> <span class="n">in_ex</span> <span class="o">==</span> <span class="s2">"in"</span><span class="p">:</span>
            <span class="n">select</span> <span class="o">=</span> <span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">deltaE</span> <span class="o">&gt;=</span> <span class="n">E1</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">deltaE</span> <span class="o">&lt;=</span> <span class="n">E2</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span> 
            <span class="n">select</span> <span class="o">=</span> <span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">deltaE</span> <span class="o">&gt;</span> <span class="n">E1</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">deltaE</span> <span class="o">&lt;</span> <span class="n">E2</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">[:,:,</span><span class="n">select</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">deltaE</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">deltaE</span><span class="p">[</span><span class="n">select</span><span class="p">]</span>
        <span class="c1">#TODO add selecting of all attributes</span>
        <span class="k">pass</span></div>
    
<div class="viewcode-block" id="Spectral_image.cut_image"><a class="viewcode-back" href="../modules/image_class_bs.html#image_class_bs.Spectral_image.cut_image">[docs]</a>    <span class="k">def</span> <span class="nf">cut_image</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">range_width</span><span class="p">,</span> <span class="n">range_height</span><span class="p">):</span>
        <span class="c1">#TODO: add floats for cutting to meter sizes?</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="n">range_height</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span><span class="n">range_height</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">range_width</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span><span class="n">range_width</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">y_axis</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">y_axis</span><span class="p">[</span><span class="n">range_height</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span><span class="n">range_height</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">x_axis</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">x_axis</span><span class="p">[</span><span class="n">range_width</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span><span class="n">range_width</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span></div>
    
    <span class="c1">#TODO</span>
<div class="viewcode-block" id="Spectral_image.samenvoegen"><a class="viewcode-back" href="../modules/image_class_bs.html#image_class_bs.Spectral_image.samenvoegen">[docs]</a>    <span class="k">def</span> <span class="nf">samenvoegen</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">pass</span></div>
    
<div class="viewcode-block" id="Spectral_image.smooth"><a class="viewcode-back" href="../modules/image_class_bs.html#image_class_bs.Spectral_image.smooth">[docs]</a>    <span class="k">def</span> <span class="nf">smooth</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">window_len</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span><span class="n">window</span><span class="o">=</span><span class="s1">'hanning'</span><span class="p">,</span> <span class="n">keep_original</span> <span class="o">=</span> <span class="kc">False</span><span class="p">):</span>
        <span class="sd">"""smooth the data using a window with requested size.</span>
<span class="sd">        </span>
<span class="sd">        This method is based on the convolution of a scaled window with the signal.</span>
<span class="sd">        The signal is prepared by introducing reflected copies of the signal </span>
<span class="sd">        (with the window size) in both ends so that transient parts are minimized</span>
<span class="sd">        in the begining and end part of the output signal.</span>
<span class="sd">        </span>
<span class="sd">        input:</span>
<span class="sd">            x: the input signal </span>
<span class="sd">            window_len: the dimension of the smoothing window; should be an odd integer</span>
<span class="sd">            window: the type of window from 'flat', 'hanning', 'hamming', 'bartlett', 'blackman'</span>
<span class="sd">                flat window will produce a moving average smoothing.</span>
<span class="sd">    </span>
<span class="sd">        output:</span>
<span class="sd">            the smoothed signal</span>
<span class="sd">    </span>
<span class="sd">        """</span>
        <span class="c1">#TODO: add comnparison</span>
        <span class="n">window_len</span> <span class="o">+=</span> <span class="p">(</span><span class="n">window_len</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">%</span><span class="mi">2</span>
        <span class="n">s</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">r_</span><span class="p">[</span><span class="s1">'-1'</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">[:,:,</span><span class="n">window_len</span><span class="o">-</span><span class="mi">1</span><span class="p">:</span><span class="mi">0</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span><span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">[:,:,</span><span class="o">-</span><span class="mi">2</span><span class="p">:</span><span class="o">-</span><span class="n">window_len</span><span class="o">-</span><span class="mi">1</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">]]</span>
    
        <span class="k">if</span> <span class="n">window</span> <span class="o">==</span> <span class="s1">'flat'</span><span class="p">:</span> <span class="c1">#moving average</span>
            <span class="n">w</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">window_len</span><span class="p">,</span><span class="s1">'d'</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">w</span><span class="o">=</span><span class="nb">eval</span><span class="p">(</span><span class="s1">'np.'</span><span class="o">+</span><span class="n">window</span><span class="o">+</span><span class="s1">'(window_len)'</span><span class="p">)</span>
        
        <span class="c1">#y=np.convolve(w/w.sum(),s,mode='valid')</span>
        <span class="n">surplus_data</span> <span class="o">=</span> <span class="nb">int</span><span class="p">((</span><span class="n">window_len</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="mf">0.5</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">keep_original</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">data_smooth</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">apply_along_axis</span><span class="p">(</span><span class="k">lambda</span> <span class="n">m</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">convolve</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="n">w</span><span class="o">/</span><span class="n">w</span><span class="o">.</span><span class="n">sum</span><span class="p">(),</span> <span class="n">mode</span><span class="o">=</span><span class="s1">'valid'</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">arr</span><span class="o">=</span><span class="n">s</span><span class="p">)[:,:,</span><span class="n">surplus_data</span><span class="p">:</span><span class="o">-</span><span class="n">surplus_data</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">apply_along_axis</span><span class="p">(</span><span class="k">lambda</span> <span class="n">m</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">convolve</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="n">w</span><span class="o">/</span><span class="n">w</span><span class="o">.</span><span class="n">sum</span><span class="p">(),</span> <span class="n">mode</span><span class="o">=</span><span class="s1">'valid'</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">arr</span><span class="o">=</span><span class="n">s</span><span class="p">)[:,:,</span><span class="n">surplus_data</span><span class="p">:</span><span class="o">-</span><span class="n">surplus_data</span><span class="p">]</span>
        
        
        <span class="k">return</span> <span class="c1">#y[(window_len-1):-(window_len)]</span></div>
    
    
<div class="viewcode-block" id="Spectral_image.deconvolute"><a class="viewcode-back" href="../modules/image_class_bs.html#image_class_bs.Spectral_image.deconvolute">[docs]</a>    <span class="k">def</span> <span class="nf">deconvolute</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">,</span> <span class="n">ZLP</span><span class="p">):</span>
        
        <span class="n">y</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_pixel_signal</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">)</span>
        <span class="n">r</span> <span class="o">=</span> <span class="mi">3</span> <span class="c1">#Drude model, can also use estimation from exp. data</span>
        <span class="n">A</span> <span class="o">=</span> <span class="n">y</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">n_times_extra</span> <span class="o">=</span> <span class="mi">2</span>
        <span class="n">sem_inf</span> <span class="o">=</span> <span class="n">next_fast_len</span><span class="p">(</span><span class="n">n_times_extra</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">l</span><span class="p">)</span>
        
        
        
        <span class="n">y_extrp</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">sem_inf</span><span class="p">)</span>
        <span class="n">y_ZLP_extrp</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">sem_inf</span><span class="p">)</span>
        <span class="n">x_extrp</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">deltaE</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">l</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">ddeltaE</span><span class="p">,</span> <span class="n">sem_inf</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">ddeltaE</span><span class="o">+</span><span class="bp">self</span><span class="o">.</span><span class="n">deltaE</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">l</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">ddeltaE</span><span class="p">,</span> <span class="n">sem_inf</span><span class="p">)</span>
        
        <span class="n">x_extrp</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">deltaE</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">sem_inf</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">ddeltaE</span><span class="o">+</span><span class="bp">self</span><span class="o">.</span><span class="n">deltaE</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">sem_inf</span><span class="p">)</span>

        <span class="n">y_ZLP_extrp</span><span class="p">[:</span><span class="bp">self</span><span class="o">.</span><span class="n">l</span><span class="p">]</span> <span class="o">=</span> <span class="n">ZLP</span>        
        <span class="n">y_extrp</span><span class="p">[:</span><span class="bp">self</span><span class="o">.</span><span class="n">l</span><span class="p">]</span> <span class="o">=</span> <span class="n">y</span>
        <span class="n">x_extrp</span><span class="p">[:</span><span class="bp">self</span><span class="o">.</span><span class="n">l</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">deltaE</span><span class="p">[</span><span class="o">-</span><span class="bp">self</span><span class="o">.</span><span class="n">l</span><span class="p">:]</span>
        
        <span class="n">y_extrp</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">l</span><span class="p">:]</span> <span class="o">=</span> <span class="n">A</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">power</span><span class="p">(</span><span class="mi">1</span><span class="o">+</span><span class="n">x_extrp</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">l</span><span class="p">:]</span><span class="o">-</span><span class="n">x_extrp</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">l</span><span class="p">],</span><span class="o">-</span><span class="n">r</span><span class="p">)</span>
        
        <span class="n">x</span> <span class="o">=</span> <span class="n">x_extrp</span>
        <span class="n">y</span> <span class="o">=</span> <span class="n">y_extrp</span>
        <span class="n">y_ZLP</span> <span class="o">=</span> <span class="n">y_ZLP_extrp</span>
        
        <span class="n">z_nu</span> <span class="o">=</span> <span class="n">CFT</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">y_ZLP</span><span class="p">)</span>
        <span class="n">i_nu</span> <span class="o">=</span> <span class="n">CFT</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">)</span>
        <span class="n">abs_i_nu</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">absolute</span><span class="p">(</span><span class="n">i_nu</span><span class="p">)</span>
        <span class="n">N_ZLP</span> <span class="o">=</span> <span class="mi">1</span><span class="c1">#scipy.integrate.cumtrapz(y_ZLP, x, initial=0)[-1]#1 #arbitrary units??? np.sum(EELZLP)</span>
        
        <span class="n">s_nu</span> <span class="o">=</span> <span class="n">N_ZLP</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">i_nu</span><span class="o">/</span><span class="n">z_nu</span><span class="p">)</span>
        <span class="n">j1_nu</span> <span class="o">=</span> <span class="n">z_nu</span><span class="o">*</span><span class="n">s_nu</span><span class="o">/</span><span class="n">N_ZLP</span>
        <span class="n">S_E</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">real</span><span class="p">(</span><span class="n">iCFT</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">s_nu</span><span class="p">))</span>
        <span class="n">s_nu_nc</span> <span class="o">=</span> <span class="n">s_nu</span>
        <span class="n">s_nu_nc</span><span class="p">[</span><span class="mi">500</span><span class="p">:</span><span class="o">-</span><span class="mi">500</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">S_E_nc</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">real</span><span class="p">(</span><span class="n">iCFT</span><span class="p">(</span> <span class="n">x</span><span class="p">,</span><span class="n">s_nu_nc</span><span class="p">))</span>
        <span class="n">J1_E</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">real</span><span class="p">(</span><span class="n">iCFT</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">j1_nu</span><span class="p">))</span>
        
        <span class="k">return</span> <span class="n">J1_E</span><span class="p">[:</span><span class="bp">self</span><span class="o">.</span><span class="n">l</span><span class="p">]</span></div>
    
    <span class="c1">#%%METHODS ON ZLP</span>
    <span class="c1">#CALCULATING ZLPs FROM PRETRAINDED MODELS</span>
  
  
       

    
<div class="viewcode-block" id="Spectral_image.calc_ZLPs"><a class="viewcode-back" href="../modules/image_class_bs.html#image_class_bs.Spectral_image.calc_ZLPs">[docs]</a>    <span class="k">def</span> <span class="nf">calc_ZLPs</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="c1">### Definition for the matching procedure</span>
        <span class="n">signal</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_pixel_signal</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">)</span>
        
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s1">'ZLP_models'</span><span class="p">):</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">load_ZLP_models_smefit</span><span class="p">(</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
            <span class="k">except</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">load_ZLP_models_smefit</span><span class="p">()</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s1">'ZLP_models'</span><span class="p">):</span>
            <span class="n">ans</span> <span class="o">=</span> <span class="nb">input</span><span class="p">(</span><span class="s2">"No ZLP models found. Please specify directory or train models. </span><span class="se">\n</span><span class="s2">"</span> <span class="o">+</span> 
                        <span class="s2">"Do you want to define path to models [p], train models [t] or quit [q]?</span><span class="se">\n</span><span class="s2">"</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">ans</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="s2">"q"</span><span class="p">:</span>
                <span class="k">return</span>
            <span class="k">elif</span> <span class="n">ans</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="s2">"p"</span><span class="p">:</span>
                <span class="n">path_to_models</span> <span class="o">=</span> <span class="nb">input</span><span class="p">(</span><span class="s2">"Please input path to models: </span><span class="se">\n</span><span class="s2">"</span><span class="p">)</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">load_ZLP_models</span><span class="p">(</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
                <span class="k">except</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">load_ZLP_models</span><span class="p">()</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s1">'ZLP_models'</span><span class="p">):</span>
                    <span class="nb">print</span><span class="p">(</span><span class="s2">"You had your chance. Please locate your models."</span><span class="p">)</span>
                    <span class="k">return</span>
            <span class="k">elif</span> <span class="n">ans</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="s2">"t"</span><span class="p">:</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">train_ZLPs</span><span class="p">(</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
                <span class="k">except</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">train_ZLPs</span><span class="p">()</span>
                <span class="k">if</span> <span class="s2">"path_to_models"</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="p">:</span>
                    <span class="n">path_to_models</span> <span class="o">=</span> <span class="n">kwargs</span><span class="p">[</span><span class="s2">"path_to_models"</span><span class="p">]</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">load_ZLP_models</span><span class="p">(</span><span class="n">path_to_models</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">load_ZLP_models</span><span class="p">()</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="s2">"unvalid input, not calculating ZLPs"</span><span class="p">)</span>
                <span class="k">return</span>
        
        
        <span class="n">cluster</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">clustered</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">]</span>
        
        <span class="c1">#TODO: aanpassen</span>
        <span class="k">def</span> <span class="nf">matching</span><span class="p">(</span> <span class="n">signal</span><span class="p">,</span> <span class="n">gen_i_ZLP</span><span class="p">,</span> <span class="n">dE1</span><span class="p">):</span>
            <span class="n">dE0</span> <span class="o">=</span> <span class="n">dE1</span> <span class="o">-</span> <span class="mf">0.5</span>
            <span class="n">dE2</span> <span class="o">=</span> <span class="n">dE1</span><span class="o">*</span><span class="mi">8</span>
            <span class="c1">#gen_i_ZLP = self.ZLPs_gen[ind_ZLP, :]#*np.max(signal)/np.max(self.ZLPs_gen[ind_ZLP,:]) #TODO!!!!, normalize?</span>
            <span class="n">delta</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">divide</span><span class="p">((</span><span class="n">dE1</span> <span class="o">-</span> <span class="n">dE0</span><span class="p">),</span> <span class="mi">3</span><span class="p">)</span>
            
            <span class="n">factor_NN</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">divide</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">deltaE</span><span class="p">[(</span><span class="bp">self</span><span class="o">.</span><span class="n">deltaE</span><span class="o">&lt;</span><span class="n">dE1</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">deltaE</span> <span class="o">&gt;=</span> <span class="n">dE0</span><span class="p">)]</span> <span class="o">-</span> <span class="n">dE1</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="p">,</span> <span class="n">delta</span><span class="o">**</span><span class="mi">2</span><span class="p">))</span>
            <span class="n">factor_dm</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">-</span> <span class="n">factor_NN</span>
            
            <span class="n">range_0</span> <span class="o">=</span> <span class="n">signal</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">deltaE</span> <span class="o">&lt;</span> <span class="n">dE0</span><span class="p">]</span>
            <span class="n">range_1</span> <span class="o">=</span> <span class="n">gen_i_ZLP</span><span class="p">[(</span><span class="bp">self</span><span class="o">.</span><span class="n">deltaE</span> <span class="o">&lt;</span> <span class="n">dE1</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">deltaE</span> <span class="o">&gt;=</span> <span class="n">dE0</span><span class="p">)]</span> <span class="o">*</span> <span class="n">factor_NN</span> <span class="o">+</span> <span class="n">signal</span><span class="p">[(</span><span class="bp">self</span><span class="o">.</span><span class="n">deltaE</span> <span class="o">&lt;</span> <span class="n">dE1</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">deltaE</span> <span class="o">&gt;=</span> <span class="n">dE0</span><span class="p">)]</span> <span class="o">*</span> <span class="n">factor_dm</span>
            <span class="n">range_2</span> <span class="o">=</span> <span class="n">gen_i_ZLP</span><span class="p">[(</span><span class="bp">self</span><span class="o">.</span><span class="n">deltaE</span> <span class="o">&gt;=</span> <span class="n">dE1</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">deltaE</span> <span class="o">&lt;</span> <span class="mi">3</span> <span class="o">*</span> <span class="n">dE2</span><span class="p">)]</span>
            <span class="n">range_3</span> <span class="o">=</span> <span class="n">gen_i_ZLP</span><span class="p">[(</span><span class="bp">self</span><span class="o">.</span><span class="n">deltaE</span> <span class="o">&gt;=</span> <span class="mi">3</span> <span class="o">*</span> <span class="n">dE2</span><span class="p">)]</span> <span class="o">*</span> <span class="mi">0</span>
            <span class="n">totalfile</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="n">range_0</span><span class="p">,</span> <span class="n">range_1</span><span class="p">,</span> <span class="n">range_2</span><span class="p">,</span> <span class="n">range_3</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
            <span class="c1">#TODO: now hardcoding no negative values!!!! CHECKKKK</span>
            <span class="n">totalfile</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">minimum</span><span class="p">(</span><span class="n">totalfile</span><span class="p">,</span> <span class="n">signal</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">totalfile</span>
        
        <span class="n">count</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ZLP_models</span><span class="p">)</span>
        <span class="n">ZLPs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">count</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">l</span><span class="p">))</span> <span class="c1">#np.zeros((count, len_data))</span>
        
        
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s2">"scale_var_deltaE"</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">scale_var_deltaE</span> <span class="o">=</span> <span class="n">find_scale_var</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">deltaE</span><span class="p">)</span>
        
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s2">"scale_var_log_sum_I"</span><span class="p">):</span>
            <span class="n">all_spectra</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span>
            <span class="n">all_spectra</span><span class="p">[</span><span class="n">all_spectra</span><span class="o">&lt;</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
            <span class="n">int_log_I</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">all_spectra</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">2</span><span class="p">))</span><span class="o">.</span><span class="n">flatten</span><span class="p">()</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">scale_var_log_sum_I</span> <span class="o">=</span> <span class="n">find_scale_var</span><span class="p">(</span><span class="n">int_log_I</span><span class="p">)</span>
            <span class="k">del</span> <span class="n">all_spectra</span>
        
        <span class="n">log_sum_I_pixel</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">signal</span><span class="p">))</span>
        <span class="n">predict_x_np</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">l</span><span class="p">,</span><span class="mi">2</span><span class="p">))</span>
        <span class="n">predict_x_np</span><span class="p">[:,</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">scale</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">deltaE</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">scale_var_deltaE</span><span class="p">)</span>
        <span class="n">predict_x_np</span><span class="p">[:,</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">scale</span><span class="p">(</span><span class="n">log_sum_I_pixel</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">scale_var_log_sum_I</span><span class="p">)</span>

        <span class="n">predict_x</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">from_numpy</span><span class="p">(</span><span class="n">predict_x_np</span><span class="p">)</span>
        
        <span class="n">dE1</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dE1</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="nb">int</span><span class="p">(</span><span class="n">cluster</span><span class="p">)]</span>
        <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">count</span><span class="p">):</span> 
            <span class="n">model</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ZLP_models</span><span class="p">[</span><span class="n">k</span><span class="p">]</span>
            <span class="k">with</span> <span class="n">torch</span><span class="o">.</span><span class="n">no_grad</span><span class="p">():</span>
                <span class="n">predictions</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="n">model</span><span class="p">(</span><span class="n">predict_x</span><span class="o">.</span><span class="n">float</span><span class="p">())</span><span class="o">.</span><span class="n">flatten</span><span class="p">())</span>
            <span class="n">ZLPs</span><span class="p">[</span><span class="n">k</span><span class="p">,:]</span> <span class="o">=</span> <span class="n">matching</span><span class="p">(</span><span class="n">signal</span><span class="p">,</span> <span class="n">predictions</span><span class="p">,</span> <span class="n">dE1</span><span class="p">)</span><span class="c1">#matching(energies, np.exp(mean_k), data)</span>
            
        <span class="k">return</span> <span class="n">ZLPs</span></div>
    
<div class="viewcode-block" id="Spectral_image.calc_gen_ZLPs"><a class="viewcode-back" href="../modules/image_class_bs.html#image_class_bs.Spectral_image.calc_gen_ZLPs">[docs]</a>    <span class="k">def</span> <span class="nf">calc_gen_ZLPs</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="c1">### Definition for the matching procedure</span>
        <span class="n">signal</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_pixel_signal</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">)</span>
        
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s1">'ZLP_models'</span><span class="p">):</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">load_ZLP_models</span><span class="p">(</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
            <span class="k">except</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">load_ZLP_models</span><span class="p">()</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s1">'ZLP_models'</span><span class="p">):</span>
            <span class="n">ans</span> <span class="o">=</span> <span class="nb">input</span><span class="p">(</span><span class="s2">"No ZLP models found. Please specify directory or train models. </span><span class="se">\n</span><span class="s2">"</span> <span class="o">+</span> 
                        <span class="s2">"Do you want to define path to models [p], train models [t] or quit [q]?</span><span class="se">\n</span><span class="s2">"</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">ans</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="s2">"q"</span><span class="p">:</span>
                <span class="k">return</span>
            <span class="k">elif</span> <span class="n">ans</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="s2">"p"</span><span class="p">:</span>
                <span class="n">path_to_models</span> <span class="o">=</span> <span class="nb">input</span><span class="p">(</span><span class="s2">"Please input path to models: </span><span class="se">\n</span><span class="s2">"</span><span class="p">)</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">load_ZLP_models</span><span class="p">(</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
                <span class="k">except</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">load_ZLP_models</span><span class="p">()</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s1">'ZLP_models'</span><span class="p">):</span>
                    <span class="nb">print</span><span class="p">(</span><span class="s2">"You had your chance. Please locate your models."</span><span class="p">)</span>
                    <span class="k">return</span>
            <span class="k">elif</span> <span class="n">ans</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="s2">"t"</span><span class="p">:</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">train_ZLPs</span><span class="p">(</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
                <span class="k">except</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">train_ZLPs</span><span class="p">()</span>
                <span class="k">if</span> <span class="s2">"path_to_models"</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="p">:</span>
                    <span class="n">path_to_models</span> <span class="o">=</span> <span class="n">kwargs</span><span class="p">[</span><span class="s2">"path_to_models"</span><span class="p">]</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">load_ZLP_models</span><span class="p">(</span><span class="n">path_to_models</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">load_ZLP_models</span><span class="p">()</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="s2">"unvalid input, not calculating ZLPs"</span><span class="p">)</span>
                <span class="k">return</span>
        
        
        
        <span class="n">count</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ZLP_models</span><span class="p">)</span>
        <span class="n">predictions</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">count</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">l</span><span class="p">))</span> <span class="c1">#np.zeros((count, len_data))</span>
        
        
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s2">"scale_var_deltaE"</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">scale_var_deltaE</span> <span class="o">=</span> <span class="n">find_scale_var</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">deltaE</span><span class="p">)</span>
        
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s2">"scale_var_log_sum_I"</span><span class="p">):</span>
            <span class="n">all_spectra</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span>
            <span class="n">all_spectra</span><span class="p">[</span><span class="n">all_spectra</span><span class="o">&lt;</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
            <span class="n">int_log_I</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">all_spectra</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">2</span><span class="p">))</span><span class="o">.</span><span class="n">flatten</span><span class="p">()</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">scale_var_log_sum_I</span> <span class="o">=</span> <span class="n">find_scale_var</span><span class="p">(</span><span class="n">int_log_I</span><span class="p">)</span>
            <span class="k">del</span> <span class="n">all_spectra</span>
        
        <span class="n">log_sum_I_pixel</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">signal</span><span class="p">))</span>
        <span class="n">predict_x_np</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">l</span><span class="p">,</span><span class="mi">2</span><span class="p">))</span>
        <span class="n">predict_x_np</span><span class="p">[:,</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">scale</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">deltaE</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">scale_var_deltaE</span><span class="p">)</span>
        <span class="n">predict_x_np</span><span class="p">[:,</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">scale</span><span class="p">(</span><span class="n">log_sum_I_pixel</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">scale_var_log_sum_I</span><span class="p">)</span>

        <span class="n">predict_x</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">from_numpy</span><span class="p">(</span><span class="n">predict_x_np</span><span class="p">)</span>
        
        <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">count</span><span class="p">):</span> 
            <span class="n">model</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ZLP_models</span><span class="p">[</span><span class="n">k</span><span class="p">]</span>
            <span class="k">with</span> <span class="n">torch</span><span class="o">.</span><span class="n">no_grad</span><span class="p">():</span>
                <span class="n">predictions</span><span class="p">[</span><span class="n">k</span><span class="p">,:]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="n">model</span><span class="p">(</span><span class="n">predict_x</span><span class="o">.</span><span class="n">float</span><span class="p">())</span><span class="o">.</span><span class="n">flatten</span><span class="p">())</span>
            
        <span class="k">return</span> <span class="n">predictions</span></div>
        
    
<div class="viewcode-block" id="Spectral_image.train_ZLPs"><a class="viewcode-back" href="../modules/image_class_bs.html#image_class_bs.Spectral_image.train_ZLPs">[docs]</a>    <span class="k">def</span> <span class="nf">train_ZLPs</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">n_clusters</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">conf_interval</span> <span class="o">=</span> <span class="mf">0.68</span><span class="p">,</span> <span class="n">clusters</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s2">"clustered"</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">n_clusters</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">cluster</span><span class="p">(</span><span class="n">n_clusters</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">cluster</span><span class="p">()</span>
        <span class="k">elif</span> <span class="n">n_clusters</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_clusters</span> <span class="o">!=</span> <span class="n">n_clusters</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">cluster</span><span class="p">(</span><span class="n">n_clusters</span><span class="p">)</span>
        
        <span class="n">training_data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_cluster_spectra</span><span class="p">(</span> <span class="n">conf_interval</span> <span class="o">=</span> <span class="n">conf_interval</span><span class="p">,</span> <span class="n">clusters</span> <span class="o">=</span> <span class="n">clusters</span><span class="p">)</span>
        <span class="c1">#self.models = </span>
        <span class="n">train_nn_scaled</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">training_data</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">dE1</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">dE2</span> <span class="o">=</span> <span class="n">train_nn_scaled</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">training_data</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div>

<div class="viewcode-block" id="Spectral_image.load_ZLP_models"><a class="viewcode-back" href="../modules/image_class_bs.html#image_class_bs.Spectral_image.load_ZLP_models">[docs]</a>    <span class="k">def</span> <span class="nf">load_ZLP_models</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">path_to_models</span> <span class="o">=</span> <span class="s2">"models"</span><span class="p">,</span> <span class="n">threshold_costs</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span> <span class="n">name_in_path</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span> <span class="n">plotting</span> <span class="o">=</span> <span class="kc">False</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s2">"name"</span><span class="p">)</span> <span class="ow">and</span> <span class="n">name_in_path</span><span class="p">:</span>
            <span class="n">path_to_models</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="o">+</span> <span class="s2">"_"</span> <span class="o">+</span> <span class="n">path_to_models</span>
        
        <span class="k">if</span> <span class="ow">not</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">exists</span><span class="p">(</span><span class="n">path_to_models</span><span class="p">):</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">"No path "</span> <span class="o">+</span> <span class="n">path_to_models</span> <span class="o">+</span> <span class="s2">" found. Please ensure spelling and that there are models trained."</span><span class="p">)</span>
            <span class="k">return</span>
        
        <span class="bp">self</span><span class="o">.</span><span class="n">ZLP_models</span> <span class="o">=</span> <span class="p">[]</span>
        
        <span class="n">model</span> <span class="o">=</span> <span class="n">MLP</span><span class="p">(</span><span class="n">num_inputs</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">num_outputs</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>

        <span class="n">files</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">loadtxt</span><span class="p">(</span><span class="n">path_to_models</span> <span class="o">+</span> <span class="s2">"/costs.txt"</span><span class="p">)</span>
        
        <span class="k">if</span> <span class="n">plotting</span><span class="p">:</span>
            <span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">()</span>
            <span class="n">plt</span><span class="o">.</span><span class="n">title</span><span class="p">(</span><span class="s2">"chi^2 distribution of models"</span><span class="p">)</span>
            <span class="n">plt</span><span class="o">.</span><span class="n">hist</span><span class="p">(</span><span class="n">files</span><span class="p">[</span><span class="n">files</span> <span class="o">&lt;</span> <span class="n">threshold_costs</span><span class="o">*</span><span class="mi">3</span><span class="p">],</span> <span class="n">bins</span> <span class="o">=</span> <span class="mi">20</span><span class="p">)</span>
            <span class="n">plt</span><span class="o">.</span><span class="n">xlabel</span><span class="p">(</span><span class="s2">"chi^2"</span><span class="p">)</span>
            <span class="n">plt</span><span class="o">.</span><span class="n">ylabel</span><span class="p">(</span><span class="s2">"number of occurence"</span><span class="p">)</span>
        
        <span class="n">n_working_models</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">files</span><span class="o">&lt;</span><span class="n">threshold_costs</span><span class="p">)</span>
        
        <span class="n">k</span><span class="o">=</span><span class="mi">0</span>
        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">files</span><span class="p">)):</span>
            <span class="k">if</span> <span class="n">files</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">threshold_costs</span><span class="p">:</span>
                <span class="k">with</span> <span class="n">torch</span><span class="o">.</span><span class="n">no_grad</span><span class="p">():</span>
                    <span class="n">model</span><span class="o">.</span><span class="n">load_state_dict</span><span class="p">(</span><span class="n">torch</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="n">path_to_models</span> <span class="o">+</span> <span class="s2">"/nn_rep"</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">j</span><span class="p">)))</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">ZLP_models</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="n">model</span><span class="p">))</span>
                <span class="n">k</span><span class="o">+=</span><span class="mi">1</span></div>
    
<div class="viewcode-block" id="Spectral_image.check_cost_smefit"><a class="viewcode-back" href="../modules/image_class_bs.html#image_class_bs.Spectral_image.check_cost_smefit">[docs]</a>    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">check_cost_smefit</span><span class="p">(</span><span class="n">path_to_models</span><span class="p">,</span> <span class="n">idx</span><span class="p">,</span> <span class="n">threshold</span> <span class="o">=</span> <span class="mi">1</span><span class="p">):</span>
        <span class="n">path_to_models</span> <span class="o">+=</span> <span class="p">(</span><span class="n">path_to_models</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">!=</span> <span class="s1">'/'</span><span class="p">)</span><span class="o">*</span><span class="s1">'/'</span>
        <span class="n">cost</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">loadtxt</span><span class="p">(</span><span class="n">path_to_models</span> <span class="o">+</span> <span class="s2">"costs"</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">idx</span><span class="p">)</span> <span class="o">+</span> <span class="s2">".txt"</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">cost</span><span class="o">&lt;</span><span class="n">threshold</span></div>
    
    
<div class="viewcode-block" id="Spectral_image.load_ZLP_models_smefit"><a class="viewcode-back" href="../modules/image_class_bs.html#image_class_bs.Spectral_image.load_ZLP_models_smefit">[docs]</a>    <span class="k">def</span> <span class="nf">load_ZLP_models_smefit</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">path_to_models</span> <span class="o">=</span> <span class="s2">"models"</span><span class="p">,</span> <span class="n">n_rep</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">threshold_costs</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span> <span class="n">name_in_path</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span> <span class="n">plotting</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span> <span class="n">idx</span> <span class="o">=</span> <span class="kc">None</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">n_rep</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">idx</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">"Please spectify either the number of replicas you wish to load (n_rep)"</span><span class="o">+</span>\
                  <span class="s2">" or the specific replica model you wist to load (idx) in load_ZLP_models_smefit."</span><span class="p">)</span>
            <span class="k">return</span>
        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s2">"name"</span><span class="p">)</span> <span class="ow">and</span> <span class="n">name_in_path</span><span class="p">:</span>
            <span class="n">path_to_models</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="o">+</span> <span class="s2">"_"</span> <span class="o">+</span> <span class="n">path_to_models</span>
        
        <span class="k">if</span> <span class="ow">not</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">exists</span><span class="p">(</span><span class="n">path_to_models</span><span class="p">):</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">"No path "</span> <span class="o">+</span> <span class="n">os</span><span class="o">.</span><span class="n">getcwd</span><span class="p">()</span> <span class="o">+</span> <span class="n">path_to_models</span> <span class="o">+</span> <span class="s2">" found. Please ensure spelling and that there are models trained."</span><span class="p">)</span>
            <span class="k">return</span>
        
        <span class="bp">self</span><span class="o">.</span><span class="n">ZLP_models</span> <span class="o">=</span> <span class="p">[]</span>
        
        <span class="n">path_to_models</span> <span class="o">+=</span> <span class="p">(</span><span class="n">path_to_models</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">!=</span> <span class="s1">'/'</span><span class="p">)</span><span class="o">*</span><span class="s1">'/'</span>
        <span class="n">path_dE1</span> <span class="o">=</span> <span class="s2">"dE1.txt"</span>
        <span class="n">model</span> <span class="o">=</span> <span class="n">MLP</span><span class="p">(</span><span class="n">num_inputs</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">num_outputs</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">dE1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">loadtxt</span><span class="p">(</span><span class="n">path_to_models</span> <span class="o">+</span> <span class="n">path_dE1</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">idx</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">with</span> <span class="n">torch</span><span class="o">.</span><span class="n">no_grad</span><span class="p">():</span>
                <span class="n">model</span><span class="o">.</span><span class="n">load_state_dict</span><span class="p">(</span><span class="n">torch</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="n">path_to_models</span> <span class="o">+</span> <span class="s2">"/nn_rep"</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">idx</span><span class="p">)))</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">ZLP_models</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="n">model</span><span class="p">))</span>
            <span class="k">return</span>
        
        
        <span class="n">path_costs</span> <span class="o">=</span> <span class="s2">"costs"</span>
        <span class="n">files_costs</span> <span class="o">=</span> <span class="p">[</span><span class="n">filename</span> <span class="k">for</span> <span class="n">filename</span> <span class="ow">in</span> <span class="n">os</span><span class="o">.</span><span class="n">listdir</span><span class="p">(</span><span class="n">path_to_models</span><span class="p">)</span> <span class="k">if</span> <span class="n">filename</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="n">path_costs</span><span class="p">)]</span>
        <span class="n">path_model_rep</span> <span class="o">=</span> <span class="s2">"nn_rep"</span>
        <span class="n">files_model_rep</span> <span class="o">=</span> <span class="p">[</span><span class="n">filename</span> <span class="k">for</span> <span class="n">filename</span> <span class="ow">in</span> <span class="n">os</span><span class="o">.</span><span class="n">listdir</span><span class="p">(</span><span class="n">path_to_models</span><span class="p">)</span> <span class="k">if</span> <span class="n">filename</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="n">path_model_rep</span><span class="p">)]</span>

        
        <span class="n">n_rep</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">files_costs</span><span class="p">),</span> <span class="nb">len</span><span class="p">(</span><span class="n">files_model_rep</span><span class="p">))</span>
        <span class="n">costs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">n_rep</span><span class="p">)</span>
        
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_rep</span><span class="p">):</span>
            <span class="n">file</span> <span class="o">=</span> <span class="n">files_costs</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
            <span class="n">costs</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span>  <span class="n">np</span><span class="o">.</span><span class="n">loadtxt</span><span class="p">(</span><span class="n">path_to_models</span> <span class="o">+</span> <span class="n">file</span><span class="p">)</span>
        
        <span class="bp">self</span><span class="o">.</span><span class="n">costs</span> <span class="o">=</span> <span class="n">costs</span><span class="p">[</span><span class="n">costs</span><span class="o">&lt;</span><span class="n">threshold_costs</span><span class="p">]</span>
    
        <span class="k">if</span> <span class="n">plotting</span><span class="p">:</span>
            <span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">()</span>
            <span class="n">plt</span><span class="o">.</span><span class="n">title</span><span class="p">(</span><span class="s2">"chi^2 distribution of models"</span><span class="p">)</span>
            <span class="n">plt</span><span class="o">.</span><span class="n">hist</span><span class="p">(</span><span class="n">costs</span><span class="p">[</span><span class="n">costs</span> <span class="o">&lt;</span> <span class="n">threshold_costs</span><span class="o">*</span><span class="mi">3</span><span class="p">],</span> <span class="n">bins</span> <span class="o">=</span> <span class="mi">20</span><span class="p">)</span>
            <span class="n">plt</span><span class="o">.</span><span class="n">xlabel</span><span class="p">(</span><span class="s2">"chi^2"</span><span class="p">)</span>
            <span class="n">plt</span><span class="o">.</span><span class="n">ylabel</span><span class="p">(</span><span class="s2">"number of occurence"</span><span class="p">)</span>   
        
        <span class="n">k</span><span class="o">=</span><span class="mi">0</span>
        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_rep</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">costs</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">threshold_costs</span><span class="p">:</span>
                <span class="n">file</span> <span class="o">=</span> <span class="n">files_model_rep</span><span class="p">[</span><span class="n">j</span><span class="p">]</span>
                <span class="k">with</span> <span class="n">torch</span><span class="o">.</span><span class="n">no_grad</span><span class="p">():</span>
                    <span class="n">model</span><span class="o">.</span><span class="n">load_state_dict</span><span class="p">(</span><span class="n">torch</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="n">path_to_models</span> <span class="o">+</span> <span class="n">file</span><span class="p">))</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">ZLP_models</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="n">model</span><span class="p">))</span>
                <span class="n">k</span><span class="o">+=</span><span class="mi">1</span></div>

    <span class="c1">#METHODS ON DIELECTRIC FUNCTIONS</span>
    
<div class="viewcode-block" id="Spectral_image.kramers_kronig_hs"><a class="viewcode-back" href="../modules/image_class_bs.html#image_class_bs.Spectral_image.kramers_kronig_hs">[docs]</a>    <span class="k">def</span> <span class="nf">kramers_kronig_hs</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">I_EELS</span><span class="p">,</span>
                            <span class="n">N_ZLP</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                            <span class="n">iterations</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
                            <span class="n">n</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                            <span class="n">t</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                            <span class="n">delta</span><span class="o">=</span><span class="mf">0.5</span><span class="p">,</span> <span class="n">correct_S_s</span> <span class="o">=</span> <span class="kc">False</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">"""Calculate the complex</span>
<span class="sd">        dielectric function from a single scattering distribution (SSD) using</span>
<span class="sd">        the Kramers-Kronig relations.</span>
<span class="sd">    </span>
<span class="sd">        It uses the FFT method as in [1]_.  The SSD is an</span>
<span class="sd">        EELSSpectrum instance containing SSD low-loss EELS with no zero-loss</span>
<span class="sd">        peak. The internal loop is devised to approximately subtract the</span>
<span class="sd">        surface plasmon contribution supposing an unoxidized planar surface and</span>
<span class="sd">        neglecting coupling between the surfaces. This method does not account</span>
<span class="sd">        for retardation effects, instrumental broading and surface plasmon</span>
<span class="sd">        excitation in particles.</span>
<span class="sd">    </span>
<span class="sd">        Note that either refractive index or thickness are required.</span>
<span class="sd">        If both are None or if both are provided an exception is raised.</span>
<span class="sd">    </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        zlp: {None, number, Signal1D}</span>
<span class="sd">            ZLP intensity. It is optional (can be None) if `t` is None and `n`</span>
<span class="sd">            is not None and the thickness estimation is not required. If `t`</span>
<span class="sd">            is not None, the ZLP is required to perform the normalization and</span>
<span class="sd">            if `t` is not None, the ZLP is required to calculate the thickness.</span>
<span class="sd">            If the ZLP is the same for all spectra, the integral of the ZLP</span>
<span class="sd">            can be provided as a number. Otherwise, if the ZLP intensity is not</span>
<span class="sd">            the same for all spectra, it can be provided as i) a Signal1D</span>
<span class="sd">            of the same dimensions as the current signal containing the ZLP</span>
<span class="sd">            spectra for each location ii) a BaseSignal of signal dimension 0</span>
<span class="sd">            and navigation_dimension equal to the current signal containing the</span>
<span class="sd">            integrated ZLP intensity.</span>
<span class="sd">        iterations: int</span>
<span class="sd">            Number of the iterations for the internal loop to remove the</span>
<span class="sd">            surface plasmon contribution. If 1 the surface plasmon contribution</span>
<span class="sd">            is not estimated and subtracted (the default is 1).</span>
<span class="sd">        n: {None, float}</span>
<span class="sd">            The medium refractive index. Used for normalization of the</span>
<span class="sd">            SSD to obtain the energy loss function. If given the thickness</span>
<span class="sd">            is estimated and returned. It is only required when `t` is None.</span>
<span class="sd">        t: {None, number, Signal1D}</span>
<span class="sd">            The sample thickness in nm. Used for normalization of the</span>
<span class="sd">             to obtain the energy loss function. It is only required when</span>
<span class="sd">            `n` is None. If the thickness is the same for all spectra it can be</span>
<span class="sd">            given by a number. Otherwise, it can be provided as a BaseSignal</span>
<span class="sd">            with signal dimension 0 and navigation_dimension equal to the</span>
<span class="sd">            current signal.</span>
<span class="sd">        delta : float</span>
<span class="sd">            A small number (0.1-0.5 eV) added to the energy axis in</span>
<span class="sd">            specific steps of the calculation the surface loss correction to</span>
<span class="sd">            improve stability.</span>
<span class="sd">        full_output : bool</span>
<span class="sd">            If True, return a dictionary that contains the estimated</span>
<span class="sd">            thickness if `t` is None and the estimated surface plasmon</span>
<span class="sd">            excitation and the spectrum corrected from surface plasmon</span>
<span class="sd">            excitations if `iterations` &gt; 1.</span>
<span class="sd">    </span>
<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        eps: DielectricFunction instance</span>
<span class="sd">            The complex dielectric function results,</span>
<span class="sd">    </span>
<span class="sd">                .. math::</span>
<span class="sd">                    \epsilon = \epsilon_1 + i*\epsilon_2,</span>
<span class="sd">    </span>
<span class="sd">            contained in an DielectricFunction instance.</span>
<span class="sd">        output: Dictionary (optional)</span>
<span class="sd">            A dictionary of optional outputs with the following keys:</span>
<span class="sd">    </span>
<span class="sd">            ``thickness``</span>
<span class="sd">                The estimated  thickness in nm calculated by normalization of</span>
<span class="sd">                the SSD (only when `t` is None)</span>
<span class="sd">    </span>
<span class="sd">            ``surface plasmon estimation``</span>
<span class="sd">               The estimated surface plasmon excitation (only if</span>
<span class="sd">               `iterations` &gt; 1.)</span>
<span class="sd">    </span>
<span class="sd">        Raises</span>
<span class="sd">        ------</span>
<span class="sd">        ValuerError</span>
<span class="sd">            If both `n` and `t` are undefined (None).</span>
<span class="sd">        AttribureError</span>
<span class="sd">            If the beam_energy or the collection semi-angle are not defined in</span>
<span class="sd">            metadata.</span>
<span class="sd">    </span>
<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        This method is based in Egerton's Matlab code [1]_ with some</span>
<span class="sd">        minor differences:</span>
<span class="sd">    </span>
<span class="sd">        * The wrap-around problem when computing the ffts is workarounded by</span>
<span class="sd">          padding the signal instead of substracting the reflected tail.</span>
<span class="sd">    </span>
<span class="sd">        .. [1] Ray Egerton, "Electron Energy-Loss Spectroscopy in the Electron</span>
<span class="sd">           Microscope", Springer-Verlag, 2011.</span>
<span class="sd">    </span>
<span class="sd">        """</span>
        <span class="n">output</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="c1"># Constants and units</span>
        <span class="n">me</span> <span class="o">=</span> <span class="mf">511.06</span>
    
        <span class="n">e0</span> <span class="o">=</span> <span class="mi">200</span> <span class="c1">#keV</span>
        <span class="n">beta</span> <span class="o">=</span><span class="mi">30</span> <span class="c1">#mrad</span>
    
        <span class="n">eaxis</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">deltaE</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">deltaE</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">]</span> <span class="c1">#axis.axis.copy()</span>
        <span class="n">S_E</span> <span class="o">=</span> <span class="n">I_EELS</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">deltaE</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">y</span> <span class="o">=</span> <span class="n">I_EELS</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">deltaE</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">l</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">eaxis</span><span class="p">)</span>
        <span class="n">i0</span> <span class="o">=</span> <span class="n">N_ZLP</span>
        
        <span class="c1"># Kinetic definitions</span>
        <span class="n">ke</span> <span class="o">=</span> <span class="n">e0</span> <span class="o">*</span> <span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="n">e0</span> <span class="o">/</span> <span class="mf">2.</span> <span class="o">/</span> <span class="n">me</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="n">e0</span> <span class="o">/</span> <span class="n">me</span><span class="p">)</span> <span class="o">**</span> <span class="mi">2</span>
        <span class="n">tgt</span> <span class="o">=</span> <span class="n">e0</span> <span class="o">*</span> <span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">me</span> <span class="o">+</span> <span class="n">e0</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="n">me</span> <span class="o">+</span> <span class="n">e0</span><span class="p">)</span>
        <span class="n">rk0</span> <span class="o">=</span> <span class="mi">2590</span> <span class="o">*</span> <span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="n">e0</span> <span class="o">/</span> <span class="n">me</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">ke</span> <span class="o">/</span> <span class="n">me</span><span class="p">)</span>
    
        <span class="k">for</span> <span class="n">io</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">iterations</span><span class="p">):</span>
            <span class="c1"># Calculation of the ELF by normalization of the SSD</span>
            <span class="c1"># We start by the "angular corrections"</span>
            <span class="n">Im</span> <span class="o">=</span> <span class="n">y</span> <span class="o">/</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="p">(</span><span class="n">beta</span> <span class="o">*</span> <span class="n">tgt</span> <span class="o">/</span> <span class="n">eaxis</span><span class="p">)</span> <span class="o">**</span> <span class="mi">2</span><span class="p">))</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">ddeltaE</span><span class="c1">#axis.scale</span>
            <span class="k">if</span> <span class="n">n</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">t</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">"The thickness and the refractive index are "</span>
                                 <span class="s2">"not defined. Please provide one of them."</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">n</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">t</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">"Please provide the refractive index OR the "</span>
                                 <span class="s2">"thickness information, not both"</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">n</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="c1"># normalize using the refractive index.</span>
                <span class="n">K</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">Im</span><span class="o">/</span><span class="n">eaxis</span><span class="p">)</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">ddeltaE</span> 
                <span class="n">K</span> <span class="o">=</span> <span class="p">(</span><span class="n">K</span> <span class="o">/</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">/</span> <span class="mi">2</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="mf">1.</span> <span class="o">/</span> <span class="n">n</span> <span class="o">**</span> <span class="mi">2</span><span class="p">))</span>
                <span class="n">te</span> <span class="o">=</span> <span class="p">(</span><span class="mf">332.5</span> <span class="o">*</span> <span class="n">K</span> <span class="o">*</span> <span class="n">ke</span> <span class="o">/</span> <span class="n">i0</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">t</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">N_ZLP</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">"The ZLP must be provided when the  "</span>
                                     <span class="s2">"thickness is used for normalization."</span><span class="p">)</span>
                <span class="c1"># normalize using the thickness</span>
                <span class="n">K</span> <span class="o">=</span> <span class="n">t</span> <span class="o">*</span> <span class="n">i0</span> <span class="o">/</span> <span class="p">(</span><span class="mf">332.5</span> <span class="o">*</span> <span class="n">ke</span><span class="p">)</span>
                <span class="n">te</span> <span class="o">=</span> <span class="n">t</span>
            <span class="n">Im</span> <span class="o">=</span> <span class="n">Im</span> <span class="o">/</span> <span class="n">K</span>
    
            <span class="c1"># Kramers Kronig Transform:</span>
            <span class="c1"># We calculate KKT(Im(-1/epsilon))=1+Re(1/epsilon) with FFT</span>
            <span class="c1"># Follows: D W Johnson 1975 J. Phys. A: Math. Gen. 8 490</span>
            <span class="c1"># Use an optimal FFT size to speed up the calculation, and</span>
            <span class="c1"># make it double the closest upper value to workaround the</span>
            <span class="c1"># wrap-around problem.</span>
            <span class="n">esize</span> <span class="o">=</span> <span class="n">next_fast_len</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">l</span><span class="p">)</span> <span class="c1">#2**math.floor(math.log2(l)+1)*4</span>
            <span class="n">q</span> <span class="o">=</span> <span class="o">-</span><span class="mi">2</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">fft</span><span class="o">.</span><span class="n">fft</span><span class="p">(</span><span class="n">Im</span><span class="p">,</span> <span class="n">esize</span><span class="p">)</span><span class="o">.</span><span class="n">imag</span> <span class="o">/</span> <span class="n">esize</span>
    
            <span class="n">q</span><span class="p">[:</span><span class="n">l</span><span class="p">]</span> <span class="o">*=</span> <span class="o">-</span><span class="mi">1</span>
            <span class="n">q</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">fft</span><span class="o">.</span><span class="n">fft</span><span class="p">(</span><span class="n">q</span><span class="p">)</span>
            <span class="c1"># Final touch, we have Re(1/eps)</span>
            <span class="n">Re</span> <span class="o">=</span> <span class="n">q</span><span class="p">[:</span><span class="n">l</span><span class="p">]</span><span class="o">.</span><span class="n">real</span> <span class="o">+</span> <span class="mi">1</span>
            <span class="c1"># Egerton does this to correct the wrap-around problem, but in our</span>
            <span class="c1"># case this is not necessary because we compute the fft on an</span>
            <span class="c1"># extended and padded spectrum to avoid this problem.</span>
            <span class="c1"># Re=real(q)</span>
            <span class="c1"># Tail correction</span>
            <span class="c1"># vm=Re[axis.size-1]</span>
            <span class="c1"># Re[:(axis.size-1)]=Re[:(axis.size-1)]+1-(0.5*vm*((axis.size-1) /</span>
            <span class="c1">#  (axis.size*2-arange(0,axis.size-1)))**2)</span>
            <span class="c1"># Re[axis.size:]=1+(0.5*vm*((axis.size-1) /</span>
            <span class="c1">#  (axis.size+arange(0,axis.size)))**2)</span>
    
            <span class="c1"># Epsilon appears:</span>
            <span class="c1">#  We calculate the real and imaginary parts of the CDF</span>
            <span class="n">e1</span> <span class="o">=</span> <span class="n">Re</span> <span class="o">/</span> <span class="p">(</span><span class="n">Re</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">+</span> <span class="n">Im</span> <span class="o">**</span> <span class="mi">2</span><span class="p">)</span>
            <span class="n">e2</span> <span class="o">=</span> <span class="n">Im</span> <span class="o">/</span> <span class="p">(</span><span class="n">Re</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">+</span> <span class="n">Im</span> <span class="o">**</span> <span class="mi">2</span><span class="p">)</span>
    
            <span class="k">if</span> <span class="n">iterations</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">N_ZLP</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="c1"># Surface losses correction:</span>
                <span class="c1">#  Calculates the surface ELF from a vaccumm border effect</span>
                <span class="c1">#  A simulated surface plasmon is subtracted from the ELF</span>
                <span class="n">Srfelf</span> <span class="o">=</span> <span class="mi">4</span> <span class="o">*</span> <span class="n">e2</span> <span class="o">/</span> <span class="p">((</span><span class="n">e1</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">+</span> <span class="n">e2</span> <span class="o">**</span> <span class="mi">2</span><span class="p">)</span> <span class="o">-</span> <span class="n">Im</span>
                <span class="n">adep</span> <span class="o">=</span> <span class="p">(</span><span class="n">tgt</span> <span class="o">/</span> <span class="p">(</span><span class="n">eaxis</span> <span class="o">+</span> <span class="n">delta</span><span class="p">)</span> <span class="o">*</span>
                        <span class="n">np</span><span class="o">.</span><span class="n">arctan</span><span class="p">(</span><span class="n">beta</span> <span class="o">*</span> <span class="n">tgt</span> <span class="o">/</span> <span class="n">eaxis</span><span class="p">)</span> <span class="o">-</span>
                        <span class="n">beta</span> <span class="o">/</span> <span class="mf">1000.</span> <span class="o">/</span>
                        <span class="p">(</span><span class="n">beta</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">+</span> <span class="n">eaxis</span> <span class="o">**</span> <span class="mf">2.</span> <span class="o">/</span> <span class="n">tgt</span> <span class="o">**</span> <span class="mi">2</span><span class="p">))</span>
                <span class="n">Srfint</span> <span class="o">=</span> <span class="mi">2000</span> <span class="o">*</span> <span class="n">K</span> <span class="o">*</span> <span class="n">adep</span> <span class="o">*</span> <span class="n">Srfelf</span> <span class="o">/</span> <span class="n">rk0</span> <span class="o">/</span> <span class="n">te</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">ddeltaE</span> <span class="c1">#axis.scale</span>
                <span class="k">if</span> <span class="n">correct_S_s</span> <span class="o">==</span> <span class="kc">True</span><span class="p">:</span>
                    <span class="nb">print</span><span class="p">(</span><span class="s2">"correcting S_s"</span><span class="p">)</span>
                    <span class="n">Srfint</span><span class="p">[</span><span class="n">Srfint</span><span class="o">&lt;</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
                    <span class="n">Srfint</span><span class="p">[</span><span class="n">Srfint</span><span class="o">&gt;</span><span class="n">S_E</span><span class="p">]</span> <span class="o">=</span> <span class="n">S_E</span><span class="p">[</span><span class="n">Srfint</span><span class="o">&gt;</span><span class="n">S_E</span><span class="p">]</span>
                <span class="n">y</span> <span class="o">=</span> <span class="n">S_E</span> <span class="o">-</span> <span class="n">Srfint</span>
                <span class="n">_logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s1">'Iteration number: </span><span class="si">%d</span><span class="s1"> / </span><span class="si">%d</span><span class="s1">'</span><span class="p">,</span> <span class="n">io</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">iterations</span><span class="p">)</span>
                
    
        <span class="n">eps</span> <span class="o">=</span> <span class="p">(</span><span class="n">e1</span> <span class="o">+</span> <span class="n">e2</span> <span class="o">*</span> <span class="mi">1</span><span class="n">j</span><span class="p">)</span>
        <span class="k">del</span> <span class="n">y</span>
        <span class="k">del</span> <span class="n">I_EELS</span>
        <span class="k">if</span> <span class="s1">'thickness'</span> <span class="ow">in</span> <span class="n">output</span><span class="p">:</span>
            <span class="c1"># As above,prevent errors if the signal is a single spectrum</span>
            <span class="n">output</span><span class="p">[</span><span class="s1">'thickness'</span><span class="p">]</span> <span class="o">=</span> <span class="n">te</span>
        
        <span class="k">return</span> <span class="n">eps</span><span class="p">,</span> <span class="n">te</span><span class="p">,</span> <span class="n">Srfint</span></div>


<div class="viewcode-block" id="Spectral_image.KK_pixel"><a class="viewcode-back" href="../modules/image_class_bs.html#image_class_bs.Spectral_image.KK_pixel">[docs]</a>    <span class="k">def</span> <span class="nf">KK_pixel</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">):</span>
        <span class="n">data_ij</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_pixel_signal</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">)</span><span class="c1">#[self.deltaE&gt;0]</span>
        <span class="n">ZLPs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">calc_ZLPs</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">)</span><span class="c1">#[:,self.deltaE&gt;0]</span>
        <span class="n">dielectric_functions</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="o">+</span><span class="mi">1</span><span class="n">j</span><span class="p">)</span><span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">ZLPs</span><span class="p">[:,</span><span class="bp">self</span><span class="o">.</span><span class="n">deltaE</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
        <span class="n">S_ss</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">ZLPs</span><span class="p">[:,</span><span class="bp">self</span><span class="o">.</span><span class="n">deltaE</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
        <span class="n">ts</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">ZLPs</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>            
        <span class="n">IEELSs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">ZLPs</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">ZLPs</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
            <span class="n">ZLP_k</span> <span class="o">=</span> <span class="n">ZLPs</span><span class="p">[</span><span class="n">k</span><span class="p">,:]</span>
            <span class="n">N_ZLP</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">ZLP_k</span><span class="p">)</span>
            <span class="n">IEELS</span> <span class="o">=</span> <span class="n">data_ij</span><span class="o">-</span><span class="n">ZLP_k</span>
            <span class="n">IEELS</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">deconvolute</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="n">ZLP_k</span><span class="p">)</span>
            <span class="n">IEELSs</span><span class="p">[</span><span class="n">k</span><span class="p">,:]</span> <span class="o">=</span> <span class="n">IEELS</span>
            <span class="n">dielectric_functions</span><span class="p">[</span><span class="n">k</span><span class="p">,:],</span> <span class="n">ts</span><span class="p">[</span><span class="n">k</span><span class="p">],</span> <span class="n">S_ss</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">kramers_kronig_hs</span><span class="p">(</span><span class="n">IEELS</span><span class="p">,</span> <span class="n">N_ZLP</span> <span class="o">=</span> <span class="n">N_ZLP</span><span class="p">,</span> <span class="n">n</span> <span class="o">=</span><span class="mi">3</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">dielectric_functions</span><span class="p">,</span> <span class="n">ts</span><span class="p">,</span> <span class="n">S_ss</span><span class="p">,</span> <span class="n">IEELSs</span></div>


<div class="viewcode-block" id="Spectral_image.im_dielectric_function_bs"><a class="viewcode-back" href="../modules/image_class_bs.html#image_class_bs.Spectral_image.im_dielectric_function_bs">[docs]</a>    <span class="k">def</span> <span class="nf">im_dielectric_function_bs</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">track_process</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span> <span class="n">plot</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span> <span class="n">save_index</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">save_path</span> <span class="o">=</span> <span class="s2">"KK_analysis"</span><span class="p">,</span> <span class="n">smooth</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">"""</span>
<span class="sd">        INPUT:</span>
<span class="sd">            self -- the image of which the dielectic functions are calculated</span>
<span class="sd">            track_process -- boolean, default = False, if True: prints for each pixel that program is busy with that pixel.</span>
<span class="sd">            plot -- boolean, default = False, if True, plots all calculated dielectric functions</span>
<span class="sd">        OUTPUT ATRIBUTES:</span>
<span class="sd">            self.dielectric_function_im_avg = average dielectric function for each pixel</span>
<span class="sd">            self.dielectric_function_im_std = standard deviation of the dielectric function at each energy for each pixel</span>
<span class="sd">            self.S_s_avg = average surface scattering distribution for each pixel</span>
<span class="sd">            self.S_s_std = standard deviation of the surface scattering distribution at each energy for each pixel</span>
<span class="sd">            self.thickness_avg = average thickness for each pixel</span>
<span class="sd">            self.thickness_std = standard deviation thickness for each pixel</span>
<span class="sd">            self.IEELS_avg = average bulk scattering distribution for each pixel</span>
<span class="sd">            self.IEELS_std = standard deviation of the bulk scattering distribution at each energy for each pixel</span>
<span class="sd">        """</span>
        <span class="c1">#TODO</span>
        <span class="c1">#data = self.data[self.deltaE&gt;0, :,:]</span>
        <span class="c1">#energies = self.deltaE[self.deltaE&gt;0]</span>
        <span class="c1">#TODO: make check for models</span>
        <span class="c1"># if not hasattr(self, 'ZLPs_gen'):</span>
        <span class="c1">#     self.calc_ZLPs_gen2("iets")</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">dielectric_function_im_avg</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="o">+</span><span class="mi">1</span><span class="n">j</span><span class="p">)</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">[</span> <span class="p">:,:,</span><span class="bp">self</span><span class="o">.</span><span class="n">deltaE</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">dielectric_function_im_std</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="o">+</span><span class="mi">1</span><span class="n">j</span><span class="p">)</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">[</span> <span class="p">:,:,</span><span class="bp">self</span><span class="o">.</span><span class="n">deltaE</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">S_s_avg</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="o">+</span><span class="mi">1</span><span class="n">j</span><span class="p">)</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">[</span> <span class="p">:,:,</span><span class="bp">self</span><span class="o">.</span><span class="n">deltaE</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">S_s_std</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="o">+</span><span class="mi">1</span><span class="n">j</span><span class="p">)</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">[</span> <span class="p">:,:,</span><span class="bp">self</span><span class="o">.</span><span class="n">deltaE</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">thickness_avg</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">image_shape</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">thickness_std</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">image_shape</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">IEELS_avg</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">IEELS_std</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
        <span class="n">N_ZLPs_calculated</span> <span class="o">=</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s1">'N_ZLPs'</span><span class="p">)</span>
        <span class="c1">#TODO: add N_ZLP saving</span>
        <span class="c1">#if not N_ZLPs_calculated:</span>
        <span class="c1">#    self.N_ZLPs = np.zeros(self.image_shape)</span>
        <span class="k">if</span> <span class="n">plot</span><span class="p">:</span>
            <span class="n">fig1</span><span class="p">,</span> <span class="n">ax1</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">()</span>
            <span class="n">fig2</span><span class="p">,</span> <span class="n">ax2</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">image_shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">image_shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]):</span>
                <span class="k">if</span> <span class="n">track_process</span><span class="p">:</span> <span class="nb">print</span><span class="p">(</span><span class="s2">"calculating dielectric function for pixel "</span> <span class="p">,</span> <span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">)</span>
                <span class="sd">"""</span>
<span class="sd">                data_ij = self.get_pixel_signal(i,j)#[self.deltaE&gt;0]</span>
<span class="sd">                ZLPs = self.calc_ZLPs(i,j)#[:,self.deltaE&gt;0]</span>
<span class="sd">                dielectric_functions = (1+1j)* np.zeros(ZLPs[:,self.deltaE&gt;0].shape)</span>
<span class="sd">                S_ss = np.zeros(ZLPs[:,self.deltaE&gt;0].shape)</span>
<span class="sd">                ts = np.zeros(ZLPs.shape[0])            </span>
<span class="sd">                IEELSs = np.zeros(ZLPs.shape)</span>
<span class="sd">                for k in range(ZLPs.shape[0]):</span>
<span class="sd">                    ZLP_k = ZLPs[k,:]</span>
<span class="sd">                    N_ZLP = np.sum(ZLP_k)</span>
<span class="sd">                    IEELS = data_ij-ZLP_k</span>
<span class="sd">                    if smooth:</span>
<span class="sd">                        IEELS = smooth_1D(IEELS)</span>
<span class="sd">                    IEELS = self.deconvolute(i, j, ZLP_k)</span>
<span class="sd">                    IEELSs[k,:] = IEELS</span>
<span class="sd">                    if plot: </span>
<span class="sd">                        #ax1.plot(self.deltaE, IEELS)</span>
<span class="sd">                        plt.figure()</span>
<span class="sd">                        plt.plot(self.deltaE, IEELS)</span>
<span class="sd">                    #TODO: FIX ZLP: now becomes very negative!!!!!!!</span>
<span class="sd">                    #TODO: VERY IMPORTANT</span>
<span class="sd">                    dielectric_functions[k,:], ts[k], S_ss[k] = self.kramers_kronig_hs(IEELS, N_ZLP = N_ZLP, n =3)</span>
<span class="sd">                    if plot: </span>
<span class="sd">                        #plt.figure()</span>
<span class="sd">                        plt.plot(self.deltaE[self.deltaE&gt;0], dielectric_functions[k,:]*2)</span>
<span class="sd">                        plt.xlim(0,10)</span>
<span class="sd">                        plt.ylim(-100, 400)</span>
<span class="sd">                    """</span>
                <span class="n">dielectric_functions</span><span class="p">,</span> <span class="n">ts</span><span class="p">,</span> <span class="n">S_ss</span><span class="p">,</span> <span class="n">IEELSs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">KK_pixel</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">)</span>
                <span class="c1">#print(ts)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">dielectric_function_im_avg</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">,:]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">average</span><span class="p">(</span><span class="n">dielectric_functions</span><span class="p">,</span> <span class="n">axis</span> <span class="o">=</span> <span class="mi">0</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">dielectric_function_im_std</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">,:]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">std</span><span class="p">(</span><span class="n">dielectric_functions</span><span class="p">,</span> <span class="n">axis</span> <span class="o">=</span> <span class="mi">0</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">S_s_avg</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">,:]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">average</span><span class="p">(</span><span class="n">S_ss</span><span class="p">,</span> <span class="n">axis</span> <span class="o">=</span> <span class="mi">0</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">S_s_std</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">,:]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">std</span><span class="p">(</span><span class="n">S_ss</span><span class="p">,</span> <span class="n">axis</span> <span class="o">=</span> <span class="mi">0</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">thickness_avg</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">average</span><span class="p">(</span><span class="n">ts</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">thickness_std</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">std</span><span class="p">(</span><span class="n">ts</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">IEELS_avg</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">,:]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">average</span><span class="p">(</span><span class="n">IEELSs</span><span class="p">,</span> <span class="n">axis</span> <span class="o">=</span> <span class="mi">0</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">IEELS_std</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">,:]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">std</span><span class="p">(</span><span class="n">IEELSs</span><span class="p">,</span> <span class="n">axis</span> <span class="o">=</span> <span class="mi">0</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">save_index</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">save_path</span> <span class="o">+=</span> <span class="p">(</span><span class="ow">not</span> <span class="n">save_path</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="s1">'/'</span><span class="p">)</span><span class="o">*</span><span class="s1">'/'</span>
            <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">save_path</span> <span class="o">+</span> <span class="s2">"diel_fun_"</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">save_index</span><span class="p">)</span> <span class="o">+</span> <span class="s2">".npy"</span><span class="p">,</span> <span class="s1">'wb'</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
                <span class="n">np</span><span class="o">.</span><span class="n">save</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">dielectric_function_im_avg</span><span class="p">)</span>
            <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">save_path</span> <span class="o">+</span> <span class="s2">"S_s_"</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">save_index</span><span class="p">)</span> <span class="o">+</span> <span class="s2">".npy"</span><span class="p">,</span> <span class="s1">'wb'</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
                <span class="n">np</span><span class="o">.</span><span class="n">save</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">S_s_avg</span><span class="p">)</span>
            <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">save_path</span> <span class="o">+</span> <span class="s2">"thickness_"</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">save_index</span><span class="p">)</span> <span class="o">+</span> <span class="s2">".npy"</span><span class="p">,</span> <span class="s1">'wb'</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
                <span class="n">np</span><span class="o">.</span><span class="n">save</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">thickness_avg</span><span class="p">)</span></div>
        <span class="c1">#return dielectric_function_im_avg, dielectric_function_im_std</span>

    
<div class="viewcode-block" id="Spectral_image.im_dielectric_function"><a class="viewcode-back" href="../modules/image_class_bs.html#image_class_bs.Spectral_image.im_dielectric_function">[docs]</a>    <span class="k">def</span> <span class="nf">im_dielectric_function</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">track_process</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span> <span class="n">plot</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span> <span class="n">save_index</span> <span class="o">=</span> <span class="kc">None</span><span class="p">):</span>
        <span class="sd">"""</span>
<span class="sd">        INPUT:</span>
<span class="sd">            self -- the image of which the dielectic functions are calculated</span>
<span class="sd">            track_process -- boolean, default = False, if True: prints for each pixel that program is busy with that pixel.</span>
<span class="sd">            plot -- boolean, default = False, if True, plots all calculated dielectric functions</span>
<span class="sd">        OUTPUT ATRIBUTES:</span>
<span class="sd">            self.dielectric_function_im_avg = average dielectric function for each pixel</span>
<span class="sd">            self.dielectric_function_im_std = standard deviation of the dielectric function at each energy for each pixel</span>
<span class="sd">            self.S_s_avg = average surface scattering distribution for each pixel</span>
<span class="sd">            self.S_s_std = standard deviation of the surface scattering distribution at each energy for each pixel</span>
<span class="sd">            self.thickness_avg = average thickness for each pixel</span>
<span class="sd">            self.thickness_std = standard deviation thickness for each pixel</span>
<span class="sd">            self.IEELS_avg = average bulk scattering distribution for each pixel</span>
<span class="sd">            self.IEELS_std = standard deviation of the bulk scattering distribution at each energy for each pixel</span>
<span class="sd">        """</span>
        <span class="c1">#TODO</span>
        <span class="c1">#data = self.data[self.deltaE&gt;0, :,:]</span>
        <span class="c1">#energies = self.deltaE[self.deltaE&gt;0]</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s1">'ZLPs_gen'</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">calc_ZLPs_gen2</span><span class="p">(</span><span class="s2">"iets"</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">dielectric_function_im_avg</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="o">+</span><span class="mi">1</span><span class="n">j</span><span class="p">)</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">[</span> <span class="p">:,:,</span><span class="bp">self</span><span class="o">.</span><span class="n">deltaE</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">dielectric_function_im_std</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="o">+</span><span class="mi">1</span><span class="n">j</span><span class="p">)</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">[</span> <span class="p">:,:,</span><span class="bp">self</span><span class="o">.</span><span class="n">deltaE</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">S_s_avg</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="o">+</span><span class="mi">1</span><span class="n">j</span><span class="p">)</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">[</span> <span class="p">:,:,</span><span class="bp">self</span><span class="o">.</span><span class="n">deltaE</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">S_s_std</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="o">+</span><span class="mi">1</span><span class="n">j</span><span class="p">)</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">[</span> <span class="p">:,:,</span><span class="bp">self</span><span class="o">.</span><span class="n">deltaE</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">thickness_avg</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">image_shape</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">thickness_std</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">image_shape</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">IEELS_avg</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">IEELS_std</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
        <span class="n">N_ZLPs_calculated</span> <span class="o">=</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s1">'N_ZLPs'</span><span class="p">)</span>
        <span class="c1">#TODO: add N_ZLP saving</span>
        <span class="c1">#if not N_ZLPs_calculated:</span>
        <span class="c1">#    self.N_ZLPs = np.zeros(self.image_shape)</span>
        <span class="k">if</span> <span class="n">plot</span><span class="p">:</span>
            <span class="n">fig1</span><span class="p">,</span> <span class="n">ax1</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">()</span>
            <span class="n">fig2</span><span class="p">,</span> <span class="n">ax2</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">image_shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">image_shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]):</span>
                <span class="k">if</span> <span class="n">track_process</span><span class="p">:</span> <span class="nb">print</span><span class="p">(</span><span class="s2">"calculating dielectric function for pixel "</span> <span class="p">,</span> <span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">)</span>
                <span class="n">data_ij</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_pixel_signal</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">)</span><span class="c1">#[self.deltaE&gt;0]</span>
                <span class="n">ZLPs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">calc_ZLPs</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">)</span><span class="c1">#[:,self.deltaE&gt;0]</span>
                <span class="n">dielectric_functions</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="o">+</span><span class="mi">1</span><span class="n">j</span><span class="p">)</span><span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">ZLPs</span><span class="p">[:,</span><span class="bp">self</span><span class="o">.</span><span class="n">deltaE</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
                <span class="n">S_ss</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">ZLPs</span><span class="p">[:,</span><span class="bp">self</span><span class="o">.</span><span class="n">deltaE</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
                <span class="n">ts</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">ZLPs</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>            
                <span class="n">IEELSs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">ZLPs</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">23</span><span class="p">,</span><span class="mi">28</span><span class="p">):</span><span class="c1">#ZLPs.shape[0]):</span>
                    <span class="n">ZLP_k</span> <span class="o">=</span> <span class="n">ZLPs</span><span class="p">[</span><span class="n">k</span><span class="p">,:]</span>
                    <span class="n">N_ZLP</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">ZLP_k</span><span class="p">)</span>
                    <span class="n">IEELS</span> <span class="o">=</span> <span class="n">data_ij</span><span class="o">-</span><span class="n">ZLP_k</span>
                    <span class="n">IEELS</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">deconvolute</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="n">ZLP_k</span><span class="p">)</span>
                    <span class="n">IEELSs</span><span class="p">[</span><span class="n">k</span><span class="p">,:]</span> <span class="o">=</span> <span class="n">IEELS</span>
                    <span class="k">if</span> <span class="n">plot</span><span class="p">:</span> 
                        <span class="c1">#ax1.plot(self.deltaE, IEELS)</span>
                        <span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">()</span>
                        <span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">deltaE</span><span class="p">,</span> <span class="n">IEELS</span><span class="p">)</span>
                    <span class="c1">#TODO: FIX ZLP: now becomes very negative!!!!!!!</span>
                    <span class="c1">#TODO: VERY IMPORTANT</span>
                    <span class="n">dielectric_functions</span><span class="p">[</span><span class="n">k</span><span class="p">,:],</span> <span class="n">ts</span><span class="p">[</span><span class="n">k</span><span class="p">],</span> <span class="n">S_ss</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">kramers_kronig_hs</span><span class="p">(</span><span class="n">IEELS</span><span class="p">,</span> <span class="n">N_ZLP</span> <span class="o">=</span> <span class="n">N_ZLP</span><span class="p">,</span> <span class="n">n</span> <span class="o">=</span><span class="mi">3</span><span class="p">)</span>
                    <span class="k">if</span> <span class="n">plot</span><span class="p">:</span> 
                        <span class="c1">#plt.figure()</span>
                        <span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">deltaE</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">deltaE</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">],</span> <span class="n">dielectric_functions</span><span class="p">[</span><span class="n">k</span><span class="p">,:]</span><span class="o">*</span><span class="mi">2</span><span class="p">)</span>
                        <span class="n">plt</span><span class="o">.</span><span class="n">xlim</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">10</span><span class="p">)</span>
                        <span class="n">plt</span><span class="o">.</span><span class="n">ylim</span><span class="p">(</span><span class="o">-</span><span class="mi">100</span><span class="p">,</span> <span class="mi">400</span><span class="p">)</span>
                
                <span class="c1">#print(ts)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">dielectric_function_im_avg</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">,:]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">average</span><span class="p">(</span><span class="n">dielectric_functions</span><span class="p">,</span> <span class="n">axis</span> <span class="o">=</span> <span class="mi">0</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">dielectric_function_im_std</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">,:]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">std</span><span class="p">(</span><span class="n">dielectric_functions</span><span class="p">,</span> <span class="n">axis</span> <span class="o">=</span> <span class="mi">0</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">S_s_avg</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">,:]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">average</span><span class="p">(</span><span class="n">S_ss</span><span class="p">,</span> <span class="n">axis</span> <span class="o">=</span> <span class="mi">0</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">S_s_std</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">,:]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">std</span><span class="p">(</span><span class="n">S_ss</span><span class="p">,</span> <span class="n">axis</span> <span class="o">=</span> <span class="mi">0</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">thickness_avg</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">average</span><span class="p">(</span><span class="n">ts</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">thickness_std</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">std</span><span class="p">(</span><span class="n">ts</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">IEELS_avg</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">,:]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">average</span><span class="p">(</span><span class="n">IEELSs</span><span class="p">,</span> <span class="n">axis</span> <span class="o">=</span> <span class="mi">0</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">IEELS_std</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">,:]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">std</span><span class="p">(</span><span class="n">IEELSs</span><span class="p">,</span> <span class="n">axis</span> <span class="o">=</span> <span class="mi">0</span><span class="p">)</span></div>
        <span class="c1">#return dielectric_function_im_avg, dielectric_function_im_std</span>
    
<div class="viewcode-block" id="Spectral_image.crossings_im"><a class="viewcode-back" href="../modules/image_class_bs.html#image_class_bs.Spectral_image.crossings_im">[docs]</a>    <span class="k">def</span> <span class="nf">crossings_im</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span><span class="c1">#,  delta = 50):</span>
        <span class="sd">"""</span>
<span class="sd">        INPUT: </span>
<span class="sd">            self</span>
<span class="sd">        OUTPUT:</span>
<span class="sd">            self.crossings_E = numpy array (image-shape, N_c), where N_c the maximimun number of crossings of any pixel, 0 indicates no crossing</span>
<span class="sd">            self.crossings_n = numpy array (image-shape), number of crossings per pixel</span>
<span class="sd">        Calculates for each pixel the crossings of the real part of the dielectric function \</span>
<span class="sd">            from negative to positive.</span>
<span class="sd">        """</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">crossings_E</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">image_shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">image_shape</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span><span class="mi">1</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">crossings_n</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">image_shape</span><span class="p">)</span>
        <span class="n">n_max</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">image_shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
            <span class="c1">#print("cross", i)</span>
            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">image_shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]):</span> 
                <span class="c1">#print("cross", i, j)</span>
                <span class="n">crossings_E_ij</span><span class="p">,</span> <span class="n">n</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">crossings</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">)</span><span class="c1">#, delta)</span>
                <span class="k">if</span> <span class="n">n</span> <span class="o">&gt;</span> <span class="n">n_max</span><span class="p">:</span>
                    <span class="c1">#print("cross", i, j, n, n_max, crossings_E.shape)</span>
                    <span class="n">crossings_E_new</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">image_shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">image_shape</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span><span class="n">n</span><span class="p">))</span>
                    <span class="c1">#print("cross", i, j, n, n_max, crossings_E.shape, crossings_E_new[:,:,:n_max].shape)</span>
                    <span class="n">crossings_E_new</span><span class="p">[:,:,:</span><span class="n">n_max</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">crossings_E</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">crossings_E</span> <span class="o">=</span> <span class="n">crossings_E_new</span>
                    <span class="n">n_max</span> <span class="o">=</span> <span class="n">n</span>
                    <span class="k">del</span> <span class="n">crossings_E_new</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">crossings_E</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">,:</span><span class="n">n</span><span class="p">]</span> <span class="o">=</span> <span class="n">crossings_E_ij</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">crossings_n</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">n</span></div>
    
<div class="viewcode-block" id="Spectral_image.crossings"><a class="viewcode-back" href="../modules/image_class_bs.html#image_class_bs.Spectral_image.crossings">[docs]</a>    <span class="k">def</span> <span class="nf">crossings</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">):</span><span class="c1">#, delta = 50):</span>
        <span class="c1">#l = len(die_fun)</span>
        <span class="n">die_fun_avg</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">real</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dielectric_function_im_avg</span><span class="p">[</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="p">:])</span>
        <span class="c1">#die_fun_f = np.zeros(l-2*delta)</span>
        <span class="c1">#TODO: use smooth?</span>
        <span class="sd">"""</span>
<span class="sd">        for i in range(self.l-delta):</span>
<span class="sd">            die_fun_avg[i] = np.average(self.dielectric_function_im_avg[i:i+delta])</span>
<span class="sd">        """</span>
        <span class="n">crossing</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">0</span><span class="p">]),(</span><span class="n">die_fun_avg</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">&lt;</span><span class="mi">0</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">die_fun_avg</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span> <span class="o">&gt;=</span><span class="mi">0</span><span class="p">)))</span>
        <span class="n">deltaE_n</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">deltaE</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">deltaE</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">]</span>
        <span class="c1">#deltaE_n = deltaE_n[50:-50]</span>
        <span class="n">crossing_E</span> <span class="o">=</span> <span class="n">deltaE_n</span><span class="p">[</span><span class="n">crossing</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s1">'bool'</span><span class="p">)]</span>
        <span class="n">n</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">crossing_E</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">crossing_E</span><span class="p">,</span> <span class="n">n</span></div>
    
<div class="viewcode-block" id="Spectral_image.crossings_ieels"><a class="viewcode-back" href="../modules/image_class_bs.html#image_class_bs.Spectral_image.crossings_ieels">[docs]</a>    <span class="k">def</span> <span class="nf">crossings_ieels</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ieels</span><span class="p">,</span> <span class="n">smooth</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span> <span class="n">window_len</span> <span class="o">=</span> <span class="mi">50</span><span class="p">):</span><span class="c1">#, delta = 50):</span>
        <span class="c1">#l = len(die_fun)</span>
        <span class="n">die_fun_avg</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">real</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dielectric_function_im_avg</span><span class="p">[</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="p">:])</span>
        <span class="c1">#die_fun_f = np.zeros(l-2*delta)</span>
        <span class="c1">#TODO: use smooth?</span>
        <span class="sd">"""</span>
<span class="sd">        for i in range(self.l-delta):</span>
<span class="sd">            die_fun_avg[i] = np.average(self.dielectric_function_im_avg[i:i+delta])</span>
<span class="sd">        """</span>
        <span class="n">crossing</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">0</span><span class="p">]),(</span><span class="n">die_fun_avg</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">&lt;</span><span class="mi">0</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">die_fun_avg</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span> <span class="o">&gt;=</span><span class="mi">0</span><span class="p">)))</span>
        <span class="n">deltaE_n</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">deltaE</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">deltaE</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">]</span>
        <span class="c1">#deltaE_n = deltaE_n[50:-50]</span>
        <span class="n">crossing_E</span> <span class="o">=</span> <span class="n">deltaE_n</span><span class="p">[</span><span class="n">crossing</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s1">'bool'</span><span class="p">)]</span>
        <span class="n">n</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">crossing_E</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">crossing_E</span><span class="p">,</span> <span class="n">n</span></div>
    
    <span class="c1">#%%</span>
    <span class="c1">#TODO: add bandgap finding</span>
    
<div class="viewcode-block" id="Spectral_image.cluster"><a class="viewcode-back" href="../modules/image_class_bs.html#image_class_bs.Spectral_image.cluster">[docs]</a>    <span class="k">def</span> <span class="nf">cluster</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">n_clusters</span> <span class="o">=</span> <span class="mi">5</span><span class="p">,</span> <span class="n">n_iterations</span> <span class="o">=</span> <span class="mi">30</span><span class="p">,</span> <span class="n">based_upon</span> <span class="o">=</span> <span class="s2">"sum"</span><span class="p">):</span>
        <span class="c1">#TODO: add other based_upons</span>
        <span class="k">if</span> <span class="n">based_upon</span> <span class="o">==</span> <span class="s2">"sum"</span><span class="p">:</span>
            <span class="n">values</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">,</span> <span class="n">axis</span> <span class="o">=</span> <span class="mi">2</span><span class="p">)</span><span class="o">.</span><span class="n">flatten</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">based_upon</span> <span class="o">==</span> <span class="s2">"log"</span><span class="p">:</span>
            <span class="n">values</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">,</span> <span class="n">axis</span> <span class="o">=</span> <span class="mi">2</span><span class="p">)</span><span class="o">.</span><span class="n">flatten</span><span class="p">())</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">values</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">,</span> <span class="n">axis</span> <span class="o">=</span> <span class="mi">2</span><span class="p">)</span><span class="o">.</span><span class="n">flatten</span><span class="p">()</span>
        <span class="n">clusters_unsorted</span><span class="p">,</span> <span class="n">r</span> <span class="o">=</span> <span class="n">k_means</span><span class="p">(</span><span class="n">values</span><span class="p">,</span> <span class="n">n_clusters</span> <span class="o">=</span> <span class="n">n_clusters</span><span class="p">,</span> <span class="n">n_iterations</span> <span class="o">=</span><span class="n">n_iterations</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">clusters</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">clusters_unsorted</span><span class="p">)[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">arg_sort_clusters</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argsort</span><span class="p">(</span><span class="n">clusters_unsorted</span><span class="p">)[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">clustered</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">image_shape</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_clusters</span><span class="p">):</span>
            <span class="n">in_cluster_i</span> <span class="o">=</span> <span class="n">r</span><span class="p">[</span><span class="n">arg_sort_clusters</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">clustered</span> <span class="o">+=</span> <span class="p">((</span><span class="n">np</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">in_cluster_i</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">image_shape</span><span class="p">))</span><span class="o">*</span><span class="n">i</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span></div>
    
    
    <span class="c1">#PLOTTING FUNCTIONS</span>
<div class="viewcode-block" id="Spectral_image.plot_sum"><a class="viewcode-back" href="../modules/image_class_bs.html#image_class_bs.Spectral_image.plot_sum">[docs]</a>    <span class="k">def</span> <span class="nf">plot_sum</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">title</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">xlab</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">ylab</span> <span class="o">=</span> <span class="kc">None</span><span class="p">):</span>
        <span class="sd">"""</span>
<span class="sd">        INPUT:</span>
<span class="sd">            self -- spectral image </span>
<span class="sd">            title -- str, delfault = None, title of plot</span>
<span class="sd">            xlab -- str, default = None, x-label</span>
<span class="sd">            ylab -- str, default = None, y-label</span>
<span class="sd">        OUTPUT:</span>
<span class="sd">        Plots the summation over the intensity for each pixel in a heatmap.</span>
<span class="sd">        """</span>
        <span class="c1">#TODO: invert colours</span>
        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s1">'name'</span><span class="p">):</span>
            <span class="n">name</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">name</span> <span class="o">=</span> <span class="s1">''</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">title</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">plt</span><span class="o">.</span><span class="n">title</span><span class="p">(</span><span class="s2">"intgrated intensity spectrum "</span> <span class="o">+</span> <span class="n">name</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">plt</span><span class="o">.</span><span class="n">title</span><span class="p">(</span><span class="n">title</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s1">'pixelsize'</span><span class="p">):</span>
        <span class="c1">#    plt.xlabel(self.pixelsize)</span>
        <span class="c1">#    plt.ylabel(self.pixelsize)</span>
            <span class="n">plt</span><span class="o">.</span><span class="n">xlabel</span><span class="p">(</span><span class="s2">"[m]"</span><span class="p">)</span>
            <span class="n">plt</span><span class="o">.</span><span class="n">ylabel</span><span class="p">(</span><span class="s2">"[m]"</span><span class="p">)</span>
            <span class="n">xticks</span><span class="p">,</span> <span class="n">yticks</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_ticks</span><span class="p">()</span>
            <span class="n">ax</span> <span class="o">=</span> <span class="n">sns</span><span class="o">.</span><span class="n">heatmap</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">,</span> <span class="n">axis</span> <span class="o">=</span> <span class="mi">2</span><span class="p">),</span> <span class="n">xticklabels</span><span class="o">=</span><span class="n">xticks</span><span class="p">,</span> <span class="n">yticklabels</span><span class="o">=</span><span class="n">yticks</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">ax</span> <span class="o">=</span> <span class="n">sns</span><span class="o">.</span><span class="n">heatmap</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">,</span> <span class="n">axis</span> <span class="o">=</span> <span class="mi">2</span><span class="p">))</span>
        <span class="k">if</span> <span class="n">xlab</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">plt</span><span class="o">.</span><span class="n">xlabel</span><span class="p">(</span><span class="n">xlab</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">ylab</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">plt</span><span class="o">.</span><span class="n">ylabel</span><span class="p">(</span><span class="n">ylab</span><span class="p">)</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span></div>
        
<div class="viewcode-block" id="Spectral_image.plot_heatmap"><a class="viewcode-back" href="../modules/image_class_bs.html#image_class_bs.Spectral_image.plot_heatmap">[docs]</a>    <span class="k">def</span> <span class="nf">plot_heatmap</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">title</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">xlab</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">ylab</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">"""</span>
<span class="sd">        INPUT:</span>
<span class="sd">            self -- spectral image </span>
<span class="sd">            title -- str, delfault = None, title of plot</span>
<span class="sd">            xlab -- str, default = None, x-label</span>
<span class="sd">            ylab -- str, default = None, y-label</span>
<span class="sd">        OUTPUT:</span>
<span class="sd">        Plots the summation over the intensity for each pixel in a heatmap.</span>
<span class="sd">        """</span>
        <span class="c1">#TODO: invert colours</span>
        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s1">'name'</span><span class="p">):</span>
            <span class="n">name</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">name</span> <span class="o">=</span> <span class="s1">''</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">title</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">plt</span><span class="o">.</span><span class="n">title</span><span class="p">(</span><span class="s2">"intgrated intensity spectrum "</span> <span class="o">+</span> <span class="n">name</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">plt</span><span class="o">.</span><span class="n">title</span><span class="p">(</span><span class="n">title</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s1">'pixelsize'</span><span class="p">):</span>
        <span class="c1">#    plt.xlabel(self.pixelsize)</span>
        <span class="c1">#    plt.ylabel(self.pixelsize)</span>
            <span class="n">plt</span><span class="o">.</span><span class="n">xlabel</span><span class="p">(</span><span class="s2">"[m]"</span><span class="p">)</span>
            <span class="n">plt</span><span class="o">.</span><span class="n">ylabel</span><span class="p">(</span><span class="s2">"[m]"</span><span class="p">)</span>
            <span class="n">xticks</span><span class="p">,</span> <span class="n">yticks</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_ticks</span><span class="p">()</span>
            <span class="n">ax</span> <span class="o">=</span> <span class="n">sns</span><span class="o">.</span><span class="n">heatmap</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">xticklabels</span><span class="o">=</span><span class="n">xticks</span><span class="p">,</span> <span class="n">yticklabels</span><span class="o">=</span><span class="n">yticks</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">ax</span> <span class="o">=</span> <span class="n">sns</span><span class="o">.</span><span class="n">heatmap</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">xlab</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">plt</span><span class="o">.</span><span class="n">xlabel</span><span class="p">(</span><span class="n">xlab</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">plt</span><span class="o">.</span><span class="n">xlabel</span><span class="p">(</span><span class="s1">'[micron]'</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">ylab</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">plt</span><span class="o">.</span><span class="n">ylabel</span><span class="p">(</span><span class="n">ylab</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">plt</span><span class="o">.</span><span class="n">ylabel</span><span class="p">(</span><span class="s1">'[micron]'</span><span class="p">)</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span></div>
    
<div class="viewcode-block" id="Spectral_image.get_ticks"><a class="viewcode-back" href="../modules/image_class_bs.html#image_class_bs.Spectral_image.get_ticks">[docs]</a>    <span class="k">def</span> <span class="nf">get_ticks</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">sig</span> <span class="o">=</span> <span class="mi">3</span><span class="p">,</span> <span class="n">n_tick</span> <span class="o">=</span> <span class="mi">10</span><span class="p">):</span>
        <span class="n">xlabels</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">x_axis</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span><span class="n">dtype</span> <span class="o">=</span> <span class="nb">object</span><span class="p">)</span>
        <span class="n">xlabels</span><span class="p">[:]</span> <span class="o">=</span> <span class="s2">""</span>
        <span class="n">each_n_pixels</span> <span class="o">=</span> <span class="n">math</span><span class="o">.</span><span class="n">floor</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">xlabels</span><span class="p">)</span><span class="o">/</span><span class="n">n_tick</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">xlabels</span><span class="p">)):</span>
            <span class="k">if</span> <span class="n">i</span><span class="o">%</span><span class="n">each_n_pixels</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">xlabels</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="s1">'</span><span class="si">%s</span><span class="s1">'</span> <span class="o">%</span> <span class="nb">float</span><span class="p">(</span><span class="s1">'</span><span class="si">%.2g</span><span class="s1">'</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">x_axis</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
        <span class="n">ylabels</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">y_axis</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span><span class="n">dtype</span> <span class="o">=</span> <span class="nb">object</span><span class="p">)</span>
        <span class="n">ylabels</span><span class="p">[:]</span> <span class="o">=</span> <span class="s2">""</span>
        <span class="n">each_n_pixels</span> <span class="o">=</span> <span class="n">math</span><span class="o">.</span><span class="n">floor</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">ylabels</span><span class="p">)</span><span class="o">/</span><span class="n">n_tick</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">ylabels</span><span class="p">)):</span>
            <span class="k">if</span> <span class="n">i</span><span class="o">%</span><span class="n">each_n_pixels</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">ylabels</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="s1">'</span><span class="si">%s</span><span class="s1">'</span> <span class="o">%</span> <span class="nb">float</span><span class="p">(</span><span class="s1">'</span><span class="si">%.2g</span><span class="s1">'</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">y_axis</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
        <span class="k">return</span> <span class="n">xlabels</span><span class="p">,</span> <span class="n">ylabels</span></div>
                
    
<div class="viewcode-block" id="Spectral_image.plot_all"><a class="viewcode-back" href="../modules/image_class_bs.html#image_class_bs.Spectral_image.plot_all">[docs]</a>    <span class="k">def</span> <span class="nf">plot_all</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">same_image</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span> <span class="n">normalize</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span> <span class="n">legend</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span> 
                 <span class="n">range_x</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">range_y</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">range_E</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">signal</span> <span class="o">=</span> <span class="s2">"EELS"</span><span class="p">,</span> <span class="n">log</span> <span class="o">=</span> <span class="kc">False</span><span class="p">):</span>
        <span class="c1">#TODO: add titles and such</span>
        <span class="k">if</span> <span class="n">range_x</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">range_x</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">image_shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span>
        <span class="k">if</span> <span class="n">range_y</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">range_y</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">image_shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span>
        <span class="k">if</span> <span class="n">same_image</span><span class="p">:</span>
            <span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">()</span>
            <span class="n">plt</span><span class="o">.</span><span class="n">title</span><span class="p">(</span><span class="s2">"Spectrum image "</span> <span class="o">+</span> <span class="n">signal</span> <span class="o">+</span> <span class="s2">" spectra"</span><span class="p">)</span>
            <span class="n">plt</span><span class="o">.</span><span class="n">xlabel</span><span class="p">(</span><span class="s2">"[eV]"</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">range_E</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">plt</span><span class="o">.</span><span class="n">xlim</span><span class="p">(</span><span class="n">range_E</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">range_y</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">range_y</span><span class="p">[</span><span class="mi">1</span><span class="p">]):</span>
            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">range_x</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">range_x</span><span class="p">[</span><span class="mi">1</span><span class="p">]):</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">same_image</span><span class="p">:</span>
                    <span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">()</span>
                    <span class="n">plt</span><span class="o">.</span><span class="n">title</span><span class="p">(</span><span class="s2">"Spectrum pixel: ["</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">j</span><span class="p">)</span> <span class="o">+</span><span class="s2">","</span><span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="o">+</span> <span class="s2">"]"</span><span class="p">)</span>
                    <span class="n">plt</span><span class="o">.</span><span class="n">xlabel</span><span class="p">(</span><span class="s2">"[eV]"</span><span class="p">)</span>
                    <span class="k">if</span> <span class="n">range_E</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                        <span class="n">plt</span><span class="o">.</span><span class="n">xlim</span><span class="p">(</span><span class="n">range_E</span><span class="p">)</span>
                    <span class="k">if</span> <span class="n">legend</span><span class="p">:</span> 
                        <span class="n">plt</span><span class="o">.</span><span class="n">legend</span><span class="p">()</span>
                <span class="n">signal_pixel</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_pixel_signal</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">,</span><span class="n">signal</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">normalize</span><span class="p">:</span>
                    <span class="n">signal_pixel</span> <span class="o">/=</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">absolute</span><span class="p">(</span><span class="n">signal_pixel</span><span class="p">))</span>
                <span class="k">if</span> <span class="n">log</span><span class="p">:</span>
                    <span class="n">signal_pixel</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">signal_pixel</span><span class="p">)</span>
                    <span class="n">plt</span><span class="o">.</span><span class="n">ylabel</span><span class="p">(</span><span class="s2">"log intensity"</span><span class="p">)</span>
                <span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">deltaE</span><span class="p">,</span> <span class="n">signal_pixel</span><span class="p">,</span> <span class="n">label</span> <span class="o">=</span> <span class="s2">"["</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">j</span><span class="p">)</span> <span class="o">+</span><span class="s2">","</span><span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="o">+</span> <span class="s2">"]"</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">legend</span><span class="p">:</span> 
                <span class="n">plt</span><span class="o">.</span><span class="n">legend</span><span class="p">()</span></div>
                
    
    <span class="c1">#GENERAL FUNCTIONS</span>
<div class="viewcode-block" id="Spectral_image.get_key"><a class="viewcode-back" href="../modules/image_class_bs.html#image_class_bs.Spectral_image.get_key">[docs]</a>    <span class="k">def</span> <span class="nf">get_key</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">key</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="ow">in</span> <span class="p">(</span><span class="n">string</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="k">for</span> <span class="n">string</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">EELS_NAMES</span><span class="p">):</span>
            <span class="k">return</span> <span class="s1">'data'</span>
        <span class="k">elif</span> <span class="n">key</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="ow">in</span> <span class="p">(</span><span class="n">string</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="k">for</span> <span class="n">string</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">IEELS_NAMES</span><span class="p">):</span>
            <span class="k">return</span> <span class="s1">'ieels'</span>
        <span class="k">elif</span> <span class="n">key</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="ow">in</span> <span class="p">(</span><span class="n">string</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="k">for</span> <span class="n">string</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">ZLP_NAMES</span><span class="p">):</span>
            <span class="k">return</span> <span class="s1">'zlp'</span>
        <span class="k">elif</span> <span class="n">key</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="ow">in</span> <span class="p">(</span><span class="n">string</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="k">for</span> <span class="n">string</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">DIELECTRIC_FUNCTION_NAMES</span><span class="p">):</span>
            <span class="k">return</span> <span class="s1">'eps'</span>
        <span class="k">elif</span> <span class="n">key</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="ow">in</span> <span class="p">(</span><span class="n">string</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="k">for</span> <span class="n">string</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">THICKNESS_NAMES</span><span class="p">):</span>
            <span class="k">return</span> <span class="s1">'thickness'</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">key</span></div>
        
    
    
    <span class="c1">#STATIC METHODS</span>
<div class="viewcode-block" id="Spectral_image.get_prefix"><a class="viewcode-back" href="../modules/image_class_bs.html#image_class_bs.Spectral_image.get_prefix">[docs]</a>    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">get_prefix</span><span class="p">(</span><span class="n">unit</span><span class="p">,</span> <span class="n">SIunit</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">numeric</span> <span class="o">=</span> <span class="kc">True</span><span class="p">):</span>
        <span class="sd">"""</span>
<span class="sd">        INPUT:</span>
<span class="sd">            unit -- str, unit of which the prefix is wanted</span>
<span class="sd">            SIunit -- str, default = None, the SI unit of the unit of which the prefix is wanted \</span>
<span class="sd">                        (eg 'eV' for 'keV'), if None, first character of unit is evaluated as prefix</span>
<span class="sd">            numeric -- bool, default = True, if numeric the prefix is translated to the numeric value \</span>
<span class="sd">                        (e.g. 1E3 for 'k')</span>
<span class="sd">        OUTPUT:</span>
<span class="sd">            prefix -- str or int, the character of the prefix or the numeric value of the prefix</span>
<span class="sd">        """</span>
        <span class="k">if</span> <span class="n">SIunit</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">lenSI</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">SIunit</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">unit</span><span class="p">[</span><span class="o">-</span><span class="n">lenSI</span><span class="p">:]</span> <span class="o">==</span> <span class="n">SIunit</span><span class="p">:</span>
                <span class="n">prefix</span> <span class="o">=</span> <span class="n">unit</span><span class="p">[:</span><span class="o">-</span><span class="n">lenSI</span><span class="p">]</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">prefix</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">numeric</span><span class="p">:</span> <span class="k">return</span> <span class="mi">1</span>
                    <span class="k">else</span><span class="p">:</span> <span class="k">return</span> <span class="n">prefix</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="s2">"provided unit not same as target unit: "</span> <span class="o">+</span> <span class="n">unit</span> <span class="o">+</span> <span class="s2">", and "</span> <span class="o">+</span> <span class="n">SIunit</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">numeric</span><span class="p">:</span> <span class="k">return</span> <span class="mi">1</span>
                <span class="k">else</span><span class="p">:</span> <span class="k">return</span> <span class="n">prefix</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">prefix</span> <span class="o">=</span> <span class="n">unit</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">numeric</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">prefix</span>
        
        <span class="k">if</span> <span class="n">prefix</span> <span class="o">==</span> <span class="s1">'p'</span><span class="p">:</span>
            <span class="k">return</span> <span class="mf">1E-12</span>
        <span class="k">if</span> <span class="n">prefix</span> <span class="o">==</span> <span class="s1">'n'</span><span class="p">:</span>
            <span class="k">return</span> <span class="mf">1E-9</span>
        <span class="k">if</span> <span class="n">prefix</span> <span class="o">==</span> <span class="s1">'μ'</span> <span class="ow">or</span> <span class="n">prefix</span> <span class="o">==</span> <span class="s1">'µ'</span> <span class="ow">or</span> <span class="n">prefix</span> <span class="o">==</span> <span class="s1">'u'</span><span class="p">:</span>
            <span class="k">return</span> <span class="mf">1E-6</span>
        <span class="k">if</span> <span class="n">prefix</span> <span class="o">==</span> <span class="s1">'m'</span><span class="p">:</span>
            <span class="k">return</span> <span class="mf">1E-3</span>
        <span class="k">if</span> <span class="n">prefix</span> <span class="o">==</span> <span class="s1">'k'</span><span class="p">:</span>
            <span class="k">return</span> <span class="mf">1E3</span>
        <span class="k">if</span> <span class="n">prefix</span> <span class="o">==</span> <span class="s1">'M'</span><span class="p">:</span>
            <span class="k">return</span> <span class="mf">1E6</span>
        <span class="k">if</span> <span class="n">prefix</span> <span class="o">==</span> <span class="s1">'G'</span><span class="p">:</span>
            <span class="k">return</span> <span class="mf">1E9</span>
        <span class="k">if</span> <span class="n">prefix</span> <span class="o">==</span> <span class="s1">'T'</span><span class="p">:</span>
            <span class="k">return</span> <span class="mf">1E12</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">"either no or unknown prefix in unit: "</span> <span class="o">+</span> <span class="n">unit</span> <span class="o">+</span> <span class="s2">", found prefix "</span> <span class="o">+</span> <span class="n">prefix</span> <span class="o">+</span> <span class="s2">", asuming no."</span><span class="p">)</span>
        <span class="k">return</span> <span class="mi">1</span></div>
    
<div class="viewcode-block" id="Spectral_image.calc_avg_ci"><a class="viewcode-back" href="../modules/image_class_bs.html#image_class_bs.Spectral_image.calc_avg_ci">[docs]</a>    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">calc_avg_ci</span><span class="p">(</span><span class="n">np_array</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">ci</span> <span class="o">=</span> <span class="mi">16</span><span class="p">,</span> <span class="n">return_low_high</span> <span class="o">=</span> <span class="kc">True</span><span class="p">):</span>
        <span class="n">avg</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">average</span><span class="p">(</span><span class="n">np_array</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">)</span>
        <span class="n">ci_low</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nanpercentile</span><span class="p">(</span><span class="n">np_array</span><span class="p">,</span>  <span class="n">ci</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">)</span>
        <span class="n">ci_high</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nanpercentile</span><span class="p">(</span><span class="n">np_array</span><span class="p">,</span>  <span class="mi">100</span><span class="o">-</span><span class="n">ci</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">return_low_high</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">avg</span><span class="p">,</span> <span class="n">ci_low</span><span class="p">,</span> <span class="n">ci_high</span>
        <span class="k">return</span> <span class="n">avg</span><span class="p">,</span> <span class="n">ci_high</span><span class="o">-</span><span class="n">ci_low</span></div>
    
    <span class="c1">#CLASS THINGIES</span>
    <span class="k">def</span> <span class="fm">__getitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">):</span>
        <span class="sd">""" Determines behavior of `self[key]` """</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="n">key</span><span class="p">]</span>
        <span class="c1">#pass</span>
    
    <span class="k">def</span> <span class="fm">__getattr__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">):</span>
        <span class="n">key</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_key</span><span class="p">(</span><span class="n">key</span><span class="p">)</span>
        <span class="k">return</span> <span class="nb">object</span><span class="o">.</span><span class="fm">__getattribute__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">)</span>
    
    <span class="k">def</span> <span class="fm">__setattr__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="n">key</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_key</span><span class="p">(</span><span class="n">key</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="vm">__dict__</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">value</span>
    	

    
    
    <span class="k">def</span> <span class="fm">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s1">'name'</span><span class="p">):</span>
            <span class="n">name_str</span> <span class="o">=</span> <span class="s2">", name = "</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">name_str</span> <span class="o">=</span> <span class="s2">""</span>
        <span class="k">return</span> <span class="s1">'Spectral image: '</span> <span class="o">+</span> <span class="n">name_str</span> <span class="o">+</span> <span class="s2">", image size:"</span><span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">+</span> <span class="s1">'x'</span> <span class="o">+</span> \
                    <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span> <span class="o">+</span> <span class="s1">', deltaE range: ['</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="nb">round</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">deltaE</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="mi">3</span><span class="p">))</span> <span class="o">+</span> <span class="s1">','</span> <span class="o">+</span> \
                        <span class="nb">str</span><span class="p">(</span><span class="nb">round</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">deltaE</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span><span class="mi">3</span><span class="p">))</span> <span class="o">+</span> <span class="s1">'], deltadeltaE: '</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="nb">round</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ddeltaE</span><span class="p">,</span><span class="mi">3</span><span class="p">))</span>
        
    <span class="k">def</span> <span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">data_str</span> <span class="o">=</span> <span class="s2">"data * np.ones("</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="o">+</span> <span class="s2">")"</span>
        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s1">'name'</span><span class="p">):</span>
            <span class="n">name_str</span> <span class="o">=</span> <span class="s2">", name = "</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">name_str</span> <span class="o">=</span> <span class="s2">""</span>
        <span class="k">return</span> <span class="s2">"Spectral_image("</span> <span class="o">+</span> <span class="n">data_str</span> <span class="o">+</span>  <span class="s2">", deltadeltaE="</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="nb">round</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ddeltaE</span><span class="p">,</span> <span class="mi">3</span><span class="p">))</span> <span class="o">+</span> <span class="n">name_str</span> <span class="o">+</span> <span class="s2">")"</span>
        
    <span class="k">def</span> <span class="fm">__len__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">l</span></div>
            

<span class="c1"># GENERAL DATA MODIFICATION FUNCTIONS  </span>

<div class="viewcode-block" id="CFT"><a class="viewcode-back" href="../modules/image_class_bs.html#image_class_bs.CFT">[docs]</a><span class="k">def</span> <span class="nf">CFT</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">):</span>
    <span class="n">x_0</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
    <span class="n">N_0</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argmin</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">absolute</span><span class="p">(</span><span class="n">x</span><span class="p">))</span>
    <span class="n">N</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
    <span class="n">x_max</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
    <span class="n">delta_x</span> <span class="o">=</span> <span class="p">(</span><span class="n">x_max</span><span class="o">-</span><span class="n">x_0</span><span class="p">)</span><span class="o">/</span><span class="n">N</span>
    <span class="n">k</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">N</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">N</span><span class="p">)</span>
    <span class="n">cont_factor</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="mi">2</span><span class="n">j</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">*</span><span class="n">N_0</span><span class="o">*</span><span class="n">k</span><span class="o">/</span><span class="n">N</span><span class="p">)</span><span class="o">*</span><span class="n">delta_x</span> <span class="c1">#np.exp(-1j*(x_0)*k*delta_omg)*delta_x</span>
    <span class="n">F_k</span> <span class="o">=</span> <span class="n">cont_factor</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">fft</span><span class="o">.</span><span class="n">fft</span><span class="p">(</span><span class="n">y</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">F_k</span></div>

<div class="viewcode-block" id="iCFT"><a class="viewcode-back" href="../modules/image_class_bs.html#image_class_bs.iCFT">[docs]</a><span class="k">def</span> <span class="nf">iCFT</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">Y_k</span><span class="p">):</span>
    <span class="n">x_0</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
    <span class="n">N_0</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argmin</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">absolute</span><span class="p">(</span><span class="n">x</span><span class="p">))</span>
    <span class="n">x_max</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
    <span class="n">N</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
    <span class="n">delta_x</span> <span class="o">=</span> <span class="p">(</span><span class="n">x_max</span><span class="o">-</span><span class="n">x_0</span><span class="p">)</span><span class="o">/</span><span class="n">N</span>
    <span class="n">k</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">N</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">N</span><span class="p">)</span>
    <span class="n">cont_factor</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="mi">2</span><span class="n">j</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">*</span><span class="n">N_0</span><span class="o">*</span><span class="n">k</span><span class="o">/</span><span class="n">N</span><span class="p">)</span>
    <span class="n">f_n</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">fft</span><span class="o">.</span><span class="n">ifft</span><span class="p">(</span><span class="n">cont_factor</span><span class="o">*</span><span class="n">Y_k</span><span class="p">)</span><span class="o">/</span><span class="n">delta_x</span> <span class="c1"># 2*np.pi ##np.exp(-2j*np.pi*x_0*k)</span>
    <span class="k">return</span> <span class="n">f_n</span>            </div>


<div class="viewcode-block" id="smooth_1D"><a class="viewcode-back" href="../modules/image_class_bs.html#image_class_bs.smooth_1D">[docs]</a><span class="k">def</span> <span class="nf">smooth_1D</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">window_len</span><span class="o">=</span><span class="mi">50</span><span class="p">,</span><span class="n">window</span><span class="o">=</span><span class="s1">'hanning'</span><span class="p">):</span>
    <span class="sd">"""smooth the data using a window with requested size.</span>

<span class="sd">    This method is based on the convolution of a scaled window with the signal.</span>
<span class="sd">    The signal is prepared by introducing reflected copies of the signal </span>
<span class="sd">    (with the window size) in both ends so that transient parts are minimized</span>
<span class="sd">    in the begining and end part of the output signal.</span>

<span class="sd">    input:</span>
<span class="sd">        x: the input signal </span>
<span class="sd">        window_len: the dimension of the smoothing window; should be an odd integer</span>
<span class="sd">        window: the type of window from 'flat', 'hanning', 'hamming', 'bartlett', 'blackman'</span>
<span class="sd">            flat window will produce a moving average smoothing.</span>

<span class="sd">    output:</span>
<span class="sd">        the smoothed signal</span>

<span class="sd">    """</span>
    <span class="c1">#TODO: add comnparison</span>
    <span class="n">window_len</span> <span class="o">+=</span> <span class="p">(</span><span class="n">window_len</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">%</span><span class="mi">2</span>
    <span class="n">s</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">r_</span><span class="p">[</span><span class="s1">'-1'</span><span class="p">,</span> <span class="n">data</span><span class="p">[</span><span class="n">window_len</span><span class="o">-</span><span class="mi">1</span><span class="p">:</span><span class="mi">0</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span><span class="n">data</span><span class="p">,</span><span class="n">data</span><span class="p">[</span><span class="o">-</span><span class="mi">2</span><span class="p">:</span><span class="o">-</span><span class="n">window_len</span><span class="o">-</span><span class="mi">1</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">]]</span>

    <span class="k">if</span> <span class="n">window</span> <span class="o">==</span> <span class="s1">'flat'</span><span class="p">:</span> <span class="c1">#moving average</span>
        <span class="n">w</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">window_len</span><span class="p">,</span><span class="s1">'d'</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">w</span><span class="o">=</span><span class="nb">eval</span><span class="p">(</span><span class="s1">'np.'</span><span class="o">+</span><span class="n">window</span><span class="o">+</span><span class="s1">'(window_len)'</span><span class="p">)</span>

    <span class="c1"># y=np.convolve(w/w.sum(),s,mode='valid')</span>
    <span class="c1"># return y[(window_len-1):-(window_len)]</span>
    <span class="n">surplus_data</span> <span class="o">=</span> <span class="nb">int</span><span class="p">((</span><span class="n">window_len</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="mf">0.5</span><span class="p">)</span>
    <span class="n">data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">apply_along_axis</span><span class="p">(</span><span class="k">lambda</span> <span class="n">m</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">convolve</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="n">w</span><span class="o">/</span><span class="n">w</span><span class="o">.</span><span class="n">sum</span><span class="p">(),</span> <span class="n">mode</span><span class="o">=</span><span class="s1">'valid'</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">arr</span><span class="o">=</span><span class="n">s</span><span class="p">)[</span><span class="n">surplus_data</span><span class="p">:</span><span class="o">-</span><span class="n">surplus_data</span><span class="p">]</span>
    <span class="k">return</span> <span class="n">data</span></div>



<span class="c1"># MODELING CLASSES AND FUNCTIONS</span>
<div class="viewcode-block" id="bandgap"><a class="viewcode-back" href="../modules/image_class_bs.html#image_class_bs.bandgap">[docs]</a><span class="k">def</span> <span class="nf">bandgap</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">amp</span><span class="p">,</span> <span class="n">BG</span><span class="p">,</span><span class="n">b</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">amp</span> <span class="o">*</span> <span class="p">(</span><span class="n">x</span> <span class="o">-</span> <span class="n">BG</span><span class="p">)</span><span class="o">**</span><span class="p">(</span><span class="n">b</span><span class="p">)</span></div>

<div class="viewcode-block" id="MLP"><a class="viewcode-back" href="../modules/image_class_bs.html#image_class_bs.MLP">[docs]</a><span class="k">class</span> <span class="nc">MLP</span><span class="p">(</span><span class="n">nn</span><span class="o">.</span><span class="n">Module</span><span class="p">):</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">num_inputs</span><span class="p">,</span> <span class="n">num_outputs</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">()</span>
        <span class="c1"># Initialize the modules we need to build the network</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">linear1</span> <span class="o">=</span> <span class="n">nn</span><span class="o">.</span><span class="n">Linear</span><span class="p">(</span><span class="n">num_inputs</span><span class="p">,</span> <span class="mi">10</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">linear2</span> <span class="o">=</span> <span class="n">nn</span><span class="o">.</span><span class="n">Linear</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="mi">15</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">linear3</span> <span class="o">=</span> <span class="n">nn</span><span class="o">.</span><span class="n">Linear</span><span class="p">(</span><span class="mi">15</span><span class="p">,</span> <span class="mi">5</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">output</span> <span class="o">=</span> <span class="n">nn</span><span class="o">.</span><span class="n">Linear</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="n">num_outputs</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">sigmoid</span> <span class="o">=</span> <span class="n">nn</span><span class="o">.</span><span class="n">Sigmoid</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">relu</span> <span class="o">=</span> <span class="n">nn</span><span class="o">.</span><span class="n">ReLU</span><span class="p">()</span>

<div class="viewcode-block" id="MLP.forward"><a class="viewcode-back" href="../modules/image_class_bs.html#image_class_bs.MLP.forward">[docs]</a>    <span class="k">def</span> <span class="nf">forward</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
        <span class="c1"># Perform the calculation of the model to determine the prediction</span>
        <span class="n">x</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">linear1</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
        <span class="n">x</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">sigmoid</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
        <span class="n">x</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">linear2</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
        <span class="n">x</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">sigmoid</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
        <span class="n">x</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">linear3</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
        <span class="n">x</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">relu</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
        <span class="n">x</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">output</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">x</span></div></div>

<div class="viewcode-block" id="scale"><a class="viewcode-back" href="../modules/image_class_bs.html#image_class_bs.scale">[docs]</a><span class="k">def</span> <span class="nf">scale</span><span class="p">(</span><span class="n">inp</span><span class="p">,</span> <span class="n">ab</span><span class="p">):</span>
    <span class="sd">"""</span>
<span class="sd">    min_inp = inp.min()</span>
<span class="sd">    max_inp = inp.max()</span>
<span class="sd">    </span>
<span class="sd">    outp = inp/(max_inp-min_inp) * (max_out-min_out)</span>
<span class="sd">    outp -= outp.min()</span>
<span class="sd">    outp += min_out</span>
<span class="sd">    </span>
<span class="sd">    return outp</span>
<span class="sd">    """</span>
    
    <span class="k">return</span> <span class="n">inp</span><span class="o">*</span><span class="n">ab</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">ab</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span></div>
    <span class="c1">#pass</span>

<div class="viewcode-block" id="find_scale_var"><a class="viewcode-back" href="../modules/image_class_bs.html#image_class_bs.find_scale_var">[docs]</a><span class="k">def</span> <span class="nf">find_scale_var</span><span class="p">(</span><span class="n">inp</span><span class="p">,</span> <span class="n">min_out</span> <span class="o">=</span> <span class="mf">0.1</span><span class="p">,</span> <span class="n">max_out</span><span class="o">=</span><span class="mf">0.9</span><span class="p">):</span>
    <span class="n">a</span> <span class="o">=</span> <span class="p">(</span><span class="n">max_out</span> <span class="o">-</span> <span class="n">min_out</span><span class="p">)</span><span class="o">/</span><span class="p">(</span><span class="n">inp</span><span class="o">.</span><span class="n">max</span><span class="p">()</span><span class="o">-</span> <span class="n">inp</span><span class="o">.</span><span class="n">min</span><span class="p">())</span>
    <span class="n">b</span> <span class="o">=</span> <span class="n">min_out</span> <span class="o">-</span> <span class="n">a</span><span class="o">*</span><span class="n">inp</span><span class="o">.</span><span class="n">min</span><span class="p">()</span>
    <span class="k">return</span> <span class="p">[</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">]</span></div>
</pre></div>
      </article>
      <footer>
        
        <div class="related-pages">
          
          
        </div>

        <div class="related-information">
              Copyright &#169; 2021, A
            |
            Built with <a href="https://www.sphinx-doc.org/">Sphinx</a>
              and
              <a class="muted-link" href="https://pradyunsg.me">@pradyunsg</a>'s
              <a href="https://github.com/pradyunsg/furo">Furo theme</a>.
        </div>
        
      </footer>
    </div>
    <aside class="toc-drawer no-toc">
      
      
      
    </aside>
  </main>
</div>
    <script id="documentation_options" data-url_root="../" src="../_static/documentation_options.js"></script>
    <script src="../_static/jquery.js"></script>
    <script src="../_static/underscore.js"></script>
    <script src="../_static/doctools.js"></script>
    <script src="../_static/scripts/main.js?digest=e931d09b2a40c1bb82b542effe772014573baf67"></script></body>
</html>