

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>image_class_bs &mdash; EELSfitter 0.0.1 documentation</title>
  

  
  
  
  

  
  <script type="text/javascript" src="../_static/js/modernizr.min.js"></script>
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="../" src="../_static/documentation_options.js"></script>
        <script src="../_static/jquery.js"></script>
        <script src="../_static/underscore.js"></script>
        <script src="../_static/doctools.js"></script>
        <script src="../_static/language_data.js"></script>
        <script async="async" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
    
    <script type="text/javascript" src="../_static/js/theme.js"></script>

    

  
  <link rel="stylesheet" href="../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="../index.html" class="icon icon-home"> EELSfitter
          

          
          </a>

          
            
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <p class="caption"><span class="caption-text">Overview:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../overview/features.html">Features</a></li>
<li class="toctree-l1"><a class="reference internal" href="../overview/datasets.html">Datasets</a></li>
</ul>
<p class="caption"><span class="caption-text">Theory</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../theory/kk_analysis.html">Kramer-Kronig Analysis</a></li>
</ul>
<p class="caption"><span class="caption-text">Implementation</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../implementation/training_strategies.html">Training Strategies</a></li>
</ul>
<p class="caption"><span class="caption-text">Results</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../results/EELS_10.html">EELS 1.0</a></li>
<li class="toctree-l1"><a class="reference internal" href="../results/EELS_20.html">EELS 2.0</a></li>
</ul>
<p class="caption"><span class="caption-text">Code</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../modules/modules.html">API</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../index.html">EELSfitter</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../index.html">Docs</a> &raquo;</li>
        
          <li><a href="index.html">Module code</a> &raquo;</li>
        
      <li>image_class_bs</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <h1>Source code for image_class_bs</h1><div class="highlight"><pre>
<span></span><span class="ch">#!/usr/bin/env python3</span>
<span class="c1"># -*- coding: utf-8 -*-</span>
<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">Created on Fri Dec 18 17:38:57 2020</span>

<span class="sd">@author: isabel</span>
<span class="sd">&quot;&quot;&quot;</span>
<span class="c1">#!/usr/bin/env python3</span>
<span class="c1"># -*- coding: utf-8 -*-</span>
<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">Created on Thu Dec 17 23:12:19 2020</span>

<span class="sd">@author: isabel</span>
<span class="sd">&quot;&quot;&quot;</span>
<span class="c1">#!/usr/bin/env python3</span>
<span class="c1"># -*- coding: utf-8 -*-</span>
<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">Created on Tue Nov 10 01:05:56 2020</span>

<span class="sd">@author: isabel</span>
<span class="sd">&quot;&quot;&quot;</span>

<span class="kn">import</span> <span class="nn">pandas</span> <span class="k">as</span> <span class="nn">pd</span>
<span class="kn">import</span> <span class="nn">glob</span>
<span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>
<span class="kn">from</span> <span class="nn">matplotlib.colors</span> <span class="kn">import</span> <span class="n">LinearSegmentedColormap</span>
<span class="kn">from</span> <span class="nn">matplotlib</span> <span class="kn">import</span> <span class="n">cm</span>
<span class="kn">import</span> <span class="nn">seaborn</span> <span class="k">as</span> <span class="nn">sns</span>
<span class="kn">import</span> <span class="nn">natsort</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">math</span>
<span class="kn">from</span> <span class="nn">scipy.fftpack</span> <span class="kn">import</span> <span class="n">next_fast_len</span>
<span class="kn">from</span> <span class="nn">scipy.optimize</span> <span class="kn">import</span> <span class="n">curve_fit</span>
<span class="kn">import</span> <span class="nn">logging</span>
<span class="kn">from</span> <span class="nn">ncempy.io</span> <span class="kn">import</span> <span class="n">dm</span>
<span class="kn">import</span> <span class="nn">os</span>
<span class="kn">import</span> <span class="nn">copy</span>
<span class="kn">import</span> <span class="nn">pickle</span>
<span class="kn">import</span> <span class="nn">warnings</span>
<span class="kn">import</span> <span class="nn">torch</span>
<span class="kn">import</span> <span class="nn">torch.nn</span> <span class="k">as</span> <span class="nn">nn</span>
<span class="kn">import</span> <span class="nn">torch.nn.functional</span> <span class="k">as</span> <span class="nn">F</span>

<span class="kn">import</span> <span class="nn">bz2</span>
<span class="kn">import</span> <span class="nn">pickle</span>
<span class="kn">import</span> <span class="nn">_pickle</span> <span class="k">as</span> <span class="nn">cPickle</span>


<span class="kn">from</span> <span class="nn">k_means_clustering</span> <span class="kn">import</span> <span class="n">k_means</span>
<span class="kn">from</span> <span class="nn">train_nn_torch_bs</span> <span class="kn">import</span> <span class="n">train_nn_scaled</span>


<span class="n">_logger</span> <span class="o">=</span> <span class="n">logging</span><span class="o">.</span><span class="n">getLogger</span><span class="p">(</span><span class="vm">__name__</span><span class="p">)</span>


<div class="viewcode-block" id="Spectral_image"><a class="viewcode-back" href="../modules/image_class_bs.html#image_class_bs.Spectral_image">[docs]</a><span class="k">class</span> <span class="nc">Spectral_image</span><span class="p">():</span>
    <span class="n">DIELECTRIC_FUNCTION_NAMES</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;dielectric_function&#39;</span><span class="p">,</span> <span class="s1">&#39;dielectricfunction&#39;</span><span class="p">,</span> <span class="s1">&#39;dielec_func&#39;</span><span class="p">,</span> <span class="s1">&#39;die_fun&#39;</span><span class="p">,</span> <span class="s1">&#39;df&#39;</span><span class="p">,</span> <span class="s1">&#39;epsilon&#39;</span><span class="p">]</span>
    <span class="n">EELS_NAMES</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;electron_energy_loss_spectrum&#39;</span><span class="p">,</span><span class="s1">&#39;electron_energy_loss&#39;</span><span class="p">,</span><span class="s1">&#39;EELS&#39;</span><span class="p">,</span> <span class="s1">&#39;EEL&#39;</span><span class="p">,</span> <span class="s1">&#39;energy_loss&#39;</span><span class="p">,</span> <span class="s1">&#39;data&#39;</span><span class="p">]</span>
    <span class="n">IEELS_NAMES</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;inelastic_scattering_energy_loss_spectrum&#39;</span><span class="p">,</span> <span class="s1">&#39;inelastic_scattering_energy_loss&#39;</span><span class="p">,</span> <span class="s1">&#39;inelastic_scattering&#39;</span><span class="p">,</span> <span class="s1">&#39;IEELS&#39;</span><span class="p">,</span> <span class="s1">&#39;IES&#39;</span><span class="p">]</span>
    <span class="n">ZLP_NAMES</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;zeros_loss_peak&#39;</span><span class="p">,</span> <span class="s1">&#39;zero_loss&#39;</span><span class="p">,</span> <span class="s1">&#39;ZLP&#39;</span><span class="p">,</span> <span class="s1">&#39;ZLPs&#39;</span><span class="p">,</span> <span class="s1">&#39;zlp&#39;</span><span class="p">,</span> <span class="s1">&#39;zlps&#39;</span><span class="p">]</span>
    <span class="n">THICKNESS_NAMES</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;t&#39;</span><span class="p">,</span> <span class="s1">&#39;thickness&#39;</span><span class="p">,</span> <span class="s1">&#39;thick&#39;</span><span class="p">,</span> <span class="s1">&#39;thin&#39;</span><span class="p">]</span>
    <span class="n">POOLED_ADDITION</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;pooled&#39;</span><span class="p">,</span> <span class="s1">&#39;pool&#39;</span><span class="p">,</span> <span class="s1">&#39;p&#39;</span><span class="p">,</span> <span class="s1">&#39;_pooled&#39;</span><span class="p">,</span> <span class="s1">&#39;_pool&#39;</span><span class="p">,</span> <span class="s1">&#39;_p&#39;</span><span class="p">]</span>
    
    
    
    <span class="n">m_0</span> <span class="o">=</span> <span class="mf">511.06</span> <span class="c1">#eV, electron rest mass</span>
    <span class="n">a_0</span> <span class="o">=</span> <span class="mf">5.29E-11</span> <span class="c1">#m, Bohr radius</span>
    <span class="n">h_bar</span> <span class="o">=</span> <span class="mf">6.582119569E-16</span> <span class="c1">#eV/s</span>
    <span class="n">c</span> <span class="o">=</span> <span class="mf">2.99792458E8</span> <span class="c1">#m/s</span>
    
    
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">deltadeltaE</span><span class="p">,</span> <span class="n">pixelsize</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">beam_energy</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">collection_angle</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">name</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        INPUT:</span>
<span class="sd">            data = 3D-numpy array (x-axis x y-axis x energy loss-axis), spectral image data</span>
<span class="sd">            deltadeltaE = float, width of energy loss bins</span>
<span class="sd">        Keyword-arguments:</span>
<span class="sd">            pixelsize = float (default: None), width of pixels</span>
<span class="sd">            beam_energy = float (default: None), energy of electron beam [eV]</span>
<span class="sd">            collection_angle = float (default: None), collection angle of STEM [rad]</span>
<span class="sd">            name = str (default: None), name if given along is used in title of plots</span>
<span class="sd">        &quot;&quot;&quot;</span>
        
        <span class="bp">self</span><span class="o">.</span><span class="n">data</span> <span class="o">=</span> <span class="n">data</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">ddeltaE</span> <span class="o">=</span> <span class="n">deltadeltaE</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">determine_deltaE</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">pixelsize</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">pixelsize</span> <span class="o">=</span> <span class="n">pixelsize</span><span class="o">*</span><span class="mf">1E6</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">calc_axes</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">beam_energy</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">beam_energy</span> <span class="o">=</span> <span class="n">beam_energy</span>
        <span class="k">if</span> <span class="n">collection_angle</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">collection_angle</span> <span class="o">=</span> <span class="n">collection_angle</span>
        <span class="k">if</span> <span class="n">name</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="n">name</span>
    
<div class="viewcode-block" id="Spectral_image.save_image"><a class="viewcode-back" href="../modules/image_class_bs.html#image_class_bs.Spectral_image.save_image">[docs]</a>    <span class="k">def</span> <span class="nf">save_image</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">filename</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">filename</span><span class="p">[</span><span class="o">-</span><span class="mi">4</span><span class="p">:]</span> <span class="o">!=</span> <span class="s1">&#39;.pkl&#39;</span><span class="p">:</span>
            <span class="n">filename</span> <span class="o">+</span> <span class="s1">&#39;.pkl&#39;</span>
        <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">filename</span><span class="p">,</span> <span class="s1">&#39;wb&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">output</span><span class="p">:</span>  <span class="c1"># Overwrites any existing file.</span>
            <span class="n">pickle</span><span class="o">.</span><span class="n">dump</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">output</span><span class="p">,</span> <span class="n">pickle</span><span class="o">.</span><span class="n">HIGHEST_PROTOCOL</span><span class="p">)</span></div>
    
<div class="viewcode-block" id="Spectral_image.save_compressed_image"><a class="viewcode-back" href="../modules/image_class_bs.html#image_class_bs.Spectral_image.save_compressed_image">[docs]</a>    <span class="k">def</span> <span class="nf">save_compressed_image</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">filename</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">compressed_pickle</span><span class="p">(</span><span class="n">filename</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span> </div>
        
<div class="viewcode-block" id="Spectral_image.compressed_pickle"><a class="viewcode-back" href="../modules/image_class_bs.html#image_class_bs.Spectral_image.compressed_pickle">[docs]</a>    <span class="nd">@staticmethod</span>
    <span class="c1"># Pickle a file and then compress it into a file with extension </span>
    <span class="k">def</span> <span class="nf">compressed_pickle</span><span class="p">(</span><span class="n">title</span><span class="p">,</span> <span class="n">data</span><span class="p">):</span>
        <span class="k">with</span> <span class="n">bz2</span><span class="o">.</span><span class="n">BZ2File</span><span class="p">(</span><span class="n">title</span> <span class="o">+</span> <span class="s1">&#39;.pbz2&#39;</span><span class="p">,</span> <span class="s1">&#39;w&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span> 
            <span class="n">cPickle</span><span class="o">.</span><span class="n">dump</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">f</span><span class="p">)</span></div>
    
<div class="viewcode-block" id="Spectral_image.decompress_pickle"><a class="viewcode-back" href="../modules/image_class_bs.html#image_class_bs.Spectral_image.decompress_pickle">[docs]</a>    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">decompress_pickle</span><span class="p">(</span><span class="n">file</span><span class="p">):</span>
        <span class="n">data</span> <span class="o">=</span> <span class="n">bz2</span><span class="o">.</span><span class="n">BZ2File</span><span class="p">(</span><span class="n">file</span><span class="p">,</span> <span class="s1">&#39;rb&#39;</span><span class="p">)</span>
        <span class="n">data</span> <span class="o">=</span> <span class="n">cPickle</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">data</span></div>


    <span class="c1">#%%GENERAL FUNCTIONS</span>
    
    <span class="c1">#%%PROPERTIES</span>
    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">l</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;returns length of spectra, i.e. num energy loss bins&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>
    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">image_shape</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;return 2D-shape of spectral image&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">[:</span><span class="mi">2</span><span class="p">]</span>
    
    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">shape</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;returns 3D-shape of spectral image&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">shape</span>
        
    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">n_clusters</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;return number of clusters image is clustered into&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">clusters</span><span class="p">)</span>
    
    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">n_spectra</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;returns number of spectra in specral image&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">product</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">image_shape</span><span class="p">)</span>
    
<div class="viewcode-block" id="Spectral_image.load_data"><a class="viewcode-back" href="../modules/image_class_bs.html#image_class_bs.Spectral_image.load_data">[docs]</a>    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">load_data</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">path_to_dmfile</span><span class="p">,</span> <span class="n">load_additional_data</span> <span class="o">=</span> <span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        INPUT: </span>
<span class="sd">            path_to_dmfile: str, path to spectral image file (.dm3 or .dm4 extension)</span>
<span class="sd">        OUTPUT:</span>
<span class="sd">            image -- Spectral_image, object of Spectral_image class containing the data of the dm-file</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">dmfile_tot</span> <span class="o">=</span> <span class="n">dm</span><span class="o">.</span><span class="n">fileDM</span><span class="p">(</span><span class="n">path_to_dmfile</span><span class="p">)</span>
        <span class="n">additional_data</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">dmfile_tot</span><span class="o">.</span><span class="n">numObjects</span> <span class="o">-</span> <span class="n">dmfile_tot</span><span class="o">.</span><span class="n">thumbnail</span><span class="o">*</span><span class="mi">1</span><span class="p">):</span>
            <span class="n">dmfile</span> <span class="o">=</span> <span class="n">dmfile_tot</span><span class="o">.</span><span class="n">getDataset</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">dmfile</span><span class="p">[</span><span class="s1">&#39;data&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">3</span><span class="p">:</span>
                <span class="n">dmfile</span> <span class="o">=</span> <span class="n">dmfile_tot</span><span class="o">.</span><span class="n">getDataset</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
                <span class="n">data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">swapaxes</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">swapaxes</span><span class="p">(</span><span class="n">dmfile</span><span class="p">[</span><span class="s1">&#39;data&#39;</span><span class="p">],</span> <span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">),</span> <span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">)</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">load_additional_data</span><span class="p">:</span>
                    <span class="k">break</span>
            <span class="k">elif</span> <span class="n">load_additional_data</span><span class="p">:</span>
                <span class="n">additional_data</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">dmfile_tot</span><span class="o">.</span><span class="n">getDataset</span><span class="p">(</span><span class="n">i</span><span class="p">))</span>
            <span class="k">if</span> <span class="n">i</span> <span class="o">==</span> <span class="n">dmfile_tot</span><span class="o">.</span><span class="n">numObjects</span> <span class="o">-</span> <span class="n">dmfile_tot</span><span class="o">.</span><span class="n">thumbnail</span><span class="o">*</span><span class="mi">1</span> <span class="o">-</span> <span class="mi">1</span><span class="p">:</span>
                <span class="k">if</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">additional_data</span><span class="p">)</span> <span class="o">==</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="ow">or</span> <span class="ow">not</span> <span class="n">load_additional_data</span><span class="p">:</span>
                    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;No spectral image detected&quot;</span><span class="p">)</span>
                    <span class="n">dmfile</span> <span class="o">=</span> <span class="n">dmfile_tot</span><span class="o">.</span><span class="n">getDataset</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
                    <span class="n">data</span> <span class="o">=</span> <span class="n">dmfile</span><span class="p">[</span><span class="s1">&#39;data&#39;</span><span class="p">]</span>
        
        <span class="c1">#.getDataset(0)</span>
        <span class="n">ddeltaE</span> <span class="o">=</span> <span class="n">dmfile</span><span class="p">[</span><span class="s1">&#39;pixelSize&#39;</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">pixelsize</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">dmfile</span><span class="p">[</span><span class="s1">&#39;pixelSize&#39;</span><span class="p">][</span><span class="mi">1</span><span class="p">:])</span>
        <span class="n">energyUnit</span> <span class="o">=</span> <span class="n">dmfile</span><span class="p">[</span><span class="s1">&#39;pixelUnit&#39;</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">ddeltaE</span> <span class="o">*=</span> <span class="bp">cls</span><span class="o">.</span><span class="n">get_prefix</span><span class="p">(</span><span class="n">energyUnit</span><span class="p">,</span> <span class="s1">&#39;eV&#39;</span><span class="p">)</span>
        <span class="n">pixelUnit</span> <span class="o">=</span> <span class="n">dmfile</span><span class="p">[</span><span class="s1">&#39;pixelUnit&#39;</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">pixelsize</span> <span class="o">*=</span> <span class="bp">cls</span><span class="o">.</span><span class="n">get_prefix</span><span class="p">(</span><span class="n">pixelUnit</span><span class="p">,</span> <span class="s1">&#39;m&#39;</span><span class="p">)</span>
        <span class="n">image</span> <span class="o">=</span> <span class="bp">cls</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">ddeltaE</span><span class="p">,</span> <span class="n">pixelsize</span> <span class="o">=</span> <span class="n">pixelsize</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="n">path_to_dmfile</span><span class="p">[:</span><span class="o">-</span><span class="mi">4</span><span class="p">])</span>
        <span class="k">if</span> <span class="n">load_additional_data</span><span class="p">:</span>
            <span class="n">image</span><span class="o">.</span><span class="n">additional_data</span> <span class="o">=</span> <span class="n">additional_data</span>
        <span class="k">return</span> <span class="n">image</span></div>
    
<div class="viewcode-block" id="Spectral_image.load_Spectral_image"><a class="viewcode-back" href="../modules/image_class_bs.html#image_class_bs.Spectral_image.load_Spectral_image">[docs]</a>    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">load_Spectral_image</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">path_to_pickle</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">path_to_pickle</span><span class="p">[</span><span class="o">-</span><span class="mi">4</span><span class="p">:]</span> <span class="o">!=</span> <span class="s1">&#39;.pkl&#39;</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;please provide a path to a pickle file containing a Spectrall_image class object.&quot;</span><span class="p">)</span>
            <span class="k">return</span>
        <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">path_to_pickle</span><span class="p">,</span> <span class="s1">&#39;rb&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">pickle_im</span><span class="p">:</span>
            <span class="n">image</span> <span class="o">=</span> <span class="n">pickle</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="n">pickle_im</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">image</span></div>
    
    
<div class="viewcode-block" id="Spectral_image.load_compressed_Spectral_image"><a class="viewcode-back" href="../modules/image_class_bs.html#image_class_bs.Spectral_image.load_compressed_Spectral_image">[docs]</a>    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">load_compressed_Spectral_image</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">path_to_compressed_pickle</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">path_to_compressed_pickle</span><span class="p">[</span><span class="o">-</span><span class="mi">5</span><span class="p">:]</span> <span class="o">!=</span> <span class="s1">&#39;.pbz2&#39;</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;please provide a path to a compressed .pbz2 pickle file containing a Spectrall_image class object.&quot;</span><span class="p">)</span>
            <span class="k">return</span>
        <span class="n">image</span> <span class="o">=</span> <span class="bp">cls</span><span class="o">.</span><span class="n">decompress_pickle</span><span class="p">(</span><span class="n">path_to_compressed_pickle</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">image</span></div>
    
    
<div class="viewcode-block" id="Spectral_image.set_n"><a class="viewcode-back" href="../modules/image_class_bs.html#image_class_bs.Spectral_image.set_n">[docs]</a>    <span class="k">def</span> <span class="nf">set_n</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">n_vac</span> <span class="o">=</span> <span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        LET OP WELKE WAARDE n_vac is en welke n_sample</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        n : TYPE</span>
<span class="sd">            DESCRIPTION.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        None.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">n</span><span class="p">)</span> <span class="o">==</span> <span class="nb">float</span> <span class="ow">or</span> <span class="nb">type</span><span class="p">(</span><span class="n">n</span><span class="p">)</span> <span class="o">==</span> <span class="nb">int</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">n</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n_clusters</span><span class="p">)</span><span class="o">*</span><span class="n">n</span>
            <span class="k">if</span> <span class="n">n_vac</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">n</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">n_vac</span>
        <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">n</span><span class="p">)</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_clusters</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">n</span> <span class="o">=</span> <span class="n">n</span></div>
    
    
    
<div class="viewcode-block" id="Spectral_image.determine_deltaE"><a class="viewcode-back" href="../modules/image_class_bs.html#image_class_bs.Spectral_image.determine_deltaE">[docs]</a>    <span class="k">def</span> <span class="nf">determine_deltaE</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        INPUT: </span>
<span class="sd">            self</span>
<span class="sd">        </span>
<span class="sd">        Determines the delta energies of the spectral image, based on the delta delta energie,</span>
<span class="sd">        and the index on which the spectral image has on average the highest intesity, this </span>
<span class="sd">        is taken as the zero point for the delta energy.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">data_avg</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">average</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">,</span> <span class="n">axis</span> <span class="o">=</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">))</span>
        <span class="n">ind_max</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argmax</span><span class="p">(</span><span class="n">data_avg</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">deltaE</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="o">-</span><span class="n">ind_max</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">ddeltaE</span><span class="p">,</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">l</span><span class="o">-</span><span class="n">ind_max</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">ddeltaE</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">l</span><span class="p">)</span></div>
        <span class="c1">#return deltaE</span>
    
    
<div class="viewcode-block" id="Spectral_image.calc_axes"><a class="viewcode-back" href="../modules/image_class_bs.html#image_class_bs.Spectral_image.calc_axes">[docs]</a>    <span class="k">def</span> <span class="nf">calc_axes</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">image_shape</span> <span class="o">=</span> <span class="kc">None</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">image_shape</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">image_shape</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">image_shape</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">y_axis</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">image_shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">image_shape</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">x_axis</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">image_shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">image_shape</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s1">&#39;pixelsize&#39;</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">y_axis</span> <span class="o">*=</span> <span class="bp">self</span><span class="o">.</span><span class="n">pixelsize</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">x_axis</span> <span class="o">*=</span> <span class="bp">self</span><span class="o">.</span><span class="n">pixelsize</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> </div>
    
    <span class="c1">#%%RETRIEVING FUNCTIONS</span>
<div class="viewcode-block" id="Spectral_image.get_data"><a class="viewcode-back" href="../modules/image_class_bs.html#image_class_bs.Spectral_image.get_data">[docs]</a>    <span class="k">def</span> <span class="nf">get_data</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span> <span class="c1">#TODO: add smooth possibility</span>
        <span class="sd">&quot;&quot;&quot;returns spectra image data in 3D-numpy array (x-axis x y-axis x energy loss-axis)&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span></div>
    
<div class="viewcode-block" id="Spectral_image.get_deltaE"><a class="viewcode-back" href="../modules/image_class_bs.html#image_class_bs.Spectral_image.get_deltaE">[docs]</a>    <span class="k">def</span> <span class="nf">get_deltaE</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;returns energy loss axis in numpy array&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">deltaE</span></div>
    
<div class="viewcode-block" id="Spectral_image.get_metadata"><a class="viewcode-back" href="../modules/image_class_bs.html#image_class_bs.Spectral_image.get_metadata">[docs]</a>    <span class="k">def</span> <span class="nf">get_metadata</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;returns list with values for beam_energy and collection_angle, if defined&quot;&quot;&quot;</span>
        <span class="n">meta_data</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">beam_energy</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">meta_data</span><span class="p">[</span><span class="s1">&#39;beam_energy&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">beam_energy</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">collection_angle</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">meta_data</span><span class="p">[</span><span class="s1">&#39;collection_angle&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">collection_angle</span>
        <span class="k">return</span> <span class="n">meta_data</span></div>
    
<div class="viewcode-block" id="Spectral_image.get_pixel_signal"><a class="viewcode-back" href="../modules/image_class_bs.html#image_class_bs.Spectral_image.get_pixel_signal">[docs]</a>    <span class="k">def</span> <span class="nf">get_pixel_signal</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">,</span> <span class="n">signal</span> <span class="o">=</span> <span class="s1">&#39;EELS&#39;</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        INPUT:</span>
<span class="sd">            i: int, x-coordinate for the pixel</span>
<span class="sd">            j: int, y-coordinate for the pixel</span>
<span class="sd">        Keyword argument:</span>
<span class="sd">            signal: str (default = &#39;EELS&#39;), what signal is requested, should comply with defined names</span>
<span class="sd">        OUTPUT:</span>
<span class="sd">            signal: 1D numpy array, array with the requested signal from the requested pixel</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1">#TODO: add alternative signals + names</span>
        <span class="k">if</span> <span class="n">signal</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">EELS_NAMES</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">[</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="p">:])</span>
        <span class="k">elif</span> <span class="n">signal</span> <span class="o">==</span> <span class="s2">&quot;pooled&quot;</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">pooled</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">,:])</span>
        <span class="k">elif</span> <span class="n">signal</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">DIELECTRIC_FUNCTION_NAMES</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dielectric_function_im_avg</span><span class="p">[</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="p">:])</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;no such signal&quot;</span><span class="p">,</span> <span class="n">signal</span><span class="p">,</span> <span class="s2">&quot;, returned general EELS signal.&quot;</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">[</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="p">:])</span></div>
        
<div class="viewcode-block" id="Spectral_image.get_image_signals"><a class="viewcode-back" href="../modules/image_class_bs.html#image_class_bs.Spectral_image.get_image_signals">[docs]</a>    <span class="k">def</span> <span class="nf">get_image_signals</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">signal</span> <span class="o">=</span> <span class="s1">&#39;EELS&#39;</span><span class="p">):</span>
        <span class="c1">#TODO: add alternative signals + names</span>
        <span class="k">if</span> <span class="n">signal</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">EELS_NAMES</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">signal</span> <span class="o">==</span> <span class="s2">&quot;pooled&quot;</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">pooled</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">signal</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">DIELECTRIC_FUNCTION_NAMES</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dielectric_function_im_avg</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;no such signal&quot;</span><span class="p">,</span> <span class="n">signal</span><span class="p">,</span> <span class="s2">&quot;, returned general EELS data.&quot;</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">)</span></div>
    
    
<div class="viewcode-block" id="Spectral_image.get_cluster_spectra"><a class="viewcode-back" href="../modules/image_class_bs.html#image_class_bs.Spectral_image.get_cluster_spectra">[docs]</a>    <span class="k">def</span> <span class="nf">get_cluster_spectra</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">conf_interval</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span> <span class="n">clusters</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">save_as_attribute</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span> <span class="n">based_upon</span> <span class="o">=</span> <span class="s2">&quot;log&quot;</span><span class="p">,</span> <span class="n">signal</span> <span class="o">=</span> <span class="s2">&quot;EELS&quot;</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        conf_interval : float, optional</span>
<span class="sd">            The ratio of spectra returned. The spectra are selected based on the </span>
<span class="sd">            based_upon value. The default is 0.68.</span>
<span class="sd">        clusters : list of ints, optional #TODO: finish</span>
<span class="sd">            DESCRIPTION. The default is None.</span>
<span class="sd">        save_as_attribute : TYPE, optional</span>
<span class="sd">            DESCRIPTION. The default is False.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        cluster_data : np.array of type object, filled with 2D numpy arrays</span>
<span class="sd">            Each cell of the super numpy array is filled with the data of all spectra </span>
<span class="sd">            with in one of the requested clusters.</span>
<span class="sd">            </span>
<span class="sd">        Atributes</span>
<span class="sd">        ---------</span>
<span class="sd">        self.cluster_data: np.array of type object, filled with 2D numpy arrays</span>
<span class="sd">            If save_as_attribute set to True, the cluster data is also saved as attribute</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1">#TODO: check clustering before everything</span>
        <span class="k">if</span> <span class="n">clusters</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">clusters</span> <span class="o">=</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n_clusters</span><span class="p">)</span>
        
        <span class="n">integrated_I</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">,</span> <span class="n">axis</span> <span class="o">=</span> <span class="mi">2</span><span class="p">)</span>
        <span class="n">cluster_data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">clusters</span><span class="p">),</span> <span class="n">dtype</span> <span class="o">=</span> <span class="nb">object</span><span class="p">)</span>
        
        <span class="n">j</span><span class="o">=</span><span class="mi">0</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">clusters</span><span class="p">:</span>
            <span class="n">data_cluster</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_image_signals</span><span class="p">(</span><span class="n">signal</span><span class="p">)[</span><span class="bp">self</span><span class="o">.</span><span class="n">clustered</span> <span class="o">==</span> <span class="n">i</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">conf_interval</span> <span class="o">&lt;</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">intensities_cluster</span> <span class="o">=</span> <span class="n">integrated_I</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">clustered</span> <span class="o">==</span> <span class="n">i</span><span class="p">]</span>
                <span class="n">arg_sort_I</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argsort</span><span class="p">(</span><span class="n">intensities_cluster</span><span class="p">)</span>
                <span class="n">ci_lim</span> <span class="o">=</span> <span class="nb">round</span><span class="p">((</span><span class="mi">1</span><span class="o">-</span><span class="n">conf_interval</span><span class="p">)</span><span class="o">/</span><span class="mi">2</span> <span class="o">*</span><span class="n">intensities_cluster</span><span class="o">.</span><span class="n">size</span><span class="p">)</span> <span class="c1">#TODO: ask juan: round up or down?</span>
                <span class="n">data_cluster</span> <span class="o">=</span> <span class="n">data_cluster</span><span class="p">[</span><span class="n">arg_sort_I</span><span class="p">][</span><span class="n">ci_lim</span><span class="p">:</span><span class="o">-</span><span class="n">ci_lim</span><span class="p">]</span>
            <span class="c1"># intensities_cluster = np.ones(len(intensities_cluster)-2*ci_lim)*self.clusters[i]</span>
            <span class="n">cluster_data</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">data_cluster</span>
            <span class="n">j</span> <span class="o">+=</span> <span class="mi">1</span>
        
        <span class="k">if</span> <span class="n">save_as_attribute</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">cluster_data</span> <span class="o">=</span> <span class="n">cluster_data</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">cluster_data</span></div>
    
    
    <span class="c1">#%%METHODS ON SIGNAL</span>
    
<div class="viewcode-block" id="Spectral_image.cut"><a class="viewcode-back" href="../modules/image_class_bs.html#image_class_bs.Spectral_image.cut">[docs]</a>    <span class="k">def</span> <span class="nf">cut</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">E1</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">E2</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">in_ex</span> <span class="o">=</span> <span class="s2">&quot;in&quot;</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        E1 : TYPE, optional</span>
<span class="sd">            DESCRIPTION. The default is None.</span>
<span class="sd">        E2 : TYPE, optional</span>
<span class="sd">            DESCRIPTION. The default is None.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        None.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">E1</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">E1</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">deltaE</span><span class="o">.</span><span class="n">min</span><span class="p">()</span> <span class="o">-</span><span class="mi">1</span>
        <span class="k">if</span> <span class="n">E2</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">E2</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">deltaE</span><span class="o">.</span><span class="n">max</span><span class="p">()</span> <span class="o">+</span><span class="mi">1</span>
        <span class="k">if</span> <span class="n">in_ex</span> <span class="o">==</span> <span class="s2">&quot;in&quot;</span><span class="p">:</span>
            <span class="n">select</span> <span class="o">=</span> <span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">deltaE</span> <span class="o">&gt;=</span> <span class="n">E1</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">deltaE</span> <span class="o">&lt;=</span> <span class="n">E2</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span> 
            <span class="n">select</span> <span class="o">=</span> <span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">deltaE</span> <span class="o">&gt;</span> <span class="n">E1</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">deltaE</span> <span class="o">&lt;</span> <span class="n">E2</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">[:,:,</span><span class="n">select</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">deltaE</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">deltaE</span><span class="p">[</span><span class="n">select</span><span class="p">]</span>
        <span class="c1">#TODO add selecting of all attributes</span>
        <span class="k">pass</span></div>
    
<div class="viewcode-block" id="Spectral_image.cut_image"><a class="viewcode-back" href="../modules/image_class_bs.html#image_class_bs.Spectral_image.cut_image">[docs]</a>    <span class="k">def</span> <span class="nf">cut_image</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">range_width</span><span class="p">,</span> <span class="n">range_height</span><span class="p">):</span>
        <span class="c1">#TODO: add floats for cutting to meter sizes?</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="n">range_height</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span><span class="n">range_height</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">range_width</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span><span class="n">range_width</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">y_axis</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">y_axis</span><span class="p">[</span><span class="n">range_height</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span><span class="n">range_height</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">x_axis</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">x_axis</span><span class="p">[</span><span class="n">range_width</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span><span class="n">range_width</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span></div>
    
    <span class="c1">#TODO</span>
<div class="viewcode-block" id="Spectral_image.samenvoegen"><a class="viewcode-back" href="../modules/image_class_bs.html#image_class_bs.Spectral_image.samenvoegen">[docs]</a>    <span class="k">def</span> <span class="nf">samenvoegen</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">pass</span></div>
    
<div class="viewcode-block" id="Spectral_image.smooth"><a class="viewcode-back" href="../modules/image_class_bs.html#image_class_bs.Spectral_image.smooth">[docs]</a>    <span class="k">def</span> <span class="nf">smooth</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">window_len</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span><span class="n">window</span><span class="o">=</span><span class="s1">&#39;hanning&#39;</span><span class="p">,</span> <span class="n">keep_original</span> <span class="o">=</span> <span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;smooth the data using a window with requested size.</span>
<span class="sd">        </span>
<span class="sd">        This method is based on the convolution of a scaled window with the signal.</span>
<span class="sd">        The signal is prepared by introducing reflected copies of the signal </span>
<span class="sd">        (with the window size) in both ends so that transient parts are minimized</span>
<span class="sd">        in the begining and end part of the output signal.</span>
<span class="sd">        </span>
<span class="sd">        input:</span>
<span class="sd">            x: the input signal </span>
<span class="sd">            window_len: the dimension of the smoothing window; should be an odd integer</span>
<span class="sd">            window: the type of window from &#39;flat&#39;, &#39;hanning&#39;, &#39;hamming&#39;, &#39;bartlett&#39;, &#39;blackman&#39;</span>
<span class="sd">                flat window will produce a moving average smoothing.</span>
<span class="sd">    </span>
<span class="sd">        output:</span>
<span class="sd">            the smoothed signal</span>
<span class="sd">    </span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1">#TODO: add comnparison</span>
        <span class="n">window_len</span> <span class="o">+=</span> <span class="p">(</span><span class="n">window_len</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">%</span><span class="mi">2</span>
        <span class="n">s</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">r_</span><span class="p">[</span><span class="s1">&#39;-1&#39;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">[:,:,</span><span class="n">window_len</span><span class="o">-</span><span class="mi">1</span><span class="p">:</span><span class="mi">0</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span><span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">[:,:,</span><span class="o">-</span><span class="mi">2</span><span class="p">:</span><span class="o">-</span><span class="n">window_len</span><span class="o">-</span><span class="mi">1</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">]]</span>
    
        <span class="k">if</span> <span class="n">window</span> <span class="o">==</span> <span class="s1">&#39;flat&#39;</span><span class="p">:</span> <span class="c1">#moving average</span>
            <span class="n">w</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">window_len</span><span class="p">,</span><span class="s1">&#39;d&#39;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">w</span><span class="o">=</span><span class="nb">eval</span><span class="p">(</span><span class="s1">&#39;np.&#39;</span><span class="o">+</span><span class="n">window</span><span class="o">+</span><span class="s1">&#39;(window_len)&#39;</span><span class="p">)</span>
        
        <span class="c1">#y=np.convolve(w/w.sum(),s,mode=&#39;valid&#39;)</span>
        <span class="n">surplus_data</span> <span class="o">=</span> <span class="nb">int</span><span class="p">((</span><span class="n">window_len</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="mf">0.5</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">keep_original</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">data_smooth</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">apply_along_axis</span><span class="p">(</span><span class="k">lambda</span> <span class="n">m</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">convolve</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="n">w</span><span class="o">/</span><span class="n">w</span><span class="o">.</span><span class="n">sum</span><span class="p">(),</span> <span class="n">mode</span><span class="o">=</span><span class="s1">&#39;valid&#39;</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">arr</span><span class="o">=</span><span class="n">s</span><span class="p">)[:,:,</span><span class="n">surplus_data</span><span class="p">:</span><span class="o">-</span><span class="n">surplus_data</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">apply_along_axis</span><span class="p">(</span><span class="k">lambda</span> <span class="n">m</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">convolve</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="n">w</span><span class="o">/</span><span class="n">w</span><span class="o">.</span><span class="n">sum</span><span class="p">(),</span> <span class="n">mode</span><span class="o">=</span><span class="s1">&#39;valid&#39;</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">arr</span><span class="o">=</span><span class="n">s</span><span class="p">)[:,:,</span><span class="n">surplus_data</span><span class="p">:</span><span class="o">-</span><span class="n">surplus_data</span><span class="p">]</span>
        
        
        <span class="k">return</span> <span class="c1">#y[(window_len-1):-(window_len)]</span></div>
    
    
<div class="viewcode-block" id="Spectral_image.deconvolute"><a class="viewcode-back" href="../modules/image_class_bs.html#image_class_bs.Spectral_image.deconvolute">[docs]</a>    <span class="k">def</span> <span class="nf">deconvolute</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">,</span> <span class="n">ZLP</span><span class="p">,</span> <span class="n">signal</span> <span class="o">=</span> <span class="s1">&#39;EELS&#39;</span><span class="p">):</span>
        
        <span class="n">y</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_pixel_signal</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">,</span> <span class="n">signal</span><span class="p">)</span>
        <span class="n">r</span> <span class="o">=</span> <span class="mi">3</span> <span class="c1">#Drude model, can also use estimation from exp. data</span>
        <span class="n">A</span> <span class="o">=</span> <span class="n">y</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">n_times_extra</span> <span class="o">=</span> <span class="mi">2</span>
        <span class="n">sem_inf</span> <span class="o">=</span> <span class="n">next_fast_len</span><span class="p">(</span><span class="n">n_times_extra</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">l</span><span class="p">)</span>
        
        
        
        <span class="n">y_extrp</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">sem_inf</span><span class="p">)</span>
        <span class="n">y_ZLP_extrp</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">sem_inf</span><span class="p">)</span>
        <span class="n">x_extrp</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">deltaE</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">l</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">ddeltaE</span><span class="p">,</span> <span class="n">sem_inf</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">ddeltaE</span><span class="o">+</span><span class="bp">self</span><span class="o">.</span><span class="n">deltaE</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">l</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">ddeltaE</span><span class="p">,</span> <span class="n">sem_inf</span><span class="p">)</span>
        
        <span class="n">x_extrp</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">deltaE</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">sem_inf</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">ddeltaE</span><span class="o">+</span><span class="bp">self</span><span class="o">.</span><span class="n">deltaE</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">sem_inf</span><span class="p">)</span>

        <span class="n">y_ZLP_extrp</span><span class="p">[:</span><span class="bp">self</span><span class="o">.</span><span class="n">l</span><span class="p">]</span> <span class="o">=</span> <span class="n">ZLP</span>        
        <span class="n">y_extrp</span><span class="p">[:</span><span class="bp">self</span><span class="o">.</span><span class="n">l</span><span class="p">]</span> <span class="o">=</span> <span class="n">y</span>
        <span class="n">x_extrp</span><span class="p">[:</span><span class="bp">self</span><span class="o">.</span><span class="n">l</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">deltaE</span><span class="p">[</span><span class="o">-</span><span class="bp">self</span><span class="o">.</span><span class="n">l</span><span class="p">:]</span>
        
        <span class="n">y_extrp</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">l</span><span class="p">:]</span> <span class="o">=</span> <span class="n">A</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">power</span><span class="p">(</span><span class="mi">1</span><span class="o">+</span><span class="n">x_extrp</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">l</span><span class="p">:]</span><span class="o">-</span><span class="n">x_extrp</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">l</span><span class="p">],</span><span class="o">-</span><span class="n">r</span><span class="p">)</span>
        
        <span class="n">x</span> <span class="o">=</span> <span class="n">x_extrp</span>
        <span class="n">y</span> <span class="o">=</span> <span class="n">y_extrp</span>
        <span class="n">y_ZLP</span> <span class="o">=</span> <span class="n">y_ZLP_extrp</span>
        
        <span class="n">z_nu</span> <span class="o">=</span> <span class="n">CFT</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">y_ZLP</span><span class="p">)</span>
        <span class="n">i_nu</span> <span class="o">=</span> <span class="n">CFT</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">)</span>
        <span class="n">abs_i_nu</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">absolute</span><span class="p">(</span><span class="n">i_nu</span><span class="p">)</span>
        <span class="n">N_ZLP</span> <span class="o">=</span> <span class="mi">1</span><span class="c1">#scipy.integrate.cumtrapz(y_ZLP, x, initial=0)[-1]#1 #arbitrary units??? np.sum(EELZLP)</span>
        
        <span class="n">s_nu</span> <span class="o">=</span> <span class="n">N_ZLP</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">i_nu</span><span class="o">/</span><span class="n">z_nu</span><span class="p">)</span>
        <span class="n">j1_nu</span> <span class="o">=</span> <span class="n">z_nu</span><span class="o">*</span><span class="n">s_nu</span><span class="o">/</span><span class="n">N_ZLP</span>
        <span class="n">S_E</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">real</span><span class="p">(</span><span class="n">iCFT</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">s_nu</span><span class="p">))</span>
        <span class="n">s_nu_nc</span> <span class="o">=</span> <span class="n">s_nu</span>
        <span class="n">s_nu_nc</span><span class="p">[</span><span class="mi">500</span><span class="p">:</span><span class="o">-</span><span class="mi">500</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">S_E_nc</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">real</span><span class="p">(</span><span class="n">iCFT</span><span class="p">(</span> <span class="n">x</span><span class="p">,</span><span class="n">s_nu_nc</span><span class="p">))</span>
        <span class="n">J1_E</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">real</span><span class="p">(</span><span class="n">iCFT</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">j1_nu</span><span class="p">))</span>
        
        <span class="k">return</span> <span class="n">J1_E</span><span class="p">[:</span><span class="bp">self</span><span class="o">.</span><span class="n">l</span><span class="p">]</span></div>
    
<div class="viewcode-block" id="Spectral_image.pool"><a class="viewcode-back" href="../modules/image_class_bs.html#image_class_bs.Spectral_image.pool">[docs]</a>    <span class="k">def</span> <span class="nf">pool</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">n_p</span><span class="p">):</span>
        <span class="c1">#TODO: add gaussian options ed??</span>
        <span class="k">if</span> <span class="n">n_p</span><span class="o">%</span><span class="mi">2</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Unable to pool with even number &quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">n_p</span><span class="p">)</span> <span class="o">+</span> <span class="s2">&quot;, continuing with n_p=&quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">n_p</span><span class="o">+</span><span class="mi">1</span><span class="p">))</span>
            <span class="n">n_p</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="n">pooled</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
        <span class="n">n_p_border</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">math</span><span class="o">.</span><span class="n">floor</span><span class="p">(</span><span class="n">n_p</span><span class="o">/</span><span class="mi">2</span><span class="p">))</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">image_shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">image_shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]):</span>
                <span class="n">min_x</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">i</span><span class="o">-</span><span class="n">n_p_border</span><span class="p">)</span>
                <span class="n">max_x</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">image_shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">+</span> <span class="n">n_p_border</span><span class="p">)</span>
                <span class="n">min_y</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">j</span><span class="o">-</span><span class="n">n_p_border</span><span class="p">)</span>
                <span class="n">max_y</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">image_shape</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">j</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">+</span> <span class="n">n_p_border</span><span class="p">)</span>
                <span class="n">pooled</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">average</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">average</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="n">min_x</span><span class="p">:</span><span class="n">max_x</span><span class="p">,</span><span class="n">min_y</span><span class="p">:</span><span class="n">max_y</span><span class="p">,:],</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">pooled</span> <span class="o">=</span> <span class="n">pooled</span></div>

    
    <span class="c1">#%%METHODS ON ZLP</span>
    <span class="c1">#CALCULATING ZLPs FROM PRETRAINDED MODELS</span>
  
  
       

    
<div class="viewcode-block" id="Spectral_image.calc_ZLPs"><a class="viewcode-back" href="../modules/image_class_bs.html#image_class_bs.Spectral_image.calc_ZLPs">[docs]</a>    <span class="k">def</span> <span class="nf">calc_ZLPs</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">,</span> <span class="n">signal</span> <span class="o">=</span> <span class="s1">&#39;EELS&#39;</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="c1">### Definition for the matching procedure</span>
        <span class="n">signal</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_pixel_signal</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">,</span> <span class="n">signal</span><span class="p">)</span>
        
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s1">&#39;ZLP_models&#39;</span><span class="p">):</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">load_ZLP_models_smefit</span><span class="p">(</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
            <span class="k">except</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">load_ZLP_models_smefit</span><span class="p">()</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s1">&#39;ZLP_models&#39;</span><span class="p">):</span>
            <span class="n">ans</span> <span class="o">=</span> <span class="nb">input</span><span class="p">(</span><span class="s2">&quot;No ZLP models found. Please specify directory or train models. </span><span class="se">\n</span><span class="s2">&quot;</span> <span class="o">+</span> 
                        <span class="s2">&quot;Do you want to define path to models [p], train models [t] or quit [q]?</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">ans</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="s2">&quot;q&quot;</span><span class="p">:</span>
                <span class="k">return</span>
            <span class="k">elif</span> <span class="n">ans</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="s2">&quot;p&quot;</span><span class="p">:</span>
                <span class="n">path_to_models</span> <span class="o">=</span> <span class="nb">input</span><span class="p">(</span><span class="s2">&quot;Please input path to models: </span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">load_ZLP_models</span><span class="p">(</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
                <span class="k">except</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">load_ZLP_models</span><span class="p">()</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s1">&#39;ZLP_models&#39;</span><span class="p">):</span>
                    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;You had your chance. Please locate your models.&quot;</span><span class="p">)</span>
                    <span class="k">return</span>
            <span class="k">elif</span> <span class="n">ans</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="s2">&quot;t&quot;</span><span class="p">:</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">train_ZLPs</span><span class="p">(</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
                <span class="k">except</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">train_ZLPs</span><span class="p">()</span>
                <span class="k">if</span> <span class="s2">&quot;path_to_models&quot;</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="p">:</span>
                    <span class="n">path_to_models</span> <span class="o">=</span> <span class="n">kwargs</span><span class="p">[</span><span class="s2">&quot;path_to_models&quot;</span><span class="p">]</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">load_ZLP_models</span><span class="p">(</span><span class="n">path_to_models</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">load_ZLP_models</span><span class="p">()</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;unvalid input, not calculating ZLPs&quot;</span><span class="p">)</span>
                <span class="k">return</span>
        
        
        <span class="n">cluster</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">clustered</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">]</span>
        
        <span class="c1">#TODO: aanpassen</span>
        <span class="k">def</span> <span class="nf">matching</span><span class="p">(</span> <span class="n">signal</span><span class="p">,</span> <span class="n">gen_i_ZLP</span><span class="p">,</span> <span class="n">dE1</span><span class="p">):</span>
            <span class="n">dE0</span> <span class="o">=</span> <span class="n">dE1</span> <span class="o">-</span> <span class="mf">0.5</span>
            <span class="n">dE2</span> <span class="o">=</span> <span class="n">dE1</span><span class="o">*</span><span class="mi">8</span>
            <span class="c1">#gen_i_ZLP = self.ZLPs_gen[ind_ZLP, :]#*np.max(signal)/np.max(self.ZLPs_gen[ind_ZLP,:]) #TODO!!!!, normalize?</span>
            <span class="n">delta</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">divide</span><span class="p">((</span><span class="n">dE1</span> <span class="o">-</span> <span class="n">dE0</span><span class="p">),</span> <span class="mi">3</span><span class="p">)</span>
            
            <span class="n">factor_NN</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">divide</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">deltaE</span><span class="p">[(</span><span class="bp">self</span><span class="o">.</span><span class="n">deltaE</span><span class="o">&lt;</span><span class="n">dE1</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">deltaE</span> <span class="o">&gt;=</span> <span class="n">dE0</span><span class="p">)]</span> <span class="o">-</span> <span class="n">dE1</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="p">,</span> <span class="n">delta</span><span class="o">**</span><span class="mi">2</span><span class="p">))</span>
            <span class="n">factor_dm</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">-</span> <span class="n">factor_NN</span>
            
            <span class="n">range_0</span> <span class="o">=</span> <span class="n">signal</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">deltaE</span> <span class="o">&lt;</span> <span class="n">dE0</span><span class="p">]</span>
            <span class="n">range_1</span> <span class="o">=</span> <span class="n">gen_i_ZLP</span><span class="p">[(</span><span class="bp">self</span><span class="o">.</span><span class="n">deltaE</span> <span class="o">&lt;</span> <span class="n">dE1</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">deltaE</span> <span class="o">&gt;=</span> <span class="n">dE0</span><span class="p">)]</span> <span class="o">*</span> <span class="n">factor_NN</span> <span class="o">+</span> <span class="n">signal</span><span class="p">[(</span><span class="bp">self</span><span class="o">.</span><span class="n">deltaE</span> <span class="o">&lt;</span> <span class="n">dE1</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">deltaE</span> <span class="o">&gt;=</span> <span class="n">dE0</span><span class="p">)]</span> <span class="o">*</span> <span class="n">factor_dm</span>
            <span class="n">range_2</span> <span class="o">=</span> <span class="n">gen_i_ZLP</span><span class="p">[(</span><span class="bp">self</span><span class="o">.</span><span class="n">deltaE</span> <span class="o">&gt;=</span> <span class="n">dE1</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">deltaE</span> <span class="o">&lt;</span> <span class="mi">3</span> <span class="o">*</span> <span class="n">dE2</span><span class="p">)]</span>
            <span class="n">range_3</span> <span class="o">=</span> <span class="n">gen_i_ZLP</span><span class="p">[(</span><span class="bp">self</span><span class="o">.</span><span class="n">deltaE</span> <span class="o">&gt;=</span> <span class="mi">3</span> <span class="o">*</span> <span class="n">dE2</span><span class="p">)]</span> <span class="o">*</span> <span class="mi">0</span>
            <span class="n">totalfile</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="n">range_0</span><span class="p">,</span> <span class="n">range_1</span><span class="p">,</span> <span class="n">range_2</span><span class="p">,</span> <span class="n">range_3</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
            <span class="c1">#TODO: now hardcoding no negative values!!!! CHECKKKK</span>
            <span class="n">totalfile</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">minimum</span><span class="p">(</span><span class="n">totalfile</span><span class="p">,</span> <span class="n">signal</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">totalfile</span>
        
        <span class="n">count</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ZLP_models</span><span class="p">)</span>
        <span class="n">ZLPs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">count</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">l</span><span class="p">))</span> <span class="c1">#np.zeros((count, len_data))</span>
        
        
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s2">&quot;scale_var_deltaE&quot;</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">scale_var_deltaE</span> <span class="o">=</span> <span class="n">find_scale_var</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">deltaE</span><span class="p">)</span>
        
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s2">&quot;scale_var_log_sum_I&quot;</span><span class="p">):</span>
            <span class="n">all_spectra</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span>
            <span class="n">all_spectra</span><span class="p">[</span><span class="n">all_spectra</span><span class="o">&lt;</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
            <span class="n">int_log_I</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">all_spectra</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">2</span><span class="p">))</span><span class="o">.</span><span class="n">flatten</span><span class="p">()</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">scale_var_log_sum_I</span> <span class="o">=</span> <span class="n">find_scale_var</span><span class="p">(</span><span class="n">int_log_I</span><span class="p">)</span>
            <span class="k">del</span> <span class="n">all_spectra</span>
        
        <span class="n">log_sum_I_pixel</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">signal</span><span class="p">))</span>
        <span class="n">predict_x_np</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">l</span><span class="p">,</span><span class="mi">2</span><span class="p">))</span>
        <span class="n">predict_x_np</span><span class="p">[:,</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">scale</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">deltaE</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">scale_var_deltaE</span><span class="p">)</span>
        <span class="n">predict_x_np</span><span class="p">[:,</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">scale</span><span class="p">(</span><span class="n">log_sum_I_pixel</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">scale_var_log_sum_I</span><span class="p">)</span>

        <span class="n">predict_x</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">from_numpy</span><span class="p">(</span><span class="n">predict_x_np</span><span class="p">)</span>
        
        <span class="n">dE1</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dE1</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="nb">int</span><span class="p">(</span><span class="n">cluster</span><span class="p">)]</span>
        <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">count</span><span class="p">):</span> 
            <span class="n">model</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ZLP_models</span><span class="p">[</span><span class="n">k</span><span class="p">]</span>
            <span class="k">with</span> <span class="n">torch</span><span class="o">.</span><span class="n">no_grad</span><span class="p">():</span>
                <span class="n">predictions</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="n">model</span><span class="p">(</span><span class="n">predict_x</span><span class="o">.</span><span class="n">float</span><span class="p">())</span><span class="o">.</span><span class="n">flatten</span><span class="p">())</span>
            <span class="n">ZLPs</span><span class="p">[</span><span class="n">k</span><span class="p">,:]</span> <span class="o">=</span> <span class="n">matching</span><span class="p">(</span><span class="n">signal</span><span class="p">,</span> <span class="n">predictions</span><span class="p">,</span> <span class="n">dE1</span><span class="p">)</span><span class="c1">#matching(energies, np.exp(mean_k), data)</span>
            
        <span class="k">return</span> <span class="n">ZLPs</span></div>
    
<div class="viewcode-block" id="Spectral_image.calc_gen_ZLPs"><a class="viewcode-back" href="../modules/image_class_bs.html#image_class_bs.Spectral_image.calc_gen_ZLPs">[docs]</a>    <span class="k">def</span> <span class="nf">calc_gen_ZLPs</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="c1">### Definition for the matching procedure</span>
        <span class="n">signal</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_pixel_signal</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">)</span>
        
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s1">&#39;ZLP_models&#39;</span><span class="p">):</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">load_ZLP_models</span><span class="p">(</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
            <span class="k">except</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">load_ZLP_models</span><span class="p">()</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s1">&#39;ZLP_models&#39;</span><span class="p">):</span>
            <span class="n">ans</span> <span class="o">=</span> <span class="nb">input</span><span class="p">(</span><span class="s2">&quot;No ZLP models found. Please specify directory or train models. </span><span class="se">\n</span><span class="s2">&quot;</span> <span class="o">+</span> 
                        <span class="s2">&quot;Do you want to define path to models [p], train models [t] or quit [q]?</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">ans</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="s2">&quot;q&quot;</span><span class="p">:</span>
                <span class="k">return</span>
            <span class="k">elif</span> <span class="n">ans</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="s2">&quot;p&quot;</span><span class="p">:</span>
                <span class="n">path_to_models</span> <span class="o">=</span> <span class="nb">input</span><span class="p">(</span><span class="s2">&quot;Please input path to models: </span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">load_ZLP_models</span><span class="p">(</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
                <span class="k">except</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">load_ZLP_models</span><span class="p">()</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s1">&#39;ZLP_models&#39;</span><span class="p">):</span>
                    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;You had your chance. Please locate your models.&quot;</span><span class="p">)</span>
                    <span class="k">return</span>
            <span class="k">elif</span> <span class="n">ans</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="s2">&quot;t&quot;</span><span class="p">:</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">train_ZLPs</span><span class="p">(</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
                <span class="k">except</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">train_ZLPs</span><span class="p">()</span>
                <span class="k">if</span> <span class="s2">&quot;path_to_models&quot;</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="p">:</span>
                    <span class="n">path_to_models</span> <span class="o">=</span> <span class="n">kwargs</span><span class="p">[</span><span class="s2">&quot;path_to_models&quot;</span><span class="p">]</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">load_ZLP_models</span><span class="p">(</span><span class="n">path_to_models</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">load_ZLP_models</span><span class="p">()</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;unvalid input, not calculating ZLPs&quot;</span><span class="p">)</span>
                <span class="k">return</span>
        
        
        
        <span class="n">count</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ZLP_models</span><span class="p">)</span>
        <span class="n">predictions</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">count</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">l</span><span class="p">))</span> <span class="c1">#np.zeros((count, len_data))</span>
        
        
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s2">&quot;scale_var_deltaE&quot;</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">scale_var_deltaE</span> <span class="o">=</span> <span class="n">find_scale_var</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">deltaE</span><span class="p">)</span>
        
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s2">&quot;scale_var_log_sum_I&quot;</span><span class="p">):</span>
            <span class="n">all_spectra</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span>
            <span class="n">all_spectra</span><span class="p">[</span><span class="n">all_spectra</span><span class="o">&lt;</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
            <span class="n">int_log_I</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">all_spectra</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">2</span><span class="p">))</span><span class="o">.</span><span class="n">flatten</span><span class="p">()</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">scale_var_log_sum_I</span> <span class="o">=</span> <span class="n">find_scale_var</span><span class="p">(</span><span class="n">int_log_I</span><span class="p">)</span>
            <span class="k">del</span> <span class="n">all_spectra</span>
        
        <span class="n">log_sum_I_pixel</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">signal</span><span class="p">))</span>
        <span class="n">predict_x_np</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">l</span><span class="p">,</span><span class="mi">2</span><span class="p">))</span>
        <span class="n">predict_x_np</span><span class="p">[:,</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">scale</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">deltaE</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">scale_var_deltaE</span><span class="p">)</span>
        <span class="n">predict_x_np</span><span class="p">[:,</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">scale</span><span class="p">(</span><span class="n">log_sum_I_pixel</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">scale_var_log_sum_I</span><span class="p">)</span>

        <span class="n">predict_x</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">from_numpy</span><span class="p">(</span><span class="n">predict_x_np</span><span class="p">)</span>
        
        <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">count</span><span class="p">):</span> 
            <span class="n">model</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ZLP_models</span><span class="p">[</span><span class="n">k</span><span class="p">]</span>
            <span class="k">with</span> <span class="n">torch</span><span class="o">.</span><span class="n">no_grad</span><span class="p">():</span>
                <span class="n">predictions</span><span class="p">[</span><span class="n">k</span><span class="p">,:]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="n">model</span><span class="p">(</span><span class="n">predict_x</span><span class="o">.</span><span class="n">float</span><span class="p">())</span><span class="o">.</span><span class="n">flatten</span><span class="p">())</span>
            
        <span class="k">return</span> <span class="n">predictions</span></div>
        
    
<div class="viewcode-block" id="Spectral_image.train_ZLPs"><a class="viewcode-back" href="../modules/image_class_bs.html#image_class_bs.Spectral_image.train_ZLPs">[docs]</a>    <span class="k">def</span> <span class="nf">train_ZLPs</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">n_clusters</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">conf_interval</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span> <span class="n">clusters</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">signal</span> <span class="o">=</span> <span class="s1">&#39;EELS&#39;</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s2">&quot;clustered&quot;</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">n_clusters</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">cluster</span><span class="p">(</span><span class="n">n_clusters</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">cluster</span><span class="p">()</span>
        <span class="k">elif</span> <span class="n">n_clusters</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_clusters</span> <span class="o">!=</span> <span class="n">n_clusters</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">cluster</span><span class="p">(</span><span class="n">n_clusters</span><span class="p">)</span>
        
        <span class="n">training_data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_cluster_spectra</span><span class="p">(</span> <span class="n">conf_interval</span> <span class="o">=</span> <span class="n">conf_interval</span><span class="p">,</span> <span class="n">clusters</span> <span class="o">=</span> <span class="n">clusters</span><span class="p">,</span> <span class="n">signal</span> <span class="o">=</span> <span class="n">signal</span><span class="p">)</span>
        <span class="c1">#self.models = </span>
        <span class="c1"># train_nn_scaled(self, training_data, **kwargs)</span>
        <span class="n">train_nn_scaled</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">training_data</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div>

<div class="viewcode-block" id="Spectral_image.load_ZLP_models"><a class="viewcode-back" href="../modules/image_class_bs.html#image_class_bs.Spectral_image.load_ZLP_models">[docs]</a>    <span class="k">def</span> <span class="nf">load_ZLP_models</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">path_to_models</span> <span class="o">=</span> <span class="s2">&quot;models&quot;</span><span class="p">,</span> <span class="n">threshold_costs</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span> <span class="n">name_in_path</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span> <span class="n">plotting</span> <span class="o">=</span> <span class="kc">False</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s2">&quot;name&quot;</span><span class="p">)</span> <span class="ow">and</span> <span class="n">name_in_path</span><span class="p">:</span>
            <span class="n">path_to_models</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="o">+</span> <span class="s2">&quot;_&quot;</span> <span class="o">+</span> <span class="n">path_to_models</span>
        
        <span class="k">if</span> <span class="ow">not</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">exists</span><span class="p">(</span><span class="n">path_to_models</span><span class="p">):</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;No path &quot;</span> <span class="o">+</span> <span class="n">path_to_models</span> <span class="o">+</span> <span class="s2">&quot; found. Please ensure spelling and that there are models trained.&quot;</span><span class="p">)</span>
            <span class="k">return</span>
        
        <span class="bp">self</span><span class="o">.</span><span class="n">ZLP_models</span> <span class="o">=</span> <span class="p">[]</span>
        
        <span class="n">model</span> <span class="o">=</span> <span class="n">MLP</span><span class="p">(</span><span class="n">num_inputs</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">num_outputs</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>

        <span class="n">costs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">loadtxt</span><span class="p">(</span><span class="n">path_to_models</span> <span class="o">+</span> <span class="s2">&quot;/costs.txt&quot;</span><span class="p">)</span>
        
        <span class="k">if</span> <span class="n">plotting</span><span class="p">:</span>
            <span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">()</span>
            <span class="n">plt</span><span class="o">.</span><span class="n">title</span><span class="p">(</span><span class="s2">&quot;chi^2 distribution of models&quot;</span><span class="p">)</span>
            <span class="n">plt</span><span class="o">.</span><span class="n">hist</span><span class="p">(</span><span class="n">costs</span><span class="p">[</span><span class="n">costs</span> <span class="o">&lt;</span> <span class="n">threshold_costs</span><span class="o">*</span><span class="mi">3</span><span class="p">],</span> <span class="n">bins</span> <span class="o">=</span> <span class="mi">20</span><span class="p">)</span>
            <span class="n">plt</span><span class="o">.</span><span class="n">xlabel</span><span class="p">(</span><span class="s2">&quot;chi^2&quot;</span><span class="p">)</span>
            <span class="n">plt</span><span class="o">.</span><span class="n">ylabel</span><span class="p">(</span><span class="s2">&quot;number of occurence&quot;</span><span class="p">)</span>
        
        <span class="n">n_working_models</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">costs</span><span class="o">&lt;</span><span class="n">threshold_costs</span><span class="p">)</span>
        
        <span class="n">k</span><span class="o">=</span><span class="mi">0</span>
        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">costs</span><span class="p">)):</span>
            <span class="k">if</span> <span class="n">costs</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">threshold_costs</span><span class="p">:</span>
                <span class="k">with</span> <span class="n">torch</span><span class="o">.</span><span class="n">no_grad</span><span class="p">():</span>
                    <span class="n">model</span><span class="o">.</span><span class="n">load_state_dict</span><span class="p">(</span><span class="n">torch</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="n">path_to_models</span> <span class="o">+</span> <span class="s2">&quot;/nn_rep&quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">j</span><span class="p">)))</span>
                    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">check_model</span><span class="p">(</span><span class="n">model</span><span class="p">):</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">ZLP_models</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="n">model</span><span class="p">))</span>
                <span class="n">k</span><span class="o">+=</span><span class="mi">1</span></div>
    
<div class="viewcode-block" id="Spectral_image.check_cost_smefit"><a class="viewcode-back" href="../modules/image_class_bs.html#image_class_bs.Spectral_image.check_cost_smefit">[docs]</a>    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">check_cost_smefit</span><span class="p">(</span><span class="n">path_to_models</span><span class="p">,</span> <span class="n">idx</span><span class="p">,</span> <span class="n">threshold</span> <span class="o">=</span> <span class="mi">1</span><span class="p">):</span>
        <span class="n">path_to_models</span> <span class="o">+=</span> <span class="p">(</span><span class="n">path_to_models</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">!=</span> <span class="s1">&#39;/&#39;</span><span class="p">)</span><span class="o">*</span><span class="s1">&#39;/&#39;</span>
        <span class="n">cost</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">loadtxt</span><span class="p">(</span><span class="n">path_to_models</span> <span class="o">+</span> <span class="s2">&quot;costs&quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">idx</span><span class="p">)</span> <span class="o">+</span> <span class="s2">&quot;.txt&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">cost</span><span class="o">&lt;</span><span class="n">threshold</span></div>
    
<div class="viewcode-block" id="Spectral_image.check_model"><a class="viewcode-back" href="../modules/image_class_bs.html#image_class_bs.Spectral_image.check_model">[docs]</a>    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">check_model</span><span class="p">(</span><span class="n">model</span><span class="p">):</span>
        <span class="n">deltaE</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mf">0.1</span><span class="p">,</span><span class="mf">0.9</span><span class="p">,</span> <span class="mi">1000</span><span class="p">)</span>
        <span class="n">predict_x_np</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">1000</span><span class="p">,</span><span class="mi">2</span><span class="p">))</span>
        <span class="n">predict_x_np</span><span class="p">[:,</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">deltaE</span>
        <span class="n">predict_x_np</span><span class="p">[:,</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.5</span>
    
        <span class="n">predict_x</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">from_numpy</span><span class="p">(</span><span class="n">predict_x_np</span><span class="p">)</span>
        <span class="k">with</span> <span class="n">torch</span><span class="o">.</span><span class="n">no_grad</span><span class="p">():</span>
            <span class="n">predictions</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="n">model</span><span class="p">(</span><span class="n">predict_x</span><span class="o">.</span><span class="n">float</span><span class="p">())</span><span class="o">.</span><span class="n">flatten</span><span class="p">()</span><span class="o">.</span><span class="n">numpy</span><span class="p">())</span>
        
        <span class="k">return</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">std</span><span class="p">(</span><span class="n">predictions</span><span class="p">)</span><span class="o">/</span><span class="n">np</span><span class="o">.</span><span class="n">average</span><span class="p">(</span><span class="n">predictions</span><span class="p">))</span> <span class="o">&gt;</span> <span class="mf">1E-3</span> <span class="c1">#very small --&gt; straight line</span></div>
    
<div class="viewcode-block" id="Spectral_image.load_ZLP_models_smefit"><a class="viewcode-back" href="../modules/image_class_bs.html#image_class_bs.Spectral_image.load_ZLP_models_smefit">[docs]</a>    <span class="k">def</span> <span class="nf">load_ZLP_models_smefit</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">path_to_models</span> <span class="o">=</span> <span class="s2">&quot;models&quot;</span><span class="p">,</span> <span class="n">threshold_costs</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span> <span class="n">name_in_path</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span> <span class="n">plotting</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span> <span class="n">idx</span> <span class="o">=</span> <span class="kc">None</span><span class="p">):</span>
        <span class="c1"># if n_rep is None and idx is None:</span>
        <span class="c1">#     print(&quot;Please spectify either the number of replicas you wish to load (n_rep)&quot;+\</span>
        <span class="c1">#           &quot; or the specific replica model you wist to load (idx) in load_ZLP_models_smefit.&quot;)</span>
        <span class="c1">#     return</span>
        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s2">&quot;name&quot;</span><span class="p">)</span> <span class="ow">and</span> <span class="n">name_in_path</span><span class="p">:</span>
            <span class="n">path_to_models</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="o">+</span> <span class="s2">&quot;_&quot;</span> <span class="o">+</span> <span class="n">path_to_models</span>
        
        <span class="k">if</span> <span class="ow">not</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">exists</span><span class="p">(</span><span class="n">path_to_models</span><span class="p">):</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;No path &quot;</span> <span class="o">+</span> <span class="n">os</span><span class="o">.</span><span class="n">getcwd</span><span class="p">()</span> <span class="o">+</span> <span class="n">path_to_models</span> <span class="o">+</span> <span class="s2">&quot; found. Please ensure spelling and that there are models trained.&quot;</span><span class="p">)</span>
            <span class="k">return</span>
        
        <span class="bp">self</span><span class="o">.</span><span class="n">ZLP_models</span> <span class="o">=</span> <span class="p">[]</span>
        
        <span class="n">path_to_models</span> <span class="o">+=</span> <span class="p">(</span><span class="n">path_to_models</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">!=</span> <span class="s1">&#39;/&#39;</span><span class="p">)</span><span class="o">*</span><span class="s1">&#39;/&#39;</span>
        <span class="n">path_dE1</span> <span class="o">=</span> <span class="s2">&quot;dE1.txt&quot;</span>
        <span class="n">model</span> <span class="o">=</span> <span class="n">MLP</span><span class="p">(</span><span class="n">num_inputs</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">num_outputs</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">dE1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">loadtxt</span><span class="p">(</span><span class="n">path_to_models</span> <span class="o">+</span> <span class="n">path_dE1</span><span class="p">)</span>
        
        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s2">&quot;clustered&quot;</span><span class="p">):</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_clusters</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dE1</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]:</span>
                <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;image clustered in &quot;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_clusters</span><span class="p">,</span> <span class="s2">&quot; clusters, but ZLP-models take &quot;</span><span class="p">,</span>  <span class="bp">self</span><span class="o">.</span><span class="n">dE1</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="s2">&quot; clusters, reclustering based on models.&quot;</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">cluster_on_cluster_values</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dE1</span><span class="p">[</span><span class="mi">0</span><span class="p">,:])</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">cluster_on_cluster_values</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dE1</span><span class="p">[</span><span class="mi">0</span><span class="p">,:])</span>
        
        
        <span class="k">if</span> <span class="n">idx</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">with</span> <span class="n">torch</span><span class="o">.</span><span class="n">no_grad</span><span class="p">():</span>
                <span class="n">model</span><span class="o">.</span><span class="n">load_state_dict</span><span class="p">(</span><span class="n">torch</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="n">path_to_models</span> <span class="o">+</span> <span class="s2">&quot;/nn_rep&quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">idx</span><span class="p">)))</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">ZLP_models</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="n">model</span><span class="p">))</span>
            <span class="k">return</span>
        
        
        <span class="n">path_costs</span> <span class="o">=</span> <span class="s2">&quot;costs&quot;</span>
        <span class="n">files_costs</span> <span class="o">=</span> <span class="p">[</span><span class="n">filename</span> <span class="k">for</span> <span class="n">filename</span> <span class="ow">in</span> <span class="n">os</span><span class="o">.</span><span class="n">listdir</span><span class="p">(</span><span class="n">path_to_models</span><span class="p">)</span> <span class="k">if</span> <span class="n">filename</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="n">path_costs</span><span class="p">)]</span>
        <span class="n">path_model_rep</span> <span class="o">=</span> <span class="s2">&quot;nn_rep&quot;</span>
        <span class="n">files_model_rep</span> <span class="o">=</span> <span class="p">[</span><span class="n">filename</span> <span class="k">for</span> <span class="n">filename</span> <span class="ow">in</span> <span class="n">os</span><span class="o">.</span><span class="n">listdir</span><span class="p">(</span><span class="n">path_to_models</span><span class="p">)</span> <span class="k">if</span> <span class="n">filename</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="n">path_model_rep</span><span class="p">)]</span>

        
        <span class="n">n_rep</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">files_costs</span><span class="p">),</span> <span class="nb">len</span><span class="p">(</span><span class="n">files_model_rep</span><span class="p">))</span>
        <span class="n">costs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">n_rep</span><span class="p">)</span>
        
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_rep</span><span class="p">):</span>
            <span class="n">file</span> <span class="o">=</span> <span class="n">files_costs</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
            <span class="n">costs</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span>  <span class="n">np</span><span class="o">.</span><span class="n">loadtxt</span><span class="p">(</span><span class="n">path_to_models</span> <span class="o">+</span> <span class="n">file</span><span class="p">)</span>
        
        <span class="bp">self</span><span class="o">.</span><span class="n">costs</span> <span class="o">=</span> <span class="n">costs</span><span class="p">[</span><span class="n">costs</span><span class="o">&lt;</span><span class="n">threshold_costs</span><span class="p">]</span>
    
        <span class="k">if</span> <span class="n">plotting</span><span class="p">:</span>
            <span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">()</span>
            <span class="n">plt</span><span class="o">.</span><span class="n">title</span><span class="p">(</span><span class="s2">&quot;chi^2 distribution of models&quot;</span><span class="p">)</span>
            <span class="n">plt</span><span class="o">.</span><span class="n">hist</span><span class="p">(</span><span class="n">costs</span><span class="p">[</span><span class="n">costs</span> <span class="o">&lt;</span> <span class="n">threshold_costs</span><span class="o">*</span><span class="mi">3</span><span class="p">],</span> <span class="n">bins</span> <span class="o">=</span> <span class="mi">20</span><span class="p">)</span>
            <span class="n">plt</span><span class="o">.</span><span class="n">xlabel</span><span class="p">(</span><span class="s2">&quot;chi^2&quot;</span><span class="p">)</span>
            <span class="n">plt</span><span class="o">.</span><span class="n">ylabel</span><span class="p">(</span><span class="s2">&quot;number of occurence&quot;</span><span class="p">)</span>   
        
        
        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">files_model_rep</span><span class="p">)):</span>
            <span class="k">if</span> <span class="n">costs</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">threshold_costs</span><span class="p">:</span>
                <span class="n">file</span> <span class="o">=</span> <span class="n">files_model_rep</span><span class="p">[</span><span class="n">j</span><span class="p">]</span>
                <span class="k">with</span> <span class="n">torch</span><span class="o">.</span><span class="n">no_grad</span><span class="p">():</span>
                    <span class="n">model</span><span class="o">.</span><span class="n">load_state_dict</span><span class="p">(</span><span class="n">torch</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="n">path_to_models</span> <span class="o">+</span> <span class="n">file</span><span class="p">))</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">check_model</span><span class="p">(</span><span class="n">model</span><span class="p">):</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">ZLP_models</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="n">model</span><span class="p">))</span></div>
                

    <span class="c1">#METHODS ON DIELECTRIC FUNCTIONS</span>
<div class="viewcode-block" id="Spectral_image.calc_thickness"><a class="viewcode-back" href="../modules/image_class_bs.html#image_class_bs.Spectral_image.calc_thickness">[docs]</a>    <span class="k">def</span> <span class="nf">calc_thickness</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">I_EELS</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">N_ZLP</span> <span class="o">=</span> <span class="mi">1</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Calculates thickness from sample data, using Egreton #TODO: bron.</span>
<span class="sd">        Nota bene: does not correct for surface scatterings. If you wish to correct \</span>
<span class="sd">        for surface scatterings, please extract t from kramer_kronig_hs()</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        I_EELS : TYPE</span>
<span class="sd">            DESCRIPTION.</span>
<span class="sd">        n : TYPE</span>
<span class="sd">            DESCRIPTION.</span>
<span class="sd">        N_ZLP: float/int</span>
<span class="sd">            default = 1. Default for already normalized I_EELS spectra.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        None.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">me</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">m_0</span>
        <span class="n">e0</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">e0</span>
        <span class="n">beta</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">beta</span>
    
        <span class="n">eaxis</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">deltaE</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">deltaE</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">]</span> <span class="c1">#axis.axis.copy()</span>
        <span class="n">y</span> <span class="o">=</span> <span class="n">I_EELS</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">deltaE</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">i0</span> <span class="o">=</span> <span class="n">N_ZLP</span>
        
        <span class="c1"># Kinetic definitions</span>
        <span class="n">ke</span> <span class="o">=</span> <span class="n">e0</span> <span class="o">*</span> <span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="n">e0</span> <span class="o">/</span> <span class="mf">2.</span> <span class="o">/</span> <span class="n">me</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="n">e0</span> <span class="o">/</span> <span class="n">me</span><span class="p">)</span> <span class="o">**</span> <span class="mi">2</span>
        <span class="n">tgt</span> <span class="o">=</span> <span class="n">e0</span> <span class="o">*</span> <span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">me</span> <span class="o">+</span> <span class="n">e0</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="n">me</span> <span class="o">+</span> <span class="n">e0</span><span class="p">)</span>    
    
        <span class="c1"># Calculation of the ELF by normalization of the SSD</span>
        <span class="c1"># We start by the &quot;angular corrections&quot;</span>
        <span class="n">Im</span> <span class="o">=</span> <span class="n">y</span> <span class="o">/</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="p">(</span><span class="n">beta</span> <span class="o">*</span> <span class="n">tgt</span> <span class="o">/</span> <span class="n">eaxis</span><span class="p">)</span> <span class="o">**</span> <span class="mi">2</span><span class="p">))</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">ddeltaE</span><span class="c1">#axis.scale</span>
        
        
        <span class="n">K</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">Im</span><span class="o">/</span><span class="n">eaxis</span><span class="p">)</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">ddeltaE</span> 
        <span class="n">K</span> <span class="o">=</span> <span class="p">(</span><span class="n">K</span> <span class="o">/</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">/</span> <span class="mi">2</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="mf">1.</span> <span class="o">/</span> <span class="n">n</span> <span class="o">**</span> <span class="mi">2</span><span class="p">))</span>
        <span class="n">te</span> <span class="o">=</span> <span class="p">(</span><span class="mf">332.5</span> <span class="o">*</span> <span class="n">K</span> <span class="o">*</span> <span class="n">ke</span> <span class="o">/</span> <span class="n">i0</span><span class="p">)</span>
        
        <span class="k">return</span> <span class="n">te</span></div>

    
    
<div class="viewcode-block" id="Spectral_image.kramers_kronig_hs"><a class="viewcode-back" href="../modules/image_class_bs.html#image_class_bs.Spectral_image.kramers_kronig_hs">[docs]</a>    <span class="k">def</span> <span class="nf">kramers_kronig_hs</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">I_EELS</span><span class="p">,</span>
                            <span class="n">N_ZLP</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                            <span class="n">iterations</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
                            <span class="n">n</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                            <span class="n">t</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                            <span class="n">delta</span><span class="o">=</span><span class="mf">0.5</span><span class="p">,</span> <span class="n">correct_S_s</span> <span class="o">=</span> <span class="kc">False</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;Calculate the complex</span>
<span class="sd">        dielectric function from a single scattering distribution (SSD) using</span>
<span class="sd">        the Kramers-Kronig relations.</span>
<span class="sd">    </span>
<span class="sd">        It uses the FFT method as in [1]_.  The SSD is an</span>
<span class="sd">        EELSSpectrum instance containing SSD low-loss EELS with no zero-loss</span>
<span class="sd">        peak. The internal loop is devised to approximately subtract the</span>
<span class="sd">        surface plasmon contribution supposing an unoxidized planar surface and</span>
<span class="sd">        neglecting coupling between the surfaces. This method does not account</span>
<span class="sd">        for retardation effects, instrumental broading and surface plasmon</span>
<span class="sd">        excitation in particles.</span>
<span class="sd">    </span>
<span class="sd">        Note that either refractive index or thickness are required.</span>
<span class="sd">        If both are None or if both are provided an exception is raised.</span>
<span class="sd">    </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        zlp: {None, number, Signal1D}</span>
<span class="sd">            ZLP intensity. It is optional (can be None) if `t` is None and `n`</span>
<span class="sd">            is not None and the thickness estimation is not required. If `t`</span>
<span class="sd">            is not None, the ZLP is required to perform the normalization and</span>
<span class="sd">            if `t` is not None, the ZLP is required to calculate the thickness.</span>
<span class="sd">            If the ZLP is the same for all spectra, the integral of the ZLP</span>
<span class="sd">            can be provided as a number. Otherwise, if the ZLP intensity is not</span>
<span class="sd">            the same for all spectra, it can be provided as i) a Signal1D</span>
<span class="sd">            of the same dimensions as the current signal containing the ZLP</span>
<span class="sd">            spectra for each location ii) a BaseSignal of signal dimension 0</span>
<span class="sd">            and navigation_dimension equal to the current signal containing the</span>
<span class="sd">            integrated ZLP intensity.</span>
<span class="sd">        iterations: int</span>
<span class="sd">            Number of the iterations for the internal loop to remove the</span>
<span class="sd">            surface plasmon contribution. If 1 the surface plasmon contribution</span>
<span class="sd">            is not estimated and subtracted (the default is 1).</span>
<span class="sd">        n: {None, float}</span>
<span class="sd">            The medium refractive index. Used for normalization of the</span>
<span class="sd">            SSD to obtain the energy loss function. If given the thickness</span>
<span class="sd">            is estimated and returned. It is only required when `t` is None.</span>
<span class="sd">        t: {None, number, Signal1D}</span>
<span class="sd">            The sample thickness in nm. Used for normalization of the</span>
<span class="sd">             to obtain the energy loss function. It is only required when</span>
<span class="sd">            `n` is None. If the thickness is the same for all spectra it can be</span>
<span class="sd">            given by a number. Otherwise, it can be provided as a BaseSignal</span>
<span class="sd">            with signal dimension 0 and navigation_dimension equal to the</span>
<span class="sd">            current signal.</span>
<span class="sd">        delta : float</span>
<span class="sd">            A small number (0.1-0.5 eV) added to the energy axis in</span>
<span class="sd">            specific steps of the calculation the surface loss correction to</span>
<span class="sd">            improve stability.</span>
<span class="sd">        full_output : bool</span>
<span class="sd">            If True, return a dictionary that contains the estimated</span>
<span class="sd">            thickness if `t` is None and the estimated surface plasmon</span>
<span class="sd">            excitation and the spectrum corrected from surface plasmon</span>
<span class="sd">            excitations if `iterations` &gt; 1.</span>
<span class="sd">    </span>
<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        eps: DielectricFunction instance</span>
<span class="sd">            The complex dielectric function results,</span>
<span class="sd">    </span>
<span class="sd">                .. math::</span>
<span class="sd">                    \epsilon = \epsilon_1 + i*\epsilon_2,</span>
<span class="sd">    </span>
<span class="sd">            contained in an DielectricFunction instance.</span>
<span class="sd">        output: Dictionary (optional)</span>
<span class="sd">            A dictionary of optional outputs with the following keys:</span>
<span class="sd">    </span>
<span class="sd">            ``thickness``</span>
<span class="sd">                The estimated  thickness in nm calculated by normalization of</span>
<span class="sd">                the SSD (only when `t` is None)</span>
<span class="sd">    </span>
<span class="sd">            ``surface plasmon estimation``</span>
<span class="sd">               The estimated surface plasmon excitation (only if</span>
<span class="sd">               `iterations` &gt; 1.)</span>
<span class="sd">    </span>
<span class="sd">        Raises</span>
<span class="sd">        ------</span>
<span class="sd">        ValuerError</span>
<span class="sd">            If both `n` and `t` are undefined (None).</span>
<span class="sd">        AttribureError</span>
<span class="sd">            If the beam_energy or the collection semi-angle are not defined in</span>
<span class="sd">            metadata.</span>
<span class="sd">    </span>
<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        This method is based in Egerton&#39;s Matlab code [1]_ with some</span>
<span class="sd">        minor differences:</span>
<span class="sd">    </span>
<span class="sd">        * The wrap-around problem when computing the ffts is workarounded by</span>
<span class="sd">          padding the signal instead of substracting the reflected tail.</span>
<span class="sd">    </span>
<span class="sd">        .. [1] Ray Egerton, &quot;Electron Energy-Loss Spectroscopy in the Electron</span>
<span class="sd">           Microscope&quot;, Springer-Verlag, 2011.</span>
<span class="sd">    </span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">output</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="c1"># Constants and units</span>
        <span class="n">me</span> <span class="o">=</span> <span class="mf">511.06</span>
    
        <span class="n">e0</span> <span class="o">=</span> <span class="mi">200</span> <span class="c1">#keV</span>
        <span class="n">beta</span> <span class="o">=</span><span class="mi">30</span> <span class="c1">#mrad</span>
        
        <span class="n">e0</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">e0</span>
        <span class="n">beta</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">beta</span>
    
        <span class="n">eaxis</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">deltaE</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">deltaE</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">]</span> <span class="c1">#axis.axis.copy()</span>
        <span class="n">S_E</span> <span class="o">=</span> <span class="n">I_EELS</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">deltaE</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">y</span> <span class="o">=</span> <span class="n">I_EELS</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">deltaE</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">l</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">eaxis</span><span class="p">)</span>
        <span class="n">i0</span> <span class="o">=</span> <span class="n">N_ZLP</span>
        
        <span class="c1"># Kinetic definitions</span>
        <span class="n">ke</span> <span class="o">=</span> <span class="n">e0</span> <span class="o">*</span> <span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="n">e0</span> <span class="o">/</span> <span class="mf">2.</span> <span class="o">/</span> <span class="n">me</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="n">e0</span> <span class="o">/</span> <span class="n">me</span><span class="p">)</span> <span class="o">**</span> <span class="mi">2</span>
        <span class="n">tgt</span> <span class="o">=</span> <span class="n">e0</span> <span class="o">*</span> <span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">me</span> <span class="o">+</span> <span class="n">e0</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="n">me</span> <span class="o">+</span> <span class="n">e0</span><span class="p">)</span>
        <span class="n">rk0</span> <span class="o">=</span> <span class="mi">2590</span> <span class="o">*</span> <span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="n">e0</span> <span class="o">/</span> <span class="n">me</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">ke</span> <span class="o">/</span> <span class="n">me</span><span class="p">)</span>
    
        <span class="k">for</span> <span class="n">io</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">iterations</span><span class="p">):</span>
            <span class="c1"># Calculation of the ELF by normalization of the SSD</span>
            <span class="c1"># We start by the &quot;angular corrections&quot;</span>
            <span class="n">Im</span> <span class="o">=</span> <span class="n">y</span> <span class="o">/</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="p">(</span><span class="n">beta</span> <span class="o">*</span> <span class="n">tgt</span> <span class="o">/</span> <span class="n">eaxis</span><span class="p">)</span> <span class="o">**</span> <span class="mi">2</span><span class="p">))</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">ddeltaE</span><span class="c1">#axis.scale</span>
            <span class="k">if</span> <span class="n">n</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">t</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;The thickness and the refractive index are &quot;</span>
                                 <span class="s2">&quot;not defined. Please provide one of them.&quot;</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">n</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">t</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Please provide the refractive index OR the &quot;</span>
                                 <span class="s2">&quot;thickness information, not both&quot;</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">n</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="c1"># normalize using the refractive index.</span>
                <span class="n">K</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">Im</span><span class="o">/</span><span class="n">eaxis</span><span class="p">)</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">ddeltaE</span> 
                <span class="n">K</span> <span class="o">=</span> <span class="p">(</span><span class="n">K</span> <span class="o">/</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">/</span> <span class="mi">2</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="mf">1.</span> <span class="o">/</span> <span class="n">n</span> <span class="o">**</span> <span class="mi">2</span><span class="p">))</span>
                <span class="n">te</span> <span class="o">=</span> <span class="p">(</span><span class="mf">332.5</span> <span class="o">*</span> <span class="n">K</span> <span class="o">*</span> <span class="n">ke</span> <span class="o">/</span> <span class="n">i0</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">t</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">N_ZLP</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;The ZLP must be provided when the  &quot;</span>
                                     <span class="s2">&quot;thickness is used for normalization.&quot;</span><span class="p">)</span>
                <span class="c1"># normalize using the thickness</span>
                <span class="n">K</span> <span class="o">=</span> <span class="n">t</span> <span class="o">*</span> <span class="n">i0</span> <span class="o">/</span> <span class="p">(</span><span class="mf">332.5</span> <span class="o">*</span> <span class="n">ke</span><span class="p">)</span>
                <span class="n">te</span> <span class="o">=</span> <span class="n">t</span>
            <span class="n">Im</span> <span class="o">=</span> <span class="n">Im</span> <span class="o">/</span> <span class="n">K</span>
    
            <span class="c1"># Kramers Kronig Transform:</span>
            <span class="c1"># We calculate KKT(Im(-1/epsilon))=1+Re(1/epsilon) with FFT</span>
            <span class="c1"># Follows: D W Johnson 1975 J. Phys. A: Math. Gen. 8 490</span>
            <span class="c1"># Use an optimal FFT size to speed up the calculation, and</span>
            <span class="c1"># make it double the closest upper value to workaround the</span>
            <span class="c1"># wrap-around problem.</span>
            <span class="n">esize</span> <span class="o">=</span> <span class="n">next_fast_len</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">l</span><span class="p">)</span> <span class="c1">#2**math.floor(math.log2(l)+1)*4</span>
            <span class="n">q</span> <span class="o">=</span> <span class="o">-</span><span class="mi">2</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">fft</span><span class="o">.</span><span class="n">fft</span><span class="p">(</span><span class="n">Im</span><span class="p">,</span> <span class="n">esize</span><span class="p">)</span><span class="o">.</span><span class="n">imag</span> <span class="o">/</span> <span class="n">esize</span>
    
            <span class="n">q</span><span class="p">[:</span><span class="n">l</span><span class="p">]</span> <span class="o">*=</span> <span class="o">-</span><span class="mi">1</span>
            <span class="n">q</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">fft</span><span class="o">.</span><span class="n">fft</span><span class="p">(</span><span class="n">q</span><span class="p">)</span>
            <span class="c1"># Final touch, we have Re(1/eps)</span>
            <span class="n">Re</span> <span class="o">=</span> <span class="n">q</span><span class="p">[:</span><span class="n">l</span><span class="p">]</span><span class="o">.</span><span class="n">real</span> <span class="o">+</span> <span class="mi">1</span>
            <span class="c1"># Egerton does this to correct the wrap-around problem, but in our</span>
            <span class="c1"># case this is not necessary because we compute the fft on an</span>
            <span class="c1"># extended and padded spectrum to avoid this problem.</span>
            <span class="c1"># Re=real(q)</span>
            <span class="c1"># Tail correction</span>
            <span class="c1"># vm=Re[axis.size-1]</span>
            <span class="c1"># Re[:(axis.size-1)]=Re[:(axis.size-1)]+1-(0.5*vm*((axis.size-1) /</span>
            <span class="c1">#  (axis.size*2-arange(0,axis.size-1)))**2)</span>
            <span class="c1"># Re[axis.size:]=1+(0.5*vm*((axis.size-1) /</span>
            <span class="c1">#  (axis.size+arange(0,axis.size)))**2)</span>
    
            <span class="c1"># Epsilon appears:</span>
            <span class="c1">#  We calculate the real and imaginary parts of the CDF</span>
            <span class="n">e1</span> <span class="o">=</span> <span class="n">Re</span> <span class="o">/</span> <span class="p">(</span><span class="n">Re</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">+</span> <span class="n">Im</span> <span class="o">**</span> <span class="mi">2</span><span class="p">)</span>
            <span class="n">e2</span> <span class="o">=</span> <span class="n">Im</span> <span class="o">/</span> <span class="p">(</span><span class="n">Re</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">+</span> <span class="n">Im</span> <span class="o">**</span> <span class="mi">2</span><span class="p">)</span>
    
            <span class="k">if</span> <span class="n">iterations</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">N_ZLP</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="c1"># Surface losses correction:</span>
                <span class="c1">#  Calculates the surface ELF from a vaccumm border effect</span>
                <span class="c1">#  A simulated surface plasmon is subtracted from the ELF</span>
                <span class="n">Srfelf</span> <span class="o">=</span> <span class="mi">4</span> <span class="o">*</span> <span class="n">e2</span> <span class="o">/</span> <span class="p">((</span><span class="n">e1</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">+</span> <span class="n">e2</span> <span class="o">**</span> <span class="mi">2</span><span class="p">)</span> <span class="o">-</span> <span class="n">Im</span>
                <span class="n">adep</span> <span class="o">=</span> <span class="p">(</span><span class="n">tgt</span> <span class="o">/</span> <span class="p">(</span><span class="n">eaxis</span> <span class="o">+</span> <span class="n">delta</span><span class="p">)</span> <span class="o">*</span>
                        <span class="n">np</span><span class="o">.</span><span class="n">arctan</span><span class="p">(</span><span class="n">beta</span> <span class="o">*</span> <span class="n">tgt</span> <span class="o">/</span> <span class="n">eaxis</span><span class="p">)</span> <span class="o">-</span>
                        <span class="n">beta</span> <span class="o">/</span> <span class="mf">1000.</span> <span class="o">/</span>
                        <span class="p">(</span><span class="n">beta</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">+</span> <span class="n">eaxis</span> <span class="o">**</span> <span class="mf">2.</span> <span class="o">/</span> <span class="n">tgt</span> <span class="o">**</span> <span class="mi">2</span><span class="p">))</span>
                <span class="n">Srfint</span> <span class="o">=</span> <span class="mi">2000</span> <span class="o">*</span> <span class="n">K</span> <span class="o">*</span> <span class="n">adep</span> <span class="o">*</span> <span class="n">Srfelf</span> <span class="o">/</span> <span class="n">rk0</span> <span class="o">/</span> <span class="n">te</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">ddeltaE</span> <span class="c1">#axis.scale</span>
                <span class="k">if</span> <span class="n">correct_S_s</span> <span class="o">==</span> <span class="kc">True</span><span class="p">:</span>
                    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;correcting S_s&quot;</span><span class="p">)</span>
                    <span class="n">Srfint</span><span class="p">[</span><span class="n">Srfint</span><span class="o">&lt;</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
                    <span class="n">Srfint</span><span class="p">[</span><span class="n">Srfint</span><span class="o">&gt;</span><span class="n">S_E</span><span class="p">]</span> <span class="o">=</span> <span class="n">S_E</span><span class="p">[</span><span class="n">Srfint</span><span class="o">&gt;</span><span class="n">S_E</span><span class="p">]</span>
                <span class="n">y</span> <span class="o">=</span> <span class="n">S_E</span> <span class="o">-</span> <span class="n">Srfint</span>
                <span class="n">_logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s1">&#39;Iteration number: </span><span class="si">%d</span><span class="s1"> / </span><span class="si">%d</span><span class="s1">&#39;</span><span class="p">,</span> <span class="n">io</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">iterations</span><span class="p">)</span>
                
    
        <span class="n">eps</span> <span class="o">=</span> <span class="p">(</span><span class="n">e1</span> <span class="o">+</span> <span class="n">e2</span> <span class="o">*</span> <span class="mi">1</span><span class="n">j</span><span class="p">)</span>
        <span class="k">del</span> <span class="n">y</span>
        <span class="k">del</span> <span class="n">I_EELS</span>
        <span class="k">if</span> <span class="s1">&#39;thickness&#39;</span> <span class="ow">in</span> <span class="n">output</span><span class="p">:</span>
            <span class="c1"># As above,prevent errors if the signal is a single spectrum</span>
            <span class="n">output</span><span class="p">[</span><span class="s1">&#39;thickness&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">te</span>
        
        <span class="k">return</span> <span class="n">eps</span><span class="p">,</span> <span class="n">te</span><span class="p">,</span> <span class="n">Srfint</span></div>


<div class="viewcode-block" id="Spectral_image.KK_pixel"><a class="viewcode-back" href="../modules/image_class_bs.html#image_class_bs.Spectral_image.KK_pixel">[docs]</a>    <span class="k">def</span> <span class="nf">KK_pixel</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="n">signal</span> <span class="o">=</span> <span class="s1">&#39;EELS&#39;</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        </span>
<span class="sd">        Option to include pooling, not for thickness, as this is an integral and therefor \</span>
<span class="sd">        more noise robust by default.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        i : TYPE</span>
<span class="sd">            DESCRIPTION.</span>
<span class="sd">        j : TYPE</span>
<span class="sd">            DESCRIPTION.</span>
<span class="sd">        pooled : TYPE, optional</span>
<span class="sd">            DESCRIPTION. The default is False.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        dielectric_functions : TYPE</span>
<span class="sd">            DESCRIPTION.</span>
<span class="sd">        ts : TYPE</span>
<span class="sd">            DESCRIPTION.</span>
<span class="sd">        S_ss : TYPE</span>
<span class="sd">            DESCRIPTION.</span>
<span class="sd">        IEELSs : TYPE</span>
<span class="sd">            DESCRIPTION.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1">#data_ij = self.get_pixel_signal(i,j)#[self.deltaE&gt;0]</span>
        <span class="n">ZLPs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">calc_ZLPs</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">)</span><span class="c1">#[:,self.deltaE&gt;0]</span>
        <span class="k">if</span> <span class="n">signal</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">EELS_NAMES</span><span class="p">:</span> 
            <span class="n">ZLPs_signal</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">calc_ZLPs</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">,</span> <span class="n">signal</span> <span class="o">=</span> <span class="n">signal</span><span class="p">)</span>
            <span class="n">ts_OG</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">ZLPs</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>  
            <span class="n">IEELSs_OG</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">ZLPs</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>  
            <span class="n">max_OG</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">ZLPs</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> 
        <span class="n">dielectric_functions</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="o">+</span><span class="mi">1</span><span class="n">j</span><span class="p">)</span><span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">ZLPs</span><span class="p">[:,</span><span class="bp">self</span><span class="o">.</span><span class="n">deltaE</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
        <span class="n">S_ss</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">ZLPs</span><span class="p">[:,</span><span class="bp">self</span><span class="o">.</span><span class="n">deltaE</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
        <span class="n">ts</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">ZLPs</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>            
        <span class="n">IEELSs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">ZLPs</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
        <span class="n">max_ieels</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">ZLPs</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> 
        <span class="n">n</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">n</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">clustered</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">]]</span>
        <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">ZLPs</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
            <span class="n">ZLP_k</span> <span class="o">=</span> <span class="n">ZLPs</span><span class="p">[</span><span class="n">k</span><span class="p">,:]</span>
            <span class="n">N_ZLP</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">ZLP_k</span><span class="p">)</span>
            <span class="n">IEELS</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">deconvolute</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="n">ZLP_k</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">signal</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">EELS_NAMES</span><span class="p">:</span>
                <span class="n">IEELSs_OG</span><span class="p">[</span><span class="n">k</span><span class="p">,:]</span> <span class="o">=</span> <span class="n">IEELS</span>
                <span class="n">ts_OG</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">calc_thickness</span><span class="p">(</span><span class="n">IEELS</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">N_ZLP</span><span class="p">)</span>
                <span class="n">max_OG</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">deltaE</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">argmax</span><span class="p">(</span><span class="n">IEELS</span><span class="p">)]</span>
                <span class="n">ZLP_k</span> <span class="o">=</span> <span class="n">ZLPs_signal</span><span class="p">[</span><span class="n">k</span><span class="p">,:]</span>
                <span class="n">N_ZLP</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">ZLP_k</span><span class="p">)</span>
                <span class="n">IEELS</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">deconvolute</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="n">ZLP_k</span><span class="p">,</span> <span class="n">signal</span> <span class="o">=</span> <span class="n">signal</span><span class="p">)</span>
            <span class="n">IEELSs</span><span class="p">[</span><span class="n">k</span><span class="p">,:]</span> <span class="o">=</span> <span class="n">IEELS</span>
            <span class="n">max_ieels</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">deltaE</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">argmax</span><span class="p">(</span><span class="n">IEELS</span><span class="p">)]</span>
            <span class="n">dielectric_functions</span><span class="p">[</span><span class="n">k</span><span class="p">,:],</span> <span class="n">ts</span><span class="p">[</span><span class="n">k</span><span class="p">],</span> <span class="n">S_ss</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">kramers_kronig_hs</span><span class="p">(</span><span class="n">IEELS</span><span class="p">,</span> <span class="n">N_ZLP</span> <span class="o">=</span> <span class="n">N_ZLP</span><span class="p">,</span> <span class="n">n</span> <span class="o">=</span> <span class="n">n</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">signal</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">EELS_NAMES</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">[</span><span class="n">ts_OG</span><span class="p">,</span> <span class="n">IEELSs_OG</span><span class="p">,</span> <span class="n">max_OG</span><span class="p">],</span> <span class="p">[</span><span class="n">dielectric_functions</span><span class="p">,</span> <span class="n">ts</span><span class="p">,</span> <span class="n">S_ss</span><span class="p">,</span> <span class="n">IEELSs</span><span class="p">,</span> <span class="n">max_ieels</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">dielectric_functions</span><span class="p">,</span> <span class="n">ts</span><span class="p">,</span> <span class="n">S_ss</span><span class="p">,</span> <span class="n">IEELSs</span></div>


<div class="viewcode-block" id="Spectral_image.im_dielectric_function_bs"><a class="viewcode-back" href="../modules/image_class_bs.html#image_class_bs.Spectral_image.im_dielectric_function_bs">[docs]</a>    <span class="k">def</span> <span class="nf">im_dielectric_function_bs</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">track_process</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span> <span class="n">plot</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span> <span class="n">save_index</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">save_path</span> <span class="o">=</span> <span class="s2">&quot;KK_analysis&quot;</span><span class="p">,</span> <span class="n">smooth</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        INPUT:</span>
<span class="sd">            self -- the image of which the dielectic functions are calculated</span>
<span class="sd">            track_process -- boolean, default = False, if True: prints for each pixel that program is busy with that pixel.</span>
<span class="sd">            plot -- boolean, default = False, if True, plots all calculated dielectric functions</span>
<span class="sd">        OUTPUT ATRIBUTES:</span>
<span class="sd">            self.dielectric_function_im_avg = average dielectric function for each pixel</span>
<span class="sd">            self.dielectric_function_im_std = standard deviation of the dielectric function at each energy for each pixel</span>
<span class="sd">            self.S_s_avg = average surface scattering distribution for each pixel</span>
<span class="sd">            self.S_s_std = standard deviation of the surface scattering distribution at each energy for each pixel</span>
<span class="sd">            self.thickness_avg = average thickness for each pixel</span>
<span class="sd">            self.thickness_std = standard deviation thickness for each pixel</span>
<span class="sd">            self.IEELS_avg = average bulk scattering distribution for each pixel</span>
<span class="sd">            self.IEELS_std = standard deviation of the bulk scattering distribution at each energy for each pixel</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1">#TODO</span>
        <span class="c1">#data = self.data[self.deltaE&gt;0, :,:]</span>
        <span class="c1">#energies = self.deltaE[self.deltaE&gt;0]</span>
        <span class="c1">#TODO: make check for models</span>
        <span class="c1"># if not hasattr(self, &#39;ZLPs_gen&#39;):</span>
        <span class="c1">#     self.calc_ZLPs_gen2(&quot;iets&quot;)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">dielectric_function_im_avg</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="o">+</span><span class="mi">1</span><span class="n">j</span><span class="p">)</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">[</span> <span class="p">:,:,</span><span class="bp">self</span><span class="o">.</span><span class="n">deltaE</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">dielectric_function_im_std</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="o">+</span><span class="mi">1</span><span class="n">j</span><span class="p">)</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">[</span> <span class="p">:,:,</span><span class="bp">self</span><span class="o">.</span><span class="n">deltaE</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">S_s_avg</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="o">+</span><span class="mi">1</span><span class="n">j</span><span class="p">)</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">[</span> <span class="p">:,:,</span><span class="bp">self</span><span class="o">.</span><span class="n">deltaE</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">S_s_std</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="o">+</span><span class="mi">1</span><span class="n">j</span><span class="p">)</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">[</span> <span class="p">:,:,</span><span class="bp">self</span><span class="o">.</span><span class="n">deltaE</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">thickness_avg</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">image_shape</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">thickness_std</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">image_shape</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">IEELS_avg</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">IEELS_std</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
        <span class="n">N_ZLPs_calculated</span> <span class="o">=</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s1">&#39;N_ZLPs&#39;</span><span class="p">)</span>
        <span class="c1">#TODO: add N_ZLP saving</span>
        <span class="c1">#if not N_ZLPs_calculated:</span>
        <span class="c1">#    self.N_ZLPs = np.zeros(self.image_shape)</span>
        <span class="k">if</span> <span class="n">plot</span><span class="p">:</span>
            <span class="n">fig1</span><span class="p">,</span> <span class="n">ax1</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">()</span>
            <span class="n">fig2</span><span class="p">,</span> <span class="n">ax2</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">image_shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">image_shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]):</span>
                <span class="k">if</span> <span class="n">track_process</span><span class="p">:</span> <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;calculating dielectric function for pixel &quot;</span> <span class="p">,</span> <span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">)</span>
                <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">                data_ij = self.get_pixel_signal(i,j)#[self.deltaE&gt;0]</span>
<span class="sd">                ZLPs = self.calc_ZLPs(i,j)#[:,self.deltaE&gt;0]</span>
<span class="sd">                dielectric_functions = (1+1j)* np.zeros(ZLPs[:,self.deltaE&gt;0].shape)</span>
<span class="sd">                S_ss = np.zeros(ZLPs[:,self.deltaE&gt;0].shape)</span>
<span class="sd">                ts = np.zeros(ZLPs.shape[0])            </span>
<span class="sd">                IEELSs = np.zeros(ZLPs.shape)</span>
<span class="sd">                for k in range(ZLPs.shape[0]):</span>
<span class="sd">                    ZLP_k = ZLPs[k,:]</span>
<span class="sd">                    N_ZLP = np.sum(ZLP_k)</span>
<span class="sd">                    IEELS = data_ij-ZLP_k</span>
<span class="sd">                    if smooth:</span>
<span class="sd">                        IEELS = smooth_1D(IEELS)</span>
<span class="sd">                    IEELS = self.deconvolute(i, j, ZLP_k)</span>
<span class="sd">                    IEELSs[k,:] = IEELS</span>
<span class="sd">                    if plot: </span>
<span class="sd">                        #ax1.plot(self.deltaE, IEELS)</span>
<span class="sd">                        plt.figure()</span>
<span class="sd">                        plt.plot(self.deltaE, IEELS)</span>
<span class="sd">                    #TODO: FIX ZLP: now becomes very negative!!!!!!!</span>
<span class="sd">                    #TODO: VERY IMPORTANT</span>
<span class="sd">                    dielectric_functions[k,:], ts[k], S_ss[k] = self.kramers_kronig_hs(IEELS, N_ZLP = N_ZLP, n =3)</span>
<span class="sd">                    if plot: </span>
<span class="sd">                        #plt.figure()</span>
<span class="sd">                        plt.plot(self.deltaE[self.deltaE&gt;0], dielectric_functions[k,:]*2)</span>
<span class="sd">                        plt.xlim(0,10)</span>
<span class="sd">                        plt.ylim(-100, 400)</span>
<span class="sd">                    &quot;&quot;&quot;</span>
                <span class="n">dielectric_functions</span><span class="p">,</span> <span class="n">ts</span><span class="p">,</span> <span class="n">S_ss</span><span class="p">,</span> <span class="n">IEELSs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">KK_pixel</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">)</span>
                <span class="c1">#print(ts)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">dielectric_function_im_avg</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">,:]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">average</span><span class="p">(</span><span class="n">dielectric_functions</span><span class="p">,</span> <span class="n">axis</span> <span class="o">=</span> <span class="mi">0</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">dielectric_function_im_std</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">,:]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">std</span><span class="p">(</span><span class="n">dielectric_functions</span><span class="p">,</span> <span class="n">axis</span> <span class="o">=</span> <span class="mi">0</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">S_s_avg</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">,:]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">average</span><span class="p">(</span><span class="n">S_ss</span><span class="p">,</span> <span class="n">axis</span> <span class="o">=</span> <span class="mi">0</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">S_s_std</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">,:]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">std</span><span class="p">(</span><span class="n">S_ss</span><span class="p">,</span> <span class="n">axis</span> <span class="o">=</span> <span class="mi">0</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">thickness_avg</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">average</span><span class="p">(</span><span class="n">ts</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">thickness_std</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">std</span><span class="p">(</span><span class="n">ts</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">IEELS_avg</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">,:]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">average</span><span class="p">(</span><span class="n">IEELSs</span><span class="p">,</span> <span class="n">axis</span> <span class="o">=</span> <span class="mi">0</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">IEELS_std</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">,:]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">std</span><span class="p">(</span><span class="n">IEELSs</span><span class="p">,</span> <span class="n">axis</span> <span class="o">=</span> <span class="mi">0</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">save_index</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">save_path</span> <span class="o">+=</span> <span class="p">(</span><span class="ow">not</span> <span class="n">save_path</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;/&#39;</span><span class="p">)</span><span class="o">*</span><span class="s1">&#39;/&#39;</span>
            <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">save_path</span> <span class="o">+</span> <span class="s2">&quot;diel_fun_&quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">save_index</span><span class="p">)</span> <span class="o">+</span> <span class="s2">&quot;.npy&quot;</span><span class="p">,</span> <span class="s1">&#39;wb&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
                <span class="n">np</span><span class="o">.</span><span class="n">save</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">dielectric_function_im_avg</span><span class="p">)</span>
            <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">save_path</span> <span class="o">+</span> <span class="s2">&quot;S_s_&quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">save_index</span><span class="p">)</span> <span class="o">+</span> <span class="s2">&quot;.npy&quot;</span><span class="p">,</span> <span class="s1">&#39;wb&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
                <span class="n">np</span><span class="o">.</span><span class="n">save</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">S_s_avg</span><span class="p">)</span>
            <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">save_path</span> <span class="o">+</span> <span class="s2">&quot;thickness_&quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">save_index</span><span class="p">)</span> <span class="o">+</span> <span class="s2">&quot;.npy&quot;</span><span class="p">,</span> <span class="s1">&#39;wb&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
                <span class="n">np</span><span class="o">.</span><span class="n">save</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">thickness_avg</span><span class="p">)</span></div>
        <span class="c1">#return dielectric_function_im_avg, dielectric_function_im_std</span>

    
<div class="viewcode-block" id="Spectral_image.im_dielectric_function"><a class="viewcode-back" href="../modules/image_class_bs.html#image_class_bs.Spectral_image.im_dielectric_function">[docs]</a>    <span class="k">def</span> <span class="nf">im_dielectric_function</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">track_process</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span> <span class="n">plot</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span> <span class="n">save_index</span> <span class="o">=</span> <span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        INPUT:</span>
<span class="sd">            self -- the image of which the dielectic functions are calculated</span>
<span class="sd">            track_process -- boolean, default = False, if True: prints for each pixel that program is busy with that pixel.</span>
<span class="sd">            plot -- boolean, default = False, if True, plots all calculated dielectric functions</span>
<span class="sd">        OUTPUT ATRIBUTES:</span>
<span class="sd">            self.dielectric_function_im_avg = average dielectric function for each pixel</span>
<span class="sd">            self.dielectric_function_im_std = standard deviation of the dielectric function at each energy for each pixel</span>
<span class="sd">            self.S_s_avg = average surface scattering distribution for each pixel</span>
<span class="sd">            self.S_s_std = standard deviation of the surface scattering distribution at each energy for each pixel</span>
<span class="sd">            self.thickness_avg = average thickness for each pixel</span>
<span class="sd">            self.thickness_std = standard deviation thickness for each pixel</span>
<span class="sd">            self.IEELS_avg = average bulk scattering distribution for each pixel</span>
<span class="sd">            self.IEELS_std = standard deviation of the bulk scattering distribution at each energy for each pixel</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1">#TODO</span>
        <span class="c1">#data = self.data[self.deltaE&gt;0, :,:]</span>
        <span class="c1">#energies = self.deltaE[self.deltaE&gt;0]</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s1">&#39;ZLPs_gen&#39;</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">calc_ZLPs_gen2</span><span class="p">(</span><span class="s2">&quot;iets&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">dielectric_function_im_avg</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="o">+</span><span class="mi">1</span><span class="n">j</span><span class="p">)</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">[</span> <span class="p">:,:,</span><span class="bp">self</span><span class="o">.</span><span class="n">deltaE</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">dielectric_function_im_std</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="o">+</span><span class="mi">1</span><span class="n">j</span><span class="p">)</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">[</span> <span class="p">:,:,</span><span class="bp">self</span><span class="o">.</span><span class="n">deltaE</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">S_s_avg</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="o">+</span><span class="mi">1</span><span class="n">j</span><span class="p">)</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">[</span> <span class="p">:,:,</span><span class="bp">self</span><span class="o">.</span><span class="n">deltaE</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">S_s_std</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="o">+</span><span class="mi">1</span><span class="n">j</span><span class="p">)</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">[</span> <span class="p">:,:,</span><span class="bp">self</span><span class="o">.</span><span class="n">deltaE</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">thickness_avg</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">image_shape</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">thickness_std</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">image_shape</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">IEELS_avg</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">IEELS_std</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
        <span class="n">N_ZLPs_calculated</span> <span class="o">=</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s1">&#39;N_ZLPs&#39;</span><span class="p">)</span>
        <span class="c1">#TODO: add N_ZLP saving</span>
        <span class="c1">#if not N_ZLPs_calculated:</span>
        <span class="c1">#    self.N_ZLPs = np.zeros(self.image_shape)</span>
        <span class="k">if</span> <span class="n">plot</span><span class="p">:</span>
            <span class="n">fig1</span><span class="p">,</span> <span class="n">ax1</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">()</span>
            <span class="n">fig2</span><span class="p">,</span> <span class="n">ax2</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">image_shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">image_shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]):</span>
                <span class="k">if</span> <span class="n">track_process</span><span class="p">:</span> <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;calculating dielectric function for pixel &quot;</span> <span class="p">,</span> <span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">)</span>
                <span class="n">data_ij</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_pixel_signal</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">)</span><span class="c1">#[self.deltaE&gt;0]</span>
                <span class="n">ZLPs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">calc_ZLPs</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">)</span><span class="c1">#[:,self.deltaE&gt;0]</span>
                <span class="n">dielectric_functions</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="o">+</span><span class="mi">1</span><span class="n">j</span><span class="p">)</span><span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">ZLPs</span><span class="p">[:,</span><span class="bp">self</span><span class="o">.</span><span class="n">deltaE</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
                <span class="n">S_ss</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">ZLPs</span><span class="p">[:,</span><span class="bp">self</span><span class="o">.</span><span class="n">deltaE</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
                <span class="n">ts</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">ZLPs</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>            
                <span class="n">IEELSs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">ZLPs</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">23</span><span class="p">,</span><span class="mi">28</span><span class="p">):</span><span class="c1">#ZLPs.shape[0]):</span>
                    <span class="n">ZLP_k</span> <span class="o">=</span> <span class="n">ZLPs</span><span class="p">[</span><span class="n">k</span><span class="p">,:]</span>
                    <span class="n">N_ZLP</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">ZLP_k</span><span class="p">)</span>
                    <span class="n">IEELS</span> <span class="o">=</span> <span class="n">data_ij</span><span class="o">-</span><span class="n">ZLP_k</span>
                    <span class="n">IEELS</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">deconvolute</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="n">ZLP_k</span><span class="p">)</span>
                    <span class="n">IEELSs</span><span class="p">[</span><span class="n">k</span><span class="p">,:]</span> <span class="o">=</span> <span class="n">IEELS</span>
                    <span class="k">if</span> <span class="n">plot</span><span class="p">:</span> 
                        <span class="c1">#ax1.plot(self.deltaE, IEELS)</span>
                        <span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">()</span>
                        <span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">deltaE</span><span class="p">,</span> <span class="n">IEELS</span><span class="p">)</span>
                    <span class="c1">#TODO: FIX ZLP: now becomes very negative!!!!!!!</span>
                    <span class="c1">#TODO: VERY IMPORTANT</span>
                    <span class="n">dielectric_functions</span><span class="p">[</span><span class="n">k</span><span class="p">,:],</span> <span class="n">ts</span><span class="p">[</span><span class="n">k</span><span class="p">],</span> <span class="n">S_ss</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">kramers_kronig_hs</span><span class="p">(</span><span class="n">IEELS</span><span class="p">,</span> <span class="n">N_ZLP</span> <span class="o">=</span> <span class="n">N_ZLP</span><span class="p">,</span> <span class="n">n</span> <span class="o">=</span><span class="mi">3</span><span class="p">)</span>
                    <span class="k">if</span> <span class="n">plot</span><span class="p">:</span> 
                        <span class="c1">#plt.figure()</span>
                        <span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">deltaE</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">deltaE</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">],</span> <span class="n">dielectric_functions</span><span class="p">[</span><span class="n">k</span><span class="p">,:]</span><span class="o">*</span><span class="mi">2</span><span class="p">)</span>
                        <span class="n">plt</span><span class="o">.</span><span class="n">xlim</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">10</span><span class="p">)</span>
                        <span class="n">plt</span><span class="o">.</span><span class="n">ylim</span><span class="p">(</span><span class="o">-</span><span class="mi">100</span><span class="p">,</span> <span class="mi">400</span><span class="p">)</span>
                
                <span class="c1">#print(ts)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">dielectric_function_im_avg</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">,:]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">average</span><span class="p">(</span><span class="n">dielectric_functions</span><span class="p">,</span> <span class="n">axis</span> <span class="o">=</span> <span class="mi">0</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">dielectric_function_im_std</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">,:]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">std</span><span class="p">(</span><span class="n">dielectric_functions</span><span class="p">,</span> <span class="n">axis</span> <span class="o">=</span> <span class="mi">0</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">S_s_avg</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">,:]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">average</span><span class="p">(</span><span class="n">S_ss</span><span class="p">,</span> <span class="n">axis</span> <span class="o">=</span> <span class="mi">0</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">S_s_std</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">,:]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">std</span><span class="p">(</span><span class="n">S_ss</span><span class="p">,</span> <span class="n">axis</span> <span class="o">=</span> <span class="mi">0</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">thickness_avg</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">average</span><span class="p">(</span><span class="n">ts</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">thickness_std</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">std</span><span class="p">(</span><span class="n">ts</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">IEELS_avg</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">,:]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">average</span><span class="p">(</span><span class="n">IEELSs</span><span class="p">,</span> <span class="n">axis</span> <span class="o">=</span> <span class="mi">0</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">IEELS_std</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">,:]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">std</span><span class="p">(</span><span class="n">IEELSs</span><span class="p">,</span> <span class="n">axis</span> <span class="o">=</span> <span class="mi">0</span><span class="p">)</span></div>
        <span class="c1">#return dielectric_function_im_avg, dielectric_function_im_std</span>
    
<div class="viewcode-block" id="Spectral_image.crossings_im"><a class="viewcode-back" href="../modules/image_class_bs.html#image_class_bs.Spectral_image.crossings_im">[docs]</a>    <span class="k">def</span> <span class="nf">crossings_im</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span><span class="c1">#,  delta = 50):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        INPUT: </span>
<span class="sd">            self</span>
<span class="sd">        OUTPUT:</span>
<span class="sd">            self.crossings_E = numpy array (image-shape, N_c), where N_c the maximimun number of crossings of any pixel, 0 indicates no crossing</span>
<span class="sd">            self.crossings_n = numpy array (image-shape), number of crossings per pixel</span>
<span class="sd">        Calculates for each pixel the crossings of the real part of the dielectric function \</span>
<span class="sd">            from negative to positive.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">crossings_E</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">image_shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">image_shape</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span><span class="mi">1</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">crossings_n</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">image_shape</span><span class="p">)</span>
        <span class="n">n_max</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">image_shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
            <span class="c1">#print(&quot;cross&quot;, i)</span>
            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">image_shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]):</span> 
                <span class="c1">#print(&quot;cross&quot;, i, j)</span>
                <span class="n">crossings_E_ij</span><span class="p">,</span> <span class="n">n</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">crossings</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">)</span><span class="c1">#, delta)</span>
                <span class="k">if</span> <span class="n">n</span> <span class="o">&gt;</span> <span class="n">n_max</span><span class="p">:</span>
                    <span class="c1">#print(&quot;cross&quot;, i, j, n, n_max, crossings_E.shape)</span>
                    <span class="n">crossings_E_new</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">image_shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">image_shape</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span><span class="n">n</span><span class="p">))</span>
                    <span class="c1">#print(&quot;cross&quot;, i, j, n, n_max, crossings_E.shape, crossings_E_new[:,:,:n_max].shape)</span>
                    <span class="n">crossings_E_new</span><span class="p">[:,:,:</span><span class="n">n_max</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">crossings_E</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">crossings_E</span> <span class="o">=</span> <span class="n">crossings_E_new</span>
                    <span class="n">n_max</span> <span class="o">=</span> <span class="n">n</span>
                    <span class="k">del</span> <span class="n">crossings_E_new</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">crossings_E</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">,:</span><span class="n">n</span><span class="p">]</span> <span class="o">=</span> <span class="n">crossings_E_ij</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">crossings_n</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">n</span></div>
    
<div class="viewcode-block" id="Spectral_image.crossings"><a class="viewcode-back" href="../modules/image_class_bs.html#image_class_bs.Spectral_image.crossings">[docs]</a>    <span class="k">def</span> <span class="nf">crossings</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">):</span><span class="c1">#, delta = 50):</span>
        <span class="c1">#l = len(die_fun)</span>
        <span class="n">die_fun_avg</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">real</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dielectric_function_im_avg</span><span class="p">[</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="p">:])</span>
        <span class="c1">#die_fun_f = np.zeros(l-2*delta)</span>
        <span class="c1">#TODO: use smooth?</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        for i in range(self.l-delta):</span>
<span class="sd">            die_fun_avg[i] = np.average(self.dielectric_function_im_avg[i:i+delta])</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">crossing</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">0</span><span class="p">]),(</span><span class="n">die_fun_avg</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">&lt;</span><span class="mi">0</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">die_fun_avg</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span> <span class="o">&gt;=</span><span class="mi">0</span><span class="p">)))</span>
        <span class="n">deltaE_n</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">deltaE</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">deltaE</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">]</span>
        <span class="c1">#deltaE_n = deltaE_n[50:-50]</span>
        <span class="n">crossing_E</span> <span class="o">=</span> <span class="n">deltaE_n</span><span class="p">[</span><span class="n">crossing</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s1">&#39;bool&#39;</span><span class="p">)]</span>
        <span class="n">n</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">crossing_E</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">crossing_E</span><span class="p">,</span> <span class="n">n</span></div>
    
<div class="viewcode-block" id="Spectral_image.crossings_ieels"><a class="viewcode-back" href="../modules/image_class_bs.html#image_class_bs.Spectral_image.crossings_ieels">[docs]</a>    <span class="k">def</span> <span class="nf">crossings_ieels</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ieels</span><span class="p">,</span> <span class="n">smooth</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span> <span class="n">window_len</span> <span class="o">=</span> <span class="mi">50</span><span class="p">):</span><span class="c1">#, delta = 50):</span>
        <span class="c1">#l = len(die_fun)</span>
        <span class="n">die_fun_avg</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">real</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dielectric_function_im_avg</span><span class="p">[</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="p">:])</span>
        <span class="c1">#die_fun_f = np.zeros(l-2*delta)</span>
        <span class="c1">#TODO: use smooth?</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        for i in range(self.l-delta):</span>
<span class="sd">            die_fun_avg[i] = np.average(self.dielectric_function_im_avg[i:i+delta])</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">crossing</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">0</span><span class="p">]),(</span><span class="n">die_fun_avg</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">&lt;</span><span class="mi">0</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">die_fun_avg</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span> <span class="o">&gt;=</span><span class="mi">0</span><span class="p">)))</span>
        <span class="n">deltaE_n</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">deltaE</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">deltaE</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">]</span>
        <span class="c1">#deltaE_n = deltaE_n[50:-50]</span>
        <span class="n">crossing_E</span> <span class="o">=</span> <span class="n">deltaE_n</span><span class="p">[</span><span class="n">crossing</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s1">&#39;bool&#39;</span><span class="p">)]</span>
        <span class="n">n</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">crossing_E</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">crossing_E</span><span class="p">,</span> <span class="n">n</span></div>
    
    <span class="c1">#%%</span>
    <span class="c1">#TODO: add bandgap finding</span>
    
<div class="viewcode-block" id="Spectral_image.cluster"><a class="viewcode-back" href="../modules/image_class_bs.html#image_class_bs.Spectral_image.cluster">[docs]</a>    <span class="k">def</span> <span class="nf">cluster</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">n_clusters</span> <span class="o">=</span> <span class="mi">5</span><span class="p">,</span> <span class="n">n_iterations</span> <span class="o">=</span> <span class="mi">30</span><span class="p">,</span> <span class="n">based_upon</span> <span class="o">=</span> <span class="s2">&quot;log&quot;</span><span class="p">):</span>
        <span class="c1">#TODO: add other based_upons</span>
        <span class="k">if</span> <span class="n">based_upon</span> <span class="o">==</span> <span class="s2">&quot;sum&quot;</span><span class="p">:</span>
            <span class="n">values</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">,</span> <span class="n">axis</span> <span class="o">=</span> <span class="mi">2</span><span class="p">)</span><span class="o">.</span><span class="n">flatten</span><span class="p">()</span>
        <span class="k">elif</span> <span class="n">based_upon</span> <span class="o">==</span> <span class="s2">&quot;log&quot;</span><span class="p">:</span>
            <span class="n">values</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">,</span> <span class="n">axis</span> <span class="o">=</span> <span class="mi">2</span><span class="p">)</span><span class="o">.</span><span class="n">flatten</span><span class="p">())</span>
        <span class="k">elif</span> <span class="n">based_upon</span> <span class="o">==</span> <span class="s2">&quot;thickness&quot;</span><span class="p">:</span>
            <span class="n">values</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">t</span><span class="o">.</span><span class="n">flatten</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">values</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">,</span> <span class="n">axis</span> <span class="o">=</span> <span class="mi">2</span><span class="p">)</span><span class="o">.</span><span class="n">flatten</span><span class="p">()</span>
        <span class="n">clusters_unsorted</span><span class="p">,</span> <span class="n">r</span> <span class="o">=</span> <span class="n">k_means</span><span class="p">(</span><span class="n">values</span><span class="p">,</span> <span class="n">n_clusters</span> <span class="o">=</span> <span class="n">n_clusters</span><span class="p">,</span> <span class="n">n_iterations</span> <span class="o">=</span><span class="n">n_iterations</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">clusters</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">clusters_unsorted</span><span class="p">)[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">arg_sort_clusters</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argsort</span><span class="p">(</span><span class="n">clusters_unsorted</span><span class="p">)[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">clustered</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">image_shape</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_clusters</span><span class="p">):</span>
            <span class="n">in_cluster_i</span> <span class="o">=</span> <span class="n">r</span><span class="p">[</span><span class="n">arg_sort_clusters</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">clustered</span> <span class="o">+=</span> <span class="p">((</span><span class="n">np</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">in_cluster_i</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">image_shape</span><span class="p">))</span><span class="o">*</span><span class="n">i</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">clustered</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">clustered</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span></div>
    
    
<div class="viewcode-block" id="Spectral_image.cluster_on_cluster_values"><a class="viewcode-back" href="../modules/image_class_bs.html#image_class_bs.Spectral_image.cluster_on_cluster_values">[docs]</a>    <span class="k">def</span> <span class="nf">cluster_on_cluster_values</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">cluster_values</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">clusters</span> <span class="o">=</span> <span class="n">cluster_values</span>
        
        <span class="n">values</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">,</span> <span class="n">axis</span> <span class="o">=</span> <span class="mi">2</span><span class="p">)</span>
        <span class="n">check_log</span> <span class="o">=</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">nanpercentile</span><span class="p">(</span><span class="n">values</span><span class="p">,</span><span class="mi">5</span><span class="p">)</span><span class="o">&gt;</span><span class="n">cluster_values</span><span class="o">.</span><span class="n">max</span><span class="p">())</span>
        <span class="k">if</span> <span class="n">check_log</span><span class="p">:</span>
            <span class="n">values</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">values</span><span class="p">)</span>
        <span class="n">valar</span> <span class="o">=</span> <span class="p">(</span><span class="n">values</span><span class="o">.</span><span class="n">transpose</span><span class="p">()</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">image_shape</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_clusters</span><span class="p">))</span><span class="o">.</span><span class="n">transpose</span><span class="p">())</span><span class="o">.</span><span class="n">transpose</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">clustered</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argmin</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">absolute</span><span class="p">(</span><span class="n">valar</span> <span class="o">-</span> <span class="n">cluster_values</span><span class="p">),</span><span class="n">axis</span> <span class="o">=</span> <span class="mi">2</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">clustered</span><span class="p">))</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_clusters</span><span class="p">:</span>
            <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s2">&quot;it seems like the clustered values of dE1 are not clustered on this image/on log or sum. Please check clustering.&quot;</span><span class="p">)</span></div>
        
    
    <span class="c1">#PLOTTING FUNCTIONS</span>
<div class="viewcode-block" id="Spectral_image.plot_sum"><a class="viewcode-back" href="../modules/image_class_bs.html#image_class_bs.Spectral_image.plot_sum">[docs]</a>    <span class="k">def</span> <span class="nf">plot_sum</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">title</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">xlab</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">ylab</span> <span class="o">=</span> <span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        INPUT:</span>
<span class="sd">            self -- spectral image </span>
<span class="sd">            title -- str, delfault = None, title of plot</span>
<span class="sd">            xlab -- str, default = None, x-label</span>
<span class="sd">            ylab -- str, default = None, y-label</span>
<span class="sd">        OUTPUT:</span>
<span class="sd">        Plots the summation over the intensity for each pixel in a heatmap.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1">#TODO: invert colours</span>
        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s1">&#39;name&#39;</span><span class="p">):</span>
            <span class="n">name</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">name</span> <span class="o">=</span> <span class="s1">&#39;&#39;</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">title</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">plt</span><span class="o">.</span><span class="n">title</span><span class="p">(</span><span class="s2">&quot;intgrated intensity spectrum &quot;</span> <span class="o">+</span> <span class="n">name</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">plt</span><span class="o">.</span><span class="n">title</span><span class="p">(</span><span class="n">title</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s1">&#39;pixelsize&#39;</span><span class="p">):</span>
        <span class="c1">#    plt.xlabel(self.pixelsize)</span>
        <span class="c1">#    plt.ylabel(self.pixelsize)</span>
            <span class="n">plt</span><span class="o">.</span><span class="n">xlabel</span><span class="p">(</span><span class="s2">&quot;[m]&quot;</span><span class="p">)</span>
            <span class="n">plt</span><span class="o">.</span><span class="n">ylabel</span><span class="p">(</span><span class="s2">&quot;[m]&quot;</span><span class="p">)</span>
            <span class="n">xticks</span><span class="p">,</span> <span class="n">yticks</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_ticks</span><span class="p">()</span>
            <span class="n">ax</span> <span class="o">=</span> <span class="n">sns</span><span class="o">.</span><span class="n">heatmap</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">,</span> <span class="n">axis</span> <span class="o">=</span> <span class="mi">2</span><span class="p">),</span> <span class="n">xticklabels</span><span class="o">=</span><span class="n">xticks</span><span class="p">,</span> <span class="n">yticklabels</span><span class="o">=</span><span class="n">yticks</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">ax</span> <span class="o">=</span> <span class="n">sns</span><span class="o">.</span><span class="n">heatmap</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">,</span> <span class="n">axis</span> <span class="o">=</span> <span class="mi">2</span><span class="p">))</span>
        <span class="k">if</span> <span class="n">xlab</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">plt</span><span class="o">.</span><span class="n">xlabel</span><span class="p">(</span><span class="n">xlab</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">ylab</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">plt</span><span class="o">.</span><span class="n">ylabel</span><span class="p">(</span><span class="n">ylab</span><span class="p">)</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span></div>
        
<div class="viewcode-block" id="Spectral_image.plot_heatmap"><a class="viewcode-back" href="../modules/image_class_bs.html#image_class_bs.Spectral_image.plot_heatmap">[docs]</a>    <span class="k">def</span> <span class="nf">plot_heatmap</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">title</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">xlab</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">ylab</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">cmap</span> <span class="o">=</span> <span class="s1">&#39;coolwarm&#39;</span><span class="p">,</span> <span class="n">discrete_colormap</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span> <span class="n">sig</span> <span class="o">=</span> <span class="mi">2</span><span class="p">,</span> <span class="n">save_as</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span> <span class="n">color_bin_size</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">equal_axis</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        INPUT:</span>
<span class="sd">            self -- spectral image </span>
<span class="sd">            title -- str, delfault = None, title of plot</span>
<span class="sd">            xlab -- str, default = None, x-label</span>
<span class="sd">            ylab -- str, default = None, y-label</span>
<span class="sd">        OUTPUT:</span>
<span class="sd">        Plots the summation over the intensity for each pixel in a heatmap.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1">#TODO: invert colours</span>
        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s1">&#39;name&#39;</span><span class="p">):</span>
            <span class="n">name</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">name</span> <span class="o">=</span> <span class="s1">&#39;&#39;</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">title</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">plt</span><span class="o">.</span><span class="n">title</span><span class="p">(</span><span class="s2">&quot;intgrated intensity spectrum &quot;</span> <span class="o">+</span> <span class="n">name</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">plt</span><span class="o">.</span><span class="n">title</span><span class="p">(</span><span class="n">title</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">discrete_colormap</span><span class="p">:</span>
            <span class="k">if</span> <span class="s1">&#39;mask&#39;</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="p">:</span>
                <span class="n">mask</span> <span class="o">=</span> <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;mask&#39;</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">mask</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s1">&#39;bool&#39;</span><span class="p">)</span> 
            
            
            <span class="n">unique_data_points</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="o">~</span><span class="n">mask</span><span class="p">])</span>
            
            <span class="k">if</span> <span class="s1">&#39;vmax&#39;</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="p">:</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">unique_data_points</span><span class="p">[</span><span class="n">unique_data_points</span> <span class="o">&gt;</span> <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;vmax&#39;</span><span class="p">]])</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">unique_data_points</span> <span class="o">=</span> <span class="n">unique_data_points</span><span class="p">[</span><span class="n">unique_data_points</span> <span class="o">&lt;=</span> <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;vmax&#39;</span><span class="p">]]</span>
                    <span class="n">unique_data_points</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">unique_data_points</span><span class="p">,</span> <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;vmax&#39;</span><span class="p">])</span>
            <span class="k">if</span>  <span class="s1">&#39;vmin&#39;</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="p">:</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">unique_data_points</span><span class="p">[</span><span class="n">unique_data_points</span> <span class="o">&lt;</span> <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;vmin&#39;</span><span class="p">]])</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">unique_data_points</span> <span class="o">=</span> <span class="n">unique_data_points</span><span class="p">[</span><span class="n">unique_data_points</span> <span class="o">&gt;=</span> <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;vmin&#39;</span><span class="p">]]</span>
                    <span class="n">unique_data_points</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;vmin&#39;</span><span class="p">],</span> <span class="n">unique_data_points</span><span class="p">)</span>
            
            <span class="k">if</span> <span class="n">color_bin_size</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">color_bin_size</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nanpercentile</span><span class="p">(</span><span class="n">unique_data_points</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span><span class="o">-</span><span class="n">unique_data_points</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span><span class="mi">30</span><span class="p">)</span>
            <span class="n">n_colors</span> <span class="o">=</span> <span class="nb">int</span><span class="p">((</span><span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">unique_data_points</span><span class="p">)</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">unique_data_points</span><span class="p">))</span><span class="o">/</span><span class="n">color_bin_size</span> <span class="o">+</span><span class="mi">1</span><span class="p">)</span>
            <span class="n">cmap</span> <span class="o">=</span> <span class="n">cm</span><span class="o">.</span><span class="n">get_cmap</span><span class="p">(</span><span class="n">cmap</span><span class="p">,</span> <span class="n">n_colors</span><span class="p">)</span>
            <span class="n">spacing</span> <span class="o">=</span> <span class="n">color_bin_size</span><span class="o">/</span><span class="mi">2</span>
            
            <span class="k">if</span> <span class="ow">not</span> <span class="s1">&#39;vmax&#39;</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="p">:</span>
                <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;vmax&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="o">~</span><span class="n">mask</span><span class="p">])</span><span class="o">+</span><span class="n">spacing</span>
                <span class="c1"># print(&quot;vmax&quot;, kwargs[&#39;vmax&#39;])</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="s1">&#39;vmin&#39;</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="p">:</span>
                <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;vmin&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="o">~</span><span class="n">mask</span><span class="p">])</span><span class="o">-</span><span class="n">spacing</span> 
            
            <span class="c1"># print(&quot;spacing&quot;, spacing, &quot;vmax&quot;, kwargs[&#39;vmax&#39;], &quot;vmin&quot;, kwargs[&#39;vmin&#39;])</span>
        <span class="k">if</span> <span class="n">equal_axis</span><span class="p">:</span>
            <span class="n">plt</span><span class="o">.</span><span class="n">axis</span><span class="p">(</span><span class="s1">&#39;equal&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s1">&#39;pixelsize&#39;</span><span class="p">):</span>
            <span class="n">plt</span><span class="o">.</span><span class="n">xlabel</span><span class="p">(</span><span class="s2">&quot;[m]&quot;</span><span class="p">)</span>
            <span class="n">plt</span><span class="o">.</span><span class="n">ylabel</span><span class="p">(</span><span class="s2">&quot;[m]&quot;</span><span class="p">)</span>
            <span class="n">xticks</span><span class="p">,</span> <span class="n">yticks</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_ticks</span><span class="p">(</span><span class="n">sig</span> <span class="o">=</span> <span class="n">sig</span><span class="p">)</span>
            <span class="n">ax</span> <span class="o">=</span> <span class="n">sns</span><span class="o">.</span><span class="n">heatmap</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">xticklabels</span><span class="o">=</span><span class="n">xticks</span><span class="p">,</span> <span class="n">yticklabels</span><span class="o">=</span><span class="n">yticks</span><span class="p">,</span> <span class="n">cmap</span><span class="o">=</span><span class="n">cmap</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">ax</span> <span class="o">=</span> <span class="n">sns</span><span class="o">.</span><span class="n">heatmap</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">xlab</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">plt</span><span class="o">.</span><span class="n">xlabel</span><span class="p">(</span><span class="n">xlab</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">plt</span><span class="o">.</span><span class="n">xlabel</span><span class="p">(</span><span class="s1">&#39;[micron]&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">ylab</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">plt</span><span class="o">.</span><span class="n">ylabel</span><span class="p">(</span><span class="n">ylab</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">plt</span><span class="o">.</span><span class="n">ylabel</span><span class="p">(</span><span class="s1">&#39;[micron]&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">discrete_colormap</span><span class="p">:</span>
            <span class="c1">#TODO: even space in colorbar</span>
            <span class="n">colorbar</span> <span class="o">=</span> <span class="n">ax</span><span class="o">.</span><span class="n">collections</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">colorbar</span>
            <span class="k">if</span> <span class="n">data</span><span class="o">.</span><span class="n">dtype</span> <span class="o">==</span> <span class="nb">int</span><span class="p">:</span>
                <span class="n">colorbar</span><span class="o">.</span><span class="n">set_ticks</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="o">~</span><span class="n">mask</span><span class="p">]))</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">cbar_ticks</span> <span class="o">=</span> <span class="p">[]</span>
                <span class="k">for</span> <span class="n">tick</span> <span class="ow">in</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="o">~</span><span class="n">mask</span><span class="p">]):</span>
                    <span class="c1"># fmt = &#39;%.&#39; + str(sig) + &#39;g&#39;</span>
                    <span class="c1"># cbar_ticks.append(&#39;%s&#39; % float(fmt % tick))</span>
                    <span class="n">cbar_ticks</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">round_scientific</span><span class="p">(</span><span class="n">tick</span><span class="p">,</span> <span class="n">sig</span><span class="p">))</span>
                <span class="n">colorbar</span><span class="o">.</span><span class="n">set_ticks</span><span class="p">(</span><span class="n">cbar_ticks</span><span class="p">)</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">save_as</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">save_as</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">str</span><span class="p">:</span>
                <span class="n">save_as</span> <span class="o">=</span> <span class="n">name</span>
            <span class="k">if</span> <span class="s1">&#39;mask&#39;</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="p">:</span>
                <span class="n">save_as</span> <span class="o">+=</span> <span class="s1">&#39;_masked&#39;</span>
            <span class="n">save_as</span> <span class="o">+=</span> <span class="s1">&#39;.pdf&#39;</span>
            <span class="n">plt</span><span class="o">.</span><span class="n">savefig</span><span class="p">(</span><span class="n">save_as</span><span class="p">)</span></div>
    
<div class="viewcode-block" id="Spectral_image.get_ticks"><a class="viewcode-back" href="../modules/image_class_bs.html#image_class_bs.Spectral_image.get_ticks">[docs]</a>    <span class="k">def</span> <span class="nf">get_ticks</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">sig</span> <span class="o">=</span> <span class="mi">2</span><span class="p">,</span> <span class="n">n_tick</span> <span class="o">=</span> <span class="mi">10</span><span class="p">):</span>
        <span class="n">fmt</span> <span class="o">=</span> <span class="s1">&#39;%.&#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">sig</span><span class="p">)</span> <span class="o">+</span> <span class="s1">&#39;g&#39;</span>
        <span class="n">xlabels</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">x_axis</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span><span class="n">dtype</span> <span class="o">=</span> <span class="nb">object</span><span class="p">)</span>
        <span class="n">xlabels</span><span class="p">[:]</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span>
        <span class="n">each_n_pixels</span> <span class="o">=</span> <span class="n">math</span><span class="o">.</span><span class="n">floor</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">xlabels</span><span class="p">)</span><span class="o">/</span><span class="n">n_tick</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">xlabels</span><span class="p">)):</span>
            <span class="k">if</span> <span class="n">i</span><span class="o">%</span><span class="n">each_n_pixels</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">xlabels</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;</span><span class="si">%s</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="nb">float</span><span class="p">(</span><span class="n">fmt</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">x_axis</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
        <span class="n">ylabels</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">y_axis</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span><span class="n">dtype</span> <span class="o">=</span> <span class="nb">object</span><span class="p">)</span>
        <span class="n">ylabels</span><span class="p">[:]</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span>
        <span class="n">each_n_pixels</span> <span class="o">=</span> <span class="n">math</span><span class="o">.</span><span class="n">floor</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">ylabels</span><span class="p">)</span><span class="o">/</span><span class="n">n_tick</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">ylabels</span><span class="p">)):</span>
            <span class="k">if</span> <span class="n">i</span><span class="o">%</span><span class="n">each_n_pixels</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">ylabels</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;</span><span class="si">%s</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="nb">float</span><span class="p">(</span><span class="n">fmt</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">y_axis</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
        <span class="k">return</span> <span class="n">xlabels</span><span class="p">,</span> <span class="n">ylabels</span></div>
                
    
<div class="viewcode-block" id="Spectral_image.plot_all"><a class="viewcode-back" href="../modules/image_class_bs.html#image_class_bs.Spectral_image.plot_all">[docs]</a>    <span class="k">def</span> <span class="nf">plot_all</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">same_image</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span> <span class="n">normalize</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span> <span class="n">legend</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span> 
                 <span class="n">range_x</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">range_y</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">range_E</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">signal</span> <span class="o">=</span> <span class="s2">&quot;EELS&quot;</span><span class="p">,</span> <span class="n">log</span> <span class="o">=</span> <span class="kc">False</span><span class="p">):</span>
        <span class="c1">#TODO: add titles and such</span>
        <span class="k">if</span> <span class="n">range_x</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">range_x</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">image_shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span>
        <span class="k">if</span> <span class="n">range_y</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">range_y</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">image_shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span>
        <span class="k">if</span> <span class="n">same_image</span><span class="p">:</span>
            <span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">()</span>
            <span class="n">plt</span><span class="o">.</span><span class="n">title</span><span class="p">(</span><span class="s2">&quot;Spectrum image &quot;</span> <span class="o">+</span> <span class="n">signal</span> <span class="o">+</span> <span class="s2">&quot; spectra&quot;</span><span class="p">)</span>
            <span class="n">plt</span><span class="o">.</span><span class="n">xlabel</span><span class="p">(</span><span class="s2">&quot;[eV]&quot;</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">range_E</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">plt</span><span class="o">.</span><span class="n">xlim</span><span class="p">(</span><span class="n">range_E</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">range_y</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">range_y</span><span class="p">[</span><span class="mi">1</span><span class="p">]):</span>
            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">range_x</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">range_x</span><span class="p">[</span><span class="mi">1</span><span class="p">]):</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">same_image</span><span class="p">:</span>
                    <span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">()</span>
                    <span class="n">plt</span><span class="o">.</span><span class="n">title</span><span class="p">(</span><span class="s2">&quot;Spectrum pixel: [&quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">j</span><span class="p">)</span> <span class="o">+</span><span class="s2">&quot;,&quot;</span><span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="o">+</span> <span class="s2">&quot;]&quot;</span><span class="p">)</span>
                    <span class="n">plt</span><span class="o">.</span><span class="n">xlabel</span><span class="p">(</span><span class="s2">&quot;[eV]&quot;</span><span class="p">)</span>
                    <span class="k">if</span> <span class="n">range_E</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                        <span class="n">plt</span><span class="o">.</span><span class="n">xlim</span><span class="p">(</span><span class="n">range_E</span><span class="p">)</span>
                    <span class="k">if</span> <span class="n">legend</span><span class="p">:</span> 
                        <span class="n">plt</span><span class="o">.</span><span class="n">legend</span><span class="p">()</span>
                <span class="n">signal_pixel</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_pixel_signal</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">,</span><span class="n">signal</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">normalize</span><span class="p">:</span>
                    <span class="n">signal_pixel</span> <span class="o">/=</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">absolute</span><span class="p">(</span><span class="n">signal_pixel</span><span class="p">))</span>
                <span class="k">if</span> <span class="n">log</span><span class="p">:</span>
                    <span class="n">signal_pixel</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">signal_pixel</span><span class="p">)</span>
                    <span class="n">plt</span><span class="o">.</span><span class="n">ylabel</span><span class="p">(</span><span class="s2">&quot;log intensity&quot;</span><span class="p">)</span>
                <span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">deltaE</span><span class="p">,</span> <span class="n">signal_pixel</span><span class="p">,</span> <span class="n">label</span> <span class="o">=</span> <span class="s2">&quot;[&quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">j</span><span class="p">)</span> <span class="o">+</span><span class="s2">&quot;,&quot;</span><span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="o">+</span> <span class="s2">&quot;]&quot;</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">legend</span><span class="p">:</span> 
                <span class="n">plt</span><span class="o">.</span><span class="n">legend</span><span class="p">()</span></div>
                
    
    <span class="c1">#GENERAL FUNCTIONS</span>
<div class="viewcode-block" id="Spectral_image.get_key"><a class="viewcode-back" href="../modules/image_class_bs.html#image_class_bs.Spectral_image.get_key">[docs]</a>    <span class="k">def</span> <span class="nf">get_key</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">key</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="ow">in</span> <span class="p">(</span><span class="n">string</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="k">for</span> <span class="n">string</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">EELS_NAMES</span><span class="p">):</span>
            <span class="k">return</span> <span class="s1">&#39;data&#39;</span>
        <span class="k">elif</span> <span class="n">key</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="ow">in</span> <span class="p">(</span><span class="n">string</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="k">for</span> <span class="n">string</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">IEELS_NAMES</span><span class="p">):</span>
            <span class="k">return</span> <span class="s1">&#39;ieels&#39;</span>
        <span class="k">elif</span> <span class="n">key</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="ow">in</span> <span class="p">(</span><span class="n">string</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="k">for</span> <span class="n">string</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">ZLP_NAMES</span><span class="p">):</span>
            <span class="k">return</span> <span class="s1">&#39;zlp&#39;</span>
        <span class="k">elif</span> <span class="n">key</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="ow">in</span> <span class="p">(</span><span class="n">string</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="k">for</span> <span class="n">string</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">DIELECTRIC_FUNCTION_NAMES</span><span class="p">):</span>
            <span class="k">return</span> <span class="s1">&#39;eps&#39;</span>
        <span class="k">elif</span> <span class="n">key</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="ow">in</span> <span class="p">(</span><span class="n">string</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="k">for</span> <span class="n">string</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">THICKNESS_NAMES</span><span class="p">):</span>
            <span class="k">return</span> <span class="s1">&#39;thickness&#39;</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">key</span></div>
        
    
    
    <span class="c1">#STATIC METHODS</span>
<div class="viewcode-block" id="Spectral_image.get_prefix"><a class="viewcode-back" href="../modules/image_class_bs.html#image_class_bs.Spectral_image.get_prefix">[docs]</a>    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">get_prefix</span><span class="p">(</span><span class="n">unit</span><span class="p">,</span> <span class="n">SIunit</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">numeric</span> <span class="o">=</span> <span class="kc">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        INPUT:</span>
<span class="sd">            unit -- str, unit of which the prefix is wanted</span>
<span class="sd">            SIunit -- str, default = None, the SI unit of the unit of which the prefix is wanted \</span>
<span class="sd">                        (eg &#39;eV&#39; for &#39;keV&#39;), if None, first character of unit is evaluated as prefix</span>
<span class="sd">            numeric -- bool, default = True, if numeric the prefix is translated to the numeric value \</span>
<span class="sd">                        (e.g. 1E3 for &#39;k&#39;)</span>
<span class="sd">        OUTPUT:</span>
<span class="sd">            prefix -- str or int, the character of the prefix or the numeric value of the prefix</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">SIunit</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">lenSI</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">SIunit</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">unit</span><span class="p">[</span><span class="o">-</span><span class="n">lenSI</span><span class="p">:]</span> <span class="o">==</span> <span class="n">SIunit</span><span class="p">:</span>
                <span class="n">prefix</span> <span class="o">=</span> <span class="n">unit</span><span class="p">[:</span><span class="o">-</span><span class="n">lenSI</span><span class="p">]</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">prefix</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">numeric</span><span class="p">:</span> <span class="k">return</span> <span class="mi">1</span>
                    <span class="k">else</span><span class="p">:</span> <span class="k">return</span> <span class="n">prefix</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;provided unit not same as target unit: &quot;</span> <span class="o">+</span> <span class="n">unit</span> <span class="o">+</span> <span class="s2">&quot;, and &quot;</span> <span class="o">+</span> <span class="n">SIunit</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">numeric</span><span class="p">:</span> <span class="k">return</span> <span class="mi">1</span>
                <span class="k">else</span><span class="p">:</span> <span class="k">return</span> <span class="n">prefix</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">prefix</span> <span class="o">=</span> <span class="n">unit</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">numeric</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">prefix</span>
        
        <span class="k">if</span> <span class="n">prefix</span> <span class="o">==</span> <span class="s1">&#39;p&#39;</span><span class="p">:</span>
            <span class="k">return</span> <span class="mf">1E-12</span>
        <span class="k">if</span> <span class="n">prefix</span> <span class="o">==</span> <span class="s1">&#39;n&#39;</span><span class="p">:</span>
            <span class="k">return</span> <span class="mf">1E-9</span>
        <span class="k">if</span> <span class="n">prefix</span> <span class="o">==</span> <span class="s1">&#39;μ&#39;</span> <span class="ow">or</span> <span class="n">prefix</span> <span class="o">==</span> <span class="s1">&#39;µ&#39;</span> <span class="ow">or</span> <span class="n">prefix</span> <span class="o">==</span> <span class="s1">&#39;u&#39;</span><span class="p">:</span>
            <span class="k">return</span> <span class="mf">1E-6</span>
        <span class="k">if</span> <span class="n">prefix</span> <span class="o">==</span> <span class="s1">&#39;m&#39;</span><span class="p">:</span>
            <span class="k">return</span> <span class="mf">1E-3</span>
        <span class="k">if</span> <span class="n">prefix</span> <span class="o">==</span> <span class="s1">&#39;k&#39;</span><span class="p">:</span>
            <span class="k">return</span> <span class="mf">1E3</span>
        <span class="k">if</span> <span class="n">prefix</span> <span class="o">==</span> <span class="s1">&#39;M&#39;</span><span class="p">:</span>
            <span class="k">return</span> <span class="mf">1E6</span>
        <span class="k">if</span> <span class="n">prefix</span> <span class="o">==</span> <span class="s1">&#39;G&#39;</span><span class="p">:</span>
            <span class="k">return</span> <span class="mf">1E9</span>
        <span class="k">if</span> <span class="n">prefix</span> <span class="o">==</span> <span class="s1">&#39;T&#39;</span><span class="p">:</span>
            <span class="k">return</span> <span class="mf">1E12</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;either no or unknown prefix in unit: &quot;</span> <span class="o">+</span> <span class="n">unit</span> <span class="o">+</span> <span class="s2">&quot;, found prefix &quot;</span> <span class="o">+</span> <span class="n">prefix</span> <span class="o">+</span> <span class="s2">&quot;, asuming no.&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="mi">1</span></div>
    
<div class="viewcode-block" id="Spectral_image.calc_avg_ci"><a class="viewcode-back" href="../modules/image_class_bs.html#image_class_bs.Spectral_image.calc_avg_ci">[docs]</a>    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">calc_avg_ci</span><span class="p">(</span><span class="n">np_array</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">ci</span> <span class="o">=</span> <span class="mi">16</span><span class="p">,</span> <span class="n">return_low_high</span> <span class="o">=</span> <span class="kc">True</span><span class="p">):</span>
        <span class="n">avg</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">average</span><span class="p">(</span><span class="n">np_array</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">)</span>
        <span class="n">ci_low</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nanpercentile</span><span class="p">(</span><span class="n">np_array</span><span class="p">,</span>  <span class="n">ci</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">)</span>
        <span class="n">ci_high</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nanpercentile</span><span class="p">(</span><span class="n">np_array</span><span class="p">,</span>  <span class="mi">100</span><span class="o">-</span><span class="n">ci</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">return_low_high</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">avg</span><span class="p">,</span> <span class="n">ci_low</span><span class="p">,</span> <span class="n">ci_high</span>
        <span class="k">return</span> <span class="n">avg</span><span class="p">,</span> <span class="n">ci_high</span><span class="o">-</span><span class="n">ci_low</span></div>
    
    <span class="c1">#CLASS THINGIES</span>
    <span class="k">def</span> <span class="fm">__getitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Determines behavior of `self[key]` &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="n">key</span><span class="p">]</span>
        <span class="c1">#pass</span>
    
    <span class="k">def</span> <span class="fm">__getattr__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">):</span>
        <span class="n">key</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_key</span><span class="p">(</span><span class="n">key</span><span class="p">)</span>
        <span class="k">return</span> <span class="nb">object</span><span class="o">.</span><span class="fm">__getattribute__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">)</span>
    
    <span class="k">def</span> <span class="fm">__setattr__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="n">key</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_key</span><span class="p">(</span><span class="n">key</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="vm">__dict__</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">value</span>
    	

    
    
    <span class="k">def</span> <span class="fm">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s1">&#39;name&#39;</span><span class="p">):</span>
            <span class="n">name_str</span> <span class="o">=</span> <span class="s2">&quot;, name = &quot;</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">name_str</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span>
        <span class="k">return</span> <span class="s1">&#39;Spectral image: &#39;</span> <span class="o">+</span> <span class="n">name_str</span> <span class="o">+</span> <span class="s2">&quot;, image size:&quot;</span><span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">+</span> <span class="s1">&#39;x&#39;</span> <span class="o">+</span> \
                    <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span> <span class="o">+</span> <span class="s1">&#39;, deltaE range: [&#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="nb">round</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">deltaE</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="mi">3</span><span class="p">))</span> <span class="o">+</span> <span class="s1">&#39;,&#39;</span> <span class="o">+</span> \
                        <span class="nb">str</span><span class="p">(</span><span class="nb">round</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">deltaE</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span><span class="mi">3</span><span class="p">))</span> <span class="o">+</span> <span class="s1">&#39;], deltadeltaE: &#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="nb">round</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ddeltaE</span><span class="p">,</span><span class="mi">3</span><span class="p">))</span>
        
    <span class="k">def</span> <span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">data_str</span> <span class="o">=</span> <span class="s2">&quot;data * np.ones(&quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="o">+</span> <span class="s2">&quot;)&quot;</span>
        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s1">&#39;name&#39;</span><span class="p">):</span>
            <span class="n">name_str</span> <span class="o">=</span> <span class="s2">&quot;, name = &quot;</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">name_str</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span>
        <span class="k">return</span> <span class="s2">&quot;Spectral_image(&quot;</span> <span class="o">+</span> <span class="n">data_str</span> <span class="o">+</span>  <span class="s2">&quot;, deltadeltaE=&quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="nb">round</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ddeltaE</span><span class="p">,</span> <span class="mi">3</span><span class="p">))</span> <span class="o">+</span> <span class="n">name_str</span> <span class="o">+</span> <span class="s2">&quot;)&quot;</span>
        
    <span class="k">def</span> <span class="fm">__len__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">l</span></div>
            

<span class="c1"># GENERAL DATA MODIFICATION FUNCTIONS  </span>

<div class="viewcode-block" id="CFT"><a class="viewcode-back" href="../modules/image_class_bs.html#image_class_bs.CFT">[docs]</a><span class="k">def</span> <span class="nf">CFT</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">):</span>
    <span class="n">x_0</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
    <span class="n">N_0</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argmin</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">absolute</span><span class="p">(</span><span class="n">x</span><span class="p">))</span>
    <span class="n">N</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
    <span class="n">x_max</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
    <span class="n">delta_x</span> <span class="o">=</span> <span class="p">(</span><span class="n">x_max</span><span class="o">-</span><span class="n">x_0</span><span class="p">)</span><span class="o">/</span><span class="n">N</span>
    <span class="n">k</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">N</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">N</span><span class="p">)</span>
    <span class="n">cont_factor</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="mi">2</span><span class="n">j</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">*</span><span class="n">N_0</span><span class="o">*</span><span class="n">k</span><span class="o">/</span><span class="n">N</span><span class="p">)</span><span class="o">*</span><span class="n">delta_x</span> <span class="c1">#np.exp(-1j*(x_0)*k*delta_omg)*delta_x</span>
    <span class="n">F_k</span> <span class="o">=</span> <span class="n">cont_factor</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">fft</span><span class="o">.</span><span class="n">fft</span><span class="p">(</span><span class="n">y</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">F_k</span></div>

<div class="viewcode-block" id="iCFT"><a class="viewcode-back" href="../modules/image_class_bs.html#image_class_bs.iCFT">[docs]</a><span class="k">def</span> <span class="nf">iCFT</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">Y_k</span><span class="p">):</span>
    <span class="n">x_0</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
    <span class="n">N_0</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argmin</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">absolute</span><span class="p">(</span><span class="n">x</span><span class="p">))</span>
    <span class="n">x_max</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
    <span class="n">N</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
    <span class="n">delta_x</span> <span class="o">=</span> <span class="p">(</span><span class="n">x_max</span><span class="o">-</span><span class="n">x_0</span><span class="p">)</span><span class="o">/</span><span class="n">N</span>
    <span class="n">k</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">N</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">N</span><span class="p">)</span>
    <span class="n">cont_factor</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="mi">2</span><span class="n">j</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">*</span><span class="n">N_0</span><span class="o">*</span><span class="n">k</span><span class="o">/</span><span class="n">N</span><span class="p">)</span>
    <span class="n">f_n</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">fft</span><span class="o">.</span><span class="n">ifft</span><span class="p">(</span><span class="n">cont_factor</span><span class="o">*</span><span class="n">Y_k</span><span class="p">)</span><span class="o">/</span><span class="n">delta_x</span> <span class="c1"># 2*np.pi ##np.exp(-2j*np.pi*x_0*k)</span>
    <span class="k">return</span> <span class="n">f_n</span>            </div>


<div class="viewcode-block" id="smooth_1D"><a class="viewcode-back" href="../modules/image_class_bs.html#image_class_bs.smooth_1D">[docs]</a><span class="k">def</span> <span class="nf">smooth_1D</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">window_len</span><span class="o">=</span><span class="mi">50</span><span class="p">,</span><span class="n">window</span><span class="o">=</span><span class="s1">&#39;hanning&#39;</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;smooth the data using a window with requested size.</span>

<span class="sd">    This method is based on the convolution of a scaled window with the signal.</span>
<span class="sd">    The signal is prepared by introducing reflected copies of the signal </span>
<span class="sd">    (with the window size) in both ends so that transient parts are minimized</span>
<span class="sd">    in the begining and end part of the output signal.</span>

<span class="sd">    input:</span>
<span class="sd">        x: the input signal </span>
<span class="sd">        window_len: the dimension of the smoothing window; should be an odd integer</span>
<span class="sd">        window: the type of window from &#39;flat&#39;, &#39;hanning&#39;, &#39;hamming&#39;, &#39;bartlett&#39;, &#39;blackman&#39;</span>
<span class="sd">            flat window will produce a moving average smoothing.</span>

<span class="sd">    output:</span>
<span class="sd">        the smoothed signal</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1">#TODO: add comnparison</span>
    <span class="n">window_len</span> <span class="o">+=</span> <span class="p">(</span><span class="n">window_len</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">%</span><span class="mi">2</span>
    <span class="n">s</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">r_</span><span class="p">[</span><span class="s1">&#39;-1&#39;</span><span class="p">,</span> <span class="n">data</span><span class="p">[</span><span class="n">window_len</span><span class="o">-</span><span class="mi">1</span><span class="p">:</span><span class="mi">0</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span><span class="n">data</span><span class="p">,</span><span class="n">data</span><span class="p">[</span><span class="o">-</span><span class="mi">2</span><span class="p">:</span><span class="o">-</span><span class="n">window_len</span><span class="o">-</span><span class="mi">1</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">]]</span>

    <span class="k">if</span> <span class="n">window</span> <span class="o">==</span> <span class="s1">&#39;flat&#39;</span><span class="p">:</span> <span class="c1">#moving average</span>
        <span class="n">w</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">window_len</span><span class="p">,</span><span class="s1">&#39;d&#39;</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">w</span><span class="o">=</span><span class="nb">eval</span><span class="p">(</span><span class="s1">&#39;np.&#39;</span><span class="o">+</span><span class="n">window</span><span class="o">+</span><span class="s1">&#39;(window_len)&#39;</span><span class="p">)</span>

    <span class="c1"># y=np.convolve(w/w.sum(),s,mode=&#39;valid&#39;)</span>
    <span class="c1"># return y[(window_len-1):-(window_len)]</span>
    <span class="n">surplus_data</span> <span class="o">=</span> <span class="nb">int</span><span class="p">((</span><span class="n">window_len</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="mf">0.5</span><span class="p">)</span>
    <span class="n">data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">apply_along_axis</span><span class="p">(</span><span class="k">lambda</span> <span class="n">m</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">convolve</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="n">w</span><span class="o">/</span><span class="n">w</span><span class="o">.</span><span class="n">sum</span><span class="p">(),</span> <span class="n">mode</span><span class="o">=</span><span class="s1">&#39;valid&#39;</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">arr</span><span class="o">=</span><span class="n">s</span><span class="p">)[</span><span class="n">surplus_data</span><span class="p">:</span><span class="o">-</span><span class="n">surplus_data</span><span class="p">]</span>
    <span class="k">return</span> <span class="n">data</span></div>



<span class="c1"># MODELING CLASSES AND FUNCTIONS</span>
<div class="viewcode-block" id="bandgap"><a class="viewcode-back" href="../modules/image_class_bs.html#image_class_bs.bandgap">[docs]</a><span class="k">def</span> <span class="nf">bandgap</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">amp</span><span class="p">,</span> <span class="n">BG</span><span class="p">,</span><span class="n">b</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">amp</span> <span class="o">*</span> <span class="p">(</span><span class="n">x</span> <span class="o">-</span> <span class="n">BG</span><span class="p">)</span><span class="o">**</span><span class="p">(</span><span class="n">b</span><span class="p">)</span></div>

<div class="viewcode-block" id="MLP"><a class="viewcode-back" href="../modules/image_class_bs.html#image_class_bs.MLP">[docs]</a><span class="k">class</span> <span class="nc">MLP</span><span class="p">(</span><span class="n">nn</span><span class="o">.</span><span class="n">Module</span><span class="p">):</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">num_inputs</span><span class="p">,</span> <span class="n">num_outputs</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">()</span>
        <span class="c1"># Initialize the modules we need to build the network</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">linear1</span> <span class="o">=</span> <span class="n">nn</span><span class="o">.</span><span class="n">Linear</span><span class="p">(</span><span class="n">num_inputs</span><span class="p">,</span> <span class="mi">10</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">linear2</span> <span class="o">=</span> <span class="n">nn</span><span class="o">.</span><span class="n">Linear</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="mi">15</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">linear3</span> <span class="o">=</span> <span class="n">nn</span><span class="o">.</span><span class="n">Linear</span><span class="p">(</span><span class="mi">15</span><span class="p">,</span> <span class="mi">5</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">output</span> <span class="o">=</span> <span class="n">nn</span><span class="o">.</span><span class="n">Linear</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="n">num_outputs</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">sigmoid</span> <span class="o">=</span> <span class="n">nn</span><span class="o">.</span><span class="n">Sigmoid</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">relu</span> <span class="o">=</span> <span class="n">nn</span><span class="o">.</span><span class="n">ReLU</span><span class="p">()</span>

<div class="viewcode-block" id="MLP.forward"><a class="viewcode-back" href="../modules/image_class_bs.html#image_class_bs.MLP.forward">[docs]</a>    <span class="k">def</span> <span class="nf">forward</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
        <span class="c1"># Perform the calculation of the model to determine the prediction</span>
        <span class="n">x</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">linear1</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
        <span class="n">x</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">sigmoid</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
        <span class="n">x</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">linear2</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
        <span class="n">x</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">sigmoid</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
        <span class="n">x</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">linear3</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
        <span class="n">x</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">relu</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
        <span class="n">x</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">output</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">x</span></div></div>

<div class="viewcode-block" id="scale"><a class="viewcode-back" href="../modules/image_class_bs.html#image_class_bs.scale">[docs]</a><span class="k">def</span> <span class="nf">scale</span><span class="p">(</span><span class="n">inp</span><span class="p">,</span> <span class="n">ab</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    min_inp = inp.min()</span>
<span class="sd">    max_inp = inp.max()</span>
<span class="sd">    </span>
<span class="sd">    outp = inp/(max_inp-min_inp) * (max_out-min_out)</span>
<span class="sd">    outp -= outp.min()</span>
<span class="sd">    outp += min_out</span>
<span class="sd">    </span>
<span class="sd">    return outp</span>
<span class="sd">    &quot;&quot;&quot;</span>
    
    <span class="k">return</span> <span class="n">inp</span><span class="o">*</span><span class="n">ab</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">ab</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span></div>
    <span class="c1">#pass</span>

<div class="viewcode-block" id="find_scale_var"><a class="viewcode-back" href="../modules/image_class_bs.html#image_class_bs.find_scale_var">[docs]</a><span class="k">def</span> <span class="nf">find_scale_var</span><span class="p">(</span><span class="n">inp</span><span class="p">,</span> <span class="n">min_out</span> <span class="o">=</span> <span class="mf">0.1</span><span class="p">,</span> <span class="n">max_out</span><span class="o">=</span><span class="mf">0.9</span><span class="p">):</span>
    <span class="n">a</span> <span class="o">=</span> <span class="p">(</span><span class="n">max_out</span> <span class="o">-</span> <span class="n">min_out</span><span class="p">)</span><span class="o">/</span><span class="p">(</span><span class="n">inp</span><span class="o">.</span><span class="n">max</span><span class="p">()</span><span class="o">-</span> <span class="n">inp</span><span class="o">.</span><span class="n">min</span><span class="p">())</span>
    <span class="n">b</span> <span class="o">=</span> <span class="n">min_out</span> <span class="o">-</span> <span class="n">a</span><span class="o">*</span><span class="n">inp</span><span class="o">.</span><span class="n">min</span><span class="p">()</span>
    <span class="k">return</span> <span class="p">[</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">]</span></div>


<div class="viewcode-block" id="round_scientific"><a class="viewcode-back" href="../modules/image_class_bs.html#image_class_bs.round_scientific">[docs]</a><span class="k">def</span> <span class="nf">round_scientific</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">n_sig</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">value</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">return</span> <span class="mi">0</span>
    <span class="n">scale</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">math</span><span class="o">.</span><span class="n">floor</span><span class="p">(</span><span class="n">math</span><span class="o">.</span><span class="n">log10</span><span class="p">(</span><span class="nb">abs</span><span class="p">(</span><span class="n">value</span><span class="p">))))</span>
    <span class="n">num</span> <span class="o">=</span> <span class="nb">round</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">n_sig</span><span class="o">-</span><span class="n">scale</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">num</span></div>
</pre></div>

           </div>
           
          </div>
          <footer>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2021, A

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>